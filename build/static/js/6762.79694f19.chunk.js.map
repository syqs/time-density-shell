{"version":3,"file":"static/js/6762.79694f19.chunk.js","mappings":"gRAYe,SAASA,EAAcC,GAMb,IAADC,EAAAD,EALtBE,MAAAA,OAAK,IAAAD,EAAG,UAASA,EAAAE,EAAAH,EACjBI,KAAAA,OAAI,IAAAD,EAAG,EAACA,EACRE,EAAeL,EAAfK,gBACAC,EAAEN,EAAFM,GACGC,GAAKC,EAAAA,EAAAA,GAAAR,EAAAS,GAEFC,GAASC,EAAAA,EAAAA,GAAUN,EAAiB,CACxCO,UAAW,IACXC,QAAS,GACTC,UAAW,OAGb,OACEC,EAAAA,EAAAA,KAACC,EAAAA,GAAGC,EAAAA,EAAAA,GAAA,CACFC,UAAWC,EAAAA,EAAEC,IACbd,IAAEW,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,CACAI,IAAK,EACLC,KAAM,EACNC,MAAO,EACPC,OAAQpB,EACRqB,OAAQ,KACRC,SAAU,QACVC,gBAAiB,KACjBC,QAAS,gBACK,YAAV1B,GAAuB,CACzB2B,WAAY,SAACC,GAAK,iCAAAC,OACWD,EAAME,QAAQ9B,GAAO+B,MAAK,SAAAF,OAAQD,EAAME,QAAQ9B,GAAOgC,KAAI,aAEvF5B,GAEL6B,MAAO,CAAEzB,OAAAA,IACLH,GAGV,C,yXCLM6B,GAAeC,EAAAA,EAAAA,aACnB,SAAArC,EAYEsC,GAAG,IAVDC,EAAMvC,EAANuC,OACAC,EAAaxC,EAAbwC,cACAC,EAAczC,EAAdyC,eACAf,EAAQ1B,EAAR0B,SACAxB,EAAKF,EAALE,MAEAwC,GADI1C,EAAJ2C,KACO3C,EAAP0C,SAAOE,EAAA5C,EACP6C,aAAAA,OAAY,IAAAD,EAAG,WAAUA,EAAAE,EAAA9C,EACzB+C,cAAAA,OAAa,IAAAD,EAAG,CAAC,EAACA,EAAA,OAIpBE,EAAAA,EAAAA,MAAA,QAAMV,IAAKA,EAAKZ,SAAUA,EAASuB,SAAA,EACjClC,EAAAA,EAAAA,KAAA,kBAAgB4B,KAAM,CAACJ,EAAQC,EAAeC,KAC5B,UAAjBI,GACC9B,EAAAA,EAAAA,KAAA,qBAAAE,EAAAA,EAAAA,GAAA,CAAmBiC,OAAO,WAAWC,KAAMC,EAAAA,SAAUC,IAAKX,EAASxC,MAAOA,GAAW6C,KAErFhC,EAAAA,EAAAA,KAAA,wBAAAE,EAAAA,EAAAA,GAAA,CAAsBoC,IAAKX,EAASxC,MAAOA,GAAW6C,MAEnD,IAIXX,EAAakB,YAAc,eAC3B,I,wFCjCA,EA1BmB,SAAAC,IAAAC,EAAAA,EAAAA,GAAAC,EAAAF,GAAA,IAAAG,GAAAC,EAAAA,EAAAA,GAAAF,GACjB,SAAAA,EAAYG,GAAe,IAADC,EAES,OAFTC,EAAAA,EAAAA,GAAA,KAAAL,IACxBI,EAAAH,EAAAK,KAAA,KAAMH,IACDI,MAAQ,CAAEC,UAAU,GAAQJ,CACnC,CAIC,OAJAK,EAAAA,EAAAA,GAAAT,EAAA,EAAAU,IAAA,oBAAAC,MAMD,SAAkBC,EAAcC,GAC9BC,QAAQF,MAAM,iCAAkCA,EAAOC,EACzD,GAAC,CAAAH,IAAA,SAAAC,MAED,WACE,IAAQH,EAAaO,KAAKR,MAAlBC,SACAhB,EAAauB,KAAKZ,MAAlBX,SAER,OAAIgB,GACKlD,EAAAA,EAAAA,KAAA,MAAAkC,SAAI,0BAGNA,CACT,IAAC,EAAAkB,IAAA,2BAAAC,MAjBD,SAAgCK,GAC9B,MAAO,CAAER,UAAU,EACrB,KAACR,CAAA,CARgB,CAASiB,EAAAA,W,0JCE5B,IACGC,EAAAA,eAAqBC,UAAkBC,kBAAoBA,EAAAA,GAC3DF,EAAAA,eAAqBC,UAAkBE,kBAAoBA,EAAAA,GAC3DH,EAAAA,KAAWC,UAAkBG,QAAUC,EAAAA,EAC1C,CAAE,MAAOX,IACPE,QAAQF,MAAM,mCAAoCA,GACpD,CAEA,IAAMY,EAAe,IAAIC,EAAAA,EACzBD,EAAaE,WAAY,GACzBC,EAAAA,EAAAA,GAAO,CAAEC,cAAAA,EAAAA,IAGT,IAAMC,GAAO,EAAIC,KAAKC,KAAK,IAAM,EAC3BC,EAAU,EAAIH,EAGdI,EAAyB,CAC7B,GAAK,EAAK,GAAK,IAAK,GAAK,IACzB,KAAM,IAAM,IAAM,IAAK,GAAK,MAoB9B,SAASC,EAAoBpD,GAI3B,GAAsB,kBAAXA,GAAuBA,GAAU,IAAMqD,OAAOC,SAAStD,GAChE,MAAM,IAAIuD,MAAM,kDAClB,IAAMC,EAAoB,IAAIC,IACxBC,EAAS,CACb,CAAC,EAAG,EAAG,GAAI,EAAE,EAAG,EAAG,GAAI,CAAC,GAAI,EAAG,GAAI,EAAE,GAAI,EAAG,GAC5C,CAAC,EAAG,GAAI,GAAI,EAAE,EAAG,GAAI,GAAI,CAAC,GAAI,GAAI,GAAI,EAAE,GAAI,GAAI,GAChD,CAAC,EAAGX,EAAKG,GAAU,CAAC,GAAIH,EAAKG,GAAU,CAAC,EAAGH,GAAMG,GAAU,CAAC,GAAIH,GAAMG,GACtE,CAACA,EAAS,EAAGH,GAAM,EAAEG,EAAS,EAAGH,GAAM,CAACG,EAAS,GAAIH,GAAM,EAAEG,EAAS,GAAIH,GAC1E,CAACA,EAAKG,EAAS,GAAI,EAAEH,EAAKG,EAAS,GAAI,CAACH,GAAMG,EAAS,GAAI,EAAEH,GAAMG,EAAS,IAExES,EAAqBX,KAAKC,KAAKF,EAAMA,EAAMG,EAAUA,GACrDU,EAAQ5D,EAAS2D,EACvBD,EAAOG,SAAQ,SAAAC,GACb,IAAMC,EAAID,EAAE,GAAKF,EAAOI,EAAIF,EAAE,GAAKF,EAAOK,EAAIH,EAAE,GAAKF,EAC/ChC,EAAG,GAAApC,OAAMuE,EAAEG,QAAQ,GAAE,KAAA1E,OAAIwE,EAAEE,QAAQ,GAAE,KAAA1E,OAAIyE,EAAEC,QAAQ,IACpDV,EAAkBW,IAAIvC,IACzB4B,EAAkBY,IAAIxC,EAAK,IAAIQ,EAAAA,QAAc2B,EAAGC,EAAGC,GAEvD,IACA,IAAMI,EAAWC,MAAMC,KAAKf,EAAkBgB,UACxCC,EAA+D,GAM/DC,EAA0B,KAAT1E,EAAgB2D,EAMvC,MAXiB,CACf,CAAC,EAAG,EAAGZ,GAAM,CAAC,GAAI,EAAGA,GAAM,CAAC,EAAG,GAAIA,GAAM,CAAC,GAAI,GAAIA,GAClD,CAAC,EAAGA,EAAK,GAAI,EAAE,EAAGA,EAAK,GAAI,CAAC,GAAIA,EAAK,GAAI,EAAE,GAAIA,EAAK,GACpD,CAACA,EAAK,EAAG,GAAI,EAAEA,EAAK,EAAG,GAAI,CAACA,EAAK,GAAI,GAAI,EAAEA,EAAK,GAAI,IAG7Cc,SAAQ,SAAAC,GACf,IAAMa,EAAS,IAAIvC,EAAAA,QAAc0B,EAAE,GAAIA,EAAE,GAAIA,EAAE,IAAIc,YAC7CC,EAASF,EAAOG,QAAQC,eAAeL,GAC7CD,EAASO,KAAK,CAAEH,OAAAA,EAAQF,OAAAA,GAC1B,IACO,CAAEN,SAAAA,EAAUI,SAAAA,EACrB,CAGA,IAAMQ,EAAqB,WACzB,IAAAC,GAAuBC,EAAAA,EAAAA,KAAfC,EAAMF,EAANE,OAAQC,EAAEH,EAAFG,GACVC,GAAcC,EAAAA,EAAAA,QAAsB,MAS1C,OARAC,EAAAA,EAAAA,YAAU,WACR,IAAMC,EAAW,IAAI3C,EAAAA,EAAcsC,EAAQC,EAAGK,YAI9C,OAHAD,EAASE,eAAgB,EACzBF,EAASG,OAAOxB,IAAI,EAAG,EAAG,GACzBkB,EAAsDO,QAAUJ,EAC1D,kBAAMA,EAASK,SAAU,CAClC,GAAG,CAACV,EAAQC,KACZU,EAAAA,EAAAA,IAAS,eAAAC,EAAA,OAAyB,QAAzBA,EAAMV,EAAYO,eAAO,IAAAG,OAAA,EAAnBA,EAAqBC,QAAQ,IACrC,IACT,EAcMC,EAAoBC,EAAAA,YACxB,SAAA1I,EAA+GsC,GAAS,IAArHqG,EAAW3I,EAAX2I,YAAaC,EAAS5I,EAAT4I,UAAWC,EAAgB7I,EAAhB6I,iBAAkBC,EAAS9I,EAAT8I,UAAWC,EAAY/I,EAAZ+I,aAAcC,EAAQhJ,EAARgJ,SAAQC,EAAAjJ,EAAEkJ,UAAAA,OAAS,IAAAD,GAAQA,EAAKrF,GAAKpD,EAAAA,EAAAA,GAAAR,EAAAS,GACzG0I,GAAoDC,EAAAA,EAAAA,UAAsC,MAAKC,GAAAC,EAAAA,EAAAA,GAAAH,EAAA,GAAxFI,EAAkBF,EAAA,GAAEG,EAAqBH,EAAA,IAChDtB,EAAAA,EAAAA,YAAU,WACR,KACyB,kBAAhBY,GAA4BA,GAAe,GAC7B,kBAAdC,GAA0BA,GAAa,GAClB,kBAArBC,GAAiCA,GAAoB,GACvC,kBAAdC,GAA0BA,GAAa,GACtB,kBAAjBC,GAA6BA,GAAgB,GALtD,CAUA,IAAIU,EAAwC,KACtCC,EAAsC,GAC5C,IACE,IAAAC,EAA2DhE,EAAoBgD,GAA7DiB,EAAYD,EAAtB/C,SAAkCiD,EAAYF,EAAtB3C,SAC1B8C,EAAgB,IAAInF,EAAAA,qBAA2BgE,EAAa,GAClEmB,EAAcjF,oBACd6E,EAAYnC,KAAKuC,GACjB,IAAMC,EAAgB,IAAIpF,EAAAA,qBAA2BgE,EAAcC,EAAW,GAC9EmB,EAAclF,oBACd6E,EAAYnC,KAAKwC,GACjB,IAAIC,EAAa,IAAIC,EAAAA,EAAMH,GACvBI,EAAa,IAAID,EAAAA,EAAMF,GAC3BG,EAAWC,oBACX,IAAIC,EAAanF,EAAaoF,SAASL,EAAYE,EAAYI,EAAAA,IACzDC,EAAgB1D,MAAMC,KAAK,CAAE0D,OAAQ,KAAM,SAAC/F,EAAGgG,GAAC,OAAK5B,EAAgBtD,KAAAmF,IAAG5B,EAAa2B,EAAG,IACxFE,EAA6B,IAAZ/B,EACjBgC,EAAc,IAAIjG,EAAAA,iBAAuB,EAAG,EAAGgG,EAAgB,IACrEC,EAAYC,QAAQtF,KAAKuF,GAAK,GAC9BF,EAAY/F,oBACZ6E,EAAYnC,KAAKqD,GACjB,IAAMG,EAAW,IAAIpG,EAAAA,WACrBkF,EAAazD,SAAQ,SAAC4E,EAAMC,GAC1B,IAAMC,EAAaX,EAAcU,GAAS,EAC1C,GAAKC,KAAcA,GAAc,GAAjC,CACA,IAAMC,EAAY,IAAIlB,EAAAA,EAAMW,GAC5BO,EAAUhF,MAAMQ,IAAIuE,EAAYA,EAAY,GAC5CH,EAASK,mBAAmB,IAAIzG,EAAAA,QAAc,EAAG,EAAG,GAAIqG,EAAK9D,QAC7DiE,EAAUE,WAAWC,KAAKP,GAC1BI,EAAUzJ,SAAS4J,KAAKN,EAAK5D,QAC7B+D,EAAUhB,oBACVC,EAAanF,EAAaoF,SAASD,EAAYe,EAAWb,EAAAA,GAPhB,CAQ5C,IACA,IAAMiB,EAAY,IAAI5G,EAAAA,eAAqBoE,EAAc,EAAG,GAC5DwC,EAAU1G,oBACV6E,EAAYnC,KAAKgE,GACjB3B,EAAaxD,SAAQ,SAAAoF,GACnB,IAAMC,EAAc,IAAIxB,EAAAA,EAAMsB,GAC9BE,EAAY/J,SAAS4J,KAAKE,GAC1BC,EAAYtB,oBACZC,EAAanF,EAAaoF,SAASD,EAAYqB,EAAaC,EAAAA,GAC9D,KACAjC,EAAWW,EAAWX,UACbkC,uBACTlC,EAASrC,QACX,CAAE,MAAO/C,IACPoF,EAAW,IACb,CAAC,QACCC,EAAYtD,SAAQ,SAAAwF,GAAC,OAAIA,EAAEvD,SAAS,GACtC,CAEA,OADAmB,EAAsBC,GACf,WACDA,GAAwC,oBAArBA,EAASpB,SAC9BoB,EAASpB,SAEb,CAvDA,CAFEmB,EAAsB,KA0D1B,GAAG,CAACb,EAAaC,EAAWC,EAAkBC,EAAWC,IAEzD,IAAM8C,GAAeC,EAAAA,EAAAA,UAAQ,WAC3B,IAAIC,EAeJ,OAbEA,EADE/C,aAAoBrE,EAAAA,SACPqE,EAAS3B,QAET,IAAI1C,EAAAA,kBAAwB,CACzCzE,MAAO,SACP8L,SAAU,QACVC,UAAW,GACXC,KAAM,wBAGG/I,KAAOwB,EAAAA,WAChB,cAAeoH,IAChBA,EAAqB7C,UAAYA,GAE7B6C,CACT,GAAG,CAAC/C,EAAUE,IAEd,OAAKK,GACExI,EAAAA,EAAAA,KAAA,QAAAE,EAAAA,EAAAA,GAAA,CAAMqB,IAAKA,EAAKmH,SAAUF,EAAoBP,SAAU6C,GAAkBjI,IADjD,IAElC,IAgBIuI,GAA0D,SAAHC,GAA4B,IAAtBC,EAAcD,EAAdC,eAC3DC,GAAWxE,EAAAA,EAAAA,QAAoB,MAC/ByE,GAAsBzE,EAAAA,EAAAA,QAAmB,MACzC0E,GAAe1E,EAAAA,EAAAA,QAAqB,MACpC2E,GAAiB3E,EAAAA,EAAAA,QAA6B,MAG9C4E,GAAoBC,EAAAA,EAAAA,IAAY,qBAAsB,CAC1DC,eAAgB,CAAExI,MAAO,EAAKyI,IAAK,EAAGC,IAAK,EAAGC,KAAM,IACpDC,eAAgB,CAAE5I,MAAO,EAAKyI,IAAK,EAAGC,IAAK,EAAGC,KAAM,IACpDE,OAAQ,CAAEC,MAAO,qBAAsB9I,MAAO,GAAKyI,IAAK,EAAGC,IAAK,EAAGC,KAAM,KACzEI,aAAc,CAAED,MAAO,gBAAiB9I,MAAO,EAAKyI,IAAK,GAAKC,IAAK,EAAGC,KAAM,IAC5ElM,QAAS,CAAEuD,MAAO,GAAKyI,IAAK,EAAGC,IAAK,EAAGC,KAAM,KAC7CK,WAAY,CAAEhJ,MAAO,GAAKyI,IAAK,EAAGC,IAAK,EAAGC,KAAM,IAChDM,kBAAmB,CAAEjJ,MAAO,IAAKyI,IAAK,EAAGC,IAAK,GAAIC,KAAM,IACxDO,wBAAyB,CAAElJ,MAAO,IAAKyI,IAAK,EAAGC,IAAK,EAAGC,KAAM,IAC7DQ,YAAa,CAAEnJ,OAAO,GACtBoJ,wBAAyB,CAAEpJ,MAAO,GAAKyI,IAAK,EAAGC,IAAK,EAAGC,KAAM,OAGzDU,GAAgBd,EAAAA,EAAAA,IAAY,iBAAkB,CAClDhE,YAAa,CAAEvE,MAAO,GACtBwE,UAAW,CAAExE,MAAO,KACpByE,iBAAkB,CAAEzE,MAAO,IAC3B0E,UAAW,CAAE1E,MAAO,KACpB2E,aAAc,CAAE3E,MAAO,MAGnBsJ,GAAcf,EAAAA,EAAAA,IAAY,gBAAiB,CAC/CgB,cAAe,CAAEvJ,MAAO,IAAMyI,IAAK,IAAKC,IAAK,IAAOC,KAAM,KAC1Da,aAAc,CAAExJ,MAAO,IAAMyI,IAAK,IAAMC,IAAK,IAAKC,KAAM,KACxDc,iBAAkB,CAAEzJ,MAAO,IAAKyI,IAAK,GAAKC,IAAK,EAAGC,KAAM,IACxDe,iBAAkB,CAAE1J,MAAO,GAAKyI,IAAK,GAAKC,IAAK,EAAGC,KAAM,KACxDgB,cAAe,CAAE3J,OAAO,GACxB8E,UAAW,CAAE9E,OAAO,KAUhB4J,IAPqBlC,EAAAA,EAAAA,UAAQ,iBAAO,CACxCnD,YAAa,EACbC,UAAW,IACXC,iBAAkB,GAClBC,UAAW,IACXC,aAAc,GACf,GAAG,KACqB+C,EAAAA,EAAAA,UAAQ,iBAAO,CACtCnD,YAAa8E,EAAc9E,YAC3BC,UAAW6E,EAAc7E,UACzBC,iBAAkB4E,EAAc5E,iBAChCC,UAAW2E,EAAc3E,UACzBC,aAAc0E,EAAc1E,aAC7B,GAAG,CAAC0E,KAECQ,GAAmBnC,EAAAA,EAAAA,UAAQ,WAC/B,OAAOY,EAAkBS,eACrB5H,KAAAmF,IAAAsD,EAAiBrF,YAAe,GAACpD,KAAAmF,IAAIsD,EAAiBrF,YAAcqF,EAAiBpF,UAAc,IAACrD,KAAAmF,IACrGsD,EAAiBrF,YAAe,GACrC,GAAG,CAAC+D,EAAkBS,aAAca,EAAiBrF,YAAaqF,EAAiBpF,YAG7EsF,GAAapG,EAAAA,EAAAA,QAAO,KAKpBqG,GAAuBrG,EAAAA,EAAAA,QAAO,GAC9BsG,GAAkBtG,EAAAA,EAAAA,SAAO,GAGzBuG,GAAevG,EAAAA,EAAAA,QAAqB,CACxCwG,gBAAiB,IAAI3J,EAAAA,QAAc,EAAG,EAAG,GACzC4J,WAAY,EACZC,cAAe,IAAI7J,EAAAA,QAAc,EAAG,EAAG,KAInC8J,GAAe3C,EAAAA,EAAAA,UAAQ,WAC3B,IAGE,IAFA,IAAM4C,EAAO,GACPC,EAAY,IAAIC,aAAyC,EAA5BlB,EAAYC,eACtClD,EAAI,EAAGA,EAAIiD,EAAYC,cAAelD,IAAK,CAClD,IAAMoE,EAAItJ,KAAKuJ,SAAWvJ,KAAKuF,GAAK,EAC9BzE,EAAId,KAAKuJ,SAAWvJ,KAAKuF,GAAK,EAC9BiE,EAAIrB,EAAYG,iBAChBmB,EAAItB,EAAYI,iBAChBmB,EAAQF,EAA4B,IAAvBxJ,KAAKuJ,SAAW,IAAaE,EAC1CE,EAAQF,EAAIzJ,KAAKC,KAAKD,KAAKuJ,UACjCH,EAAc,EAAJlE,IAAUwE,EAAQC,EAAQ3J,KAAK4J,IAAI9I,IAAMd,KAAK4J,IAAIN,GAC5DF,EAAc,EAAJlE,EAAQ,GAAKyE,EAAQ3J,KAAK6J,IAAI/I,GACxCsI,EAAc,EAAJlE,EAAQ,IAAMwE,EAAQC,EAAQ3J,KAAK4J,IAAI9I,IAAMd,KAAK6J,IAAIP,GAChEH,EAAKnH,KAAK,CAAEsH,EAAAA,EAAGxI,EAAAA,EAAG0I,EAAAA,EAAGC,EAAAA,EAAGK,QAAS,GACnC,CACA,MAAO,CAAEV,UAAAA,EAAWD,KAAAA,EACtB,CAAE,MAAOrK,IACP,MAAO,CAAEsK,UAAW,IAAIC,aAAa,GAAIF,KAAM,GACjD,CACF,GAAG,CAAChB,EAAYC,cAAeD,EAAYG,iBAAkBH,EAAYI,mBA0JzE,OAxJA/F,EAAAA,EAAAA,YAAU,WACR,GAAI0E,EAAerE,SAAuB,OAAZqG,QAAY,IAAZA,GAAAA,EAAcE,UAAW,CACrD,IAAMW,EAAoB7C,EAAerE,QAAQmH,aAAa,YACzDD,GAAqBA,EAAkBE,MAAMhF,SAAWiE,EAAaE,UAAUnE,QAClFiC,EAAerE,QAAQqH,aAAa,WAAY,IAAI9K,EAAAA,gBAAsB8J,EAAaE,UAAW,GAAG,IAEnGlC,EAAerE,QAAQmH,aAAa,UACtC9C,EAAerE,QAAQsH,gBAAgB,QAE3C,KAAO,CAAC,IAADC,EACqB,QAA1BA,EAAIlD,EAAerE,eAAO,IAAAuH,GAAtBA,EAAwBJ,aAAa,aACvC9C,EAAerE,QAAQsH,gBAAgB,WAE3C,CACF,GAAG,CAACjB,KAGJnG,EAAAA,EAAAA,IAAS,SAACtE,EAAO4L,GAAW,IAADC,EAAAC,EACnBC,EAAK1B,EAAajG,QAClBmF,EAAcb,EAAkBa,YAEhCyC,EADgBtD,EAAkBW,kBACAc,EAAqB/F,QAGzD2H,EAAGzB,gBAAgB9D,SAAWwF,IAChC5B,EAAgBhG,SAAU,GAGxBgG,EAAgBhG,SAElB8F,EAAW9F,QAAU7C,KAAKsH,IAAIqB,EAAW9F,QAlEvB,EAkEiDwH,EAAO,KAEtE1B,EAAW9F,SAAW,MACxBgG,EAAgBhG,SAAU,EAC1B+F,EAAqB/F,SAAW,GAChC2H,EAAGzB,gBAAgBhH,eAAe,OAIhCiG,GAAeW,EAAW9F,QAAU,EACtC8F,EAAW9F,QAAU7C,KAAKuH,IAAIoB,EAAW9F,QA7E5B,GA6EmDwH,EAAO,GAEvE1B,EAAW9F,QAAU7C,KAAKsH,IAAIqB,EAAW9F,QA9EzB,EA8EmDwH,EAAO,KAK1ErC,GAAeW,EAAW9F,QAAU,IACtC2H,EAAGxB,YAAc7B,EAAkBU,WAAawC,GAElD,IAAMK,EAAmB,IAAItL,EAAAA,QAAcY,KAAK4J,IAAIY,EAAGxB,YAAahJ,KAAK6J,IAAIW,EAAGxB,YAAa,GAAGpH,YAE1F9C,GADoBkJ,EAAc0C,EAAiB5I,QAAQC,eAAeoF,EAAkBE,gBAAkB,IAAIjI,EAAAA,QAAc,EAAG,EAAG,IAC5G0C,QAAQ6I,IAAIH,EAAGzB,iBACvCtH,EAAarB,EAAoBqI,EAAiBrF,aAAlD3B,SACFmJ,EArVV,SACEC,EACAH,EACAjJ,GAEA,IAAIqJ,EAAU,EAAGC,EAAY,EAO7B,OANAtJ,EAASZ,SAAQ,SAAC4E,EAAMC,GACtB,IAAMsF,EAAcvF,EAAK9D,OAAOG,QAAQmJ,gBAAgBJ,GAClDK,EAAYlL,KAAKuH,IAAI,EAAGyD,EAAYG,IAAIT,IAC9CI,GAAW3K,EAAuBuF,GAASwF,EAC3CH,GAAaG,CACf,IACOH,EAAY,EAAID,EAAUC,EAAY,CAC/C,CAwUgCK,CAAqBrE,EAASlE,QAAQiD,WAAY4E,EAAkBjJ,GAC1F4J,EAAavM,EAAMgD,QAAQC,eAAe6I,EAAsBzD,EAAkBO,OAASP,EAAkBM,gBAC7G6D,EAAed,EAAGzB,gBAAgB9D,SACpCsG,EAAiB,IAAInM,EAAAA,QAAc,EAAG,EAAG,GAC7C,GAAIkM,EAAeb,EAAiB,CAClC,IAAMe,EAAUF,EAAeb,EAC/Bc,EAAiBf,EAAGzB,gBAAgBjH,QAAQF,YAAYG,gBAAgBoF,EAAkBY,wBAA0ByD,EACtH,CACA,IAAIC,EAAYJ,EAAWK,IAAIH,GAE3BI,EAAe,IAAIvM,EAAAA,QAAc,EAAG,EAAG,GACnBgB,EAAoBqI,EAAiBrF,aAAa/B,SAC1DR,SAAQ,SAAA+K,GACtB,IACMC,EADWD,EAAU9J,QAAQmJ,gBAAgBlE,EAASlE,QAAQiD,YACtChE,QAAQgK,MAAMpB,GAAkB3I,eAAeoF,EAAkBc,yBAC/F0D,EAAaD,IAAIG,EACnB,IACAJ,EAAUC,IAAIC,GACdnB,EAAGvB,cAAclD,KAAK0F,GACtB,IAAMM,EAAeN,EAAU3J,QAAQkK,aAAatD,GACpD8B,EAAGzB,gBAAgB2C,IAAIK,EAAahK,eAAesI,IACnDG,EAAGzB,gBAAgBhH,eAAe,EAAIoF,EAAkB7L,QAAU+O,GAClE,IAAM4B,EAAazB,EAAGzB,gBAAgB9D,SAAWoF,EACjD,GAAI4B,EAAa,EAAG,CAClB,IAAMC,EAAe1B,EAAGzB,gBAAgBjH,QAAQF,YAC1CuK,GAAY,IAAI/M,EAAAA,YAAmBgN,iBAAiBF,EAAcD,GACxElF,EAASlE,QAAQiD,WAAWuG,SAASF,EACvC,CAEA,GAAInF,EAAoBnE,QAAS,CAC/B,IAAMyJ,EAAkBtF,EAAoBnE,QAAQY,SACpD,IAAI6I,aAA2BlN,EAAAA,sBAA8BkN,aAA2BlN,EAAAA,uBAClFkN,EAAgBC,SAAU,CAC5B,IAAMC,EAAerF,EAAkBO,OAASP,EAAkBM,gBAAqD,IAAnCN,EAAkBE,eAAuB,GACvHoF,EAAmBzM,KAAKsH,IAAImE,EAAUxG,UAAYuH,EAAe,KAAO,GAC9EF,EAAgBC,SAASG,OAAO,GAAK,EAAwB,GAAnBD,EAC5C,CAEJ,CAIA,IAAMrD,EAAkC,QAAzBkB,EAAGpD,EAAerE,eAAO,IAAAyH,GAAqB,QAArBC,EAAtBD,EAAwBqC,WAAWxQ,gBAAQ,IAAAoO,OAArB,EAAtBA,EAA6CN,MACzD2C,EAAQ1D,EAAaC,KAG3B,GADwB0D,MAAMrC,EAAGzB,gBAAgB9D,UAC5B,CAEnB,IAAK,IAAIC,EAAI,EAAGA,EAAI0H,EAAM3H,OAAQC,SAEP4H,IAArBF,EAAM1H,GAAG4E,UAAuB8C,EAAM1H,GAAG4E,QAAU,GAEvD8C,EAAM1H,GAAG4E,SAAW,GAAMO,OAEUyC,IAA/BF,EAAM1H,GAAW6H,YACnBH,EAAM1H,GAAW6H,UAAoC,IAAvB/M,KAAKuJ,SAAW,IAC9CqD,EAAM1H,GAAW8H,UAAoC,IAAvBhN,KAAKuJ,SAAW,KAEjDH,EAAc,EAAJlE,GAAU0H,EAAM1H,GAAW6H,UACrC3D,EAAc,EAAJlE,EAAQ,GAAK0H,EAAM1H,GAAG4E,QAChCV,EAAc,EAAJlE,EAAQ,GAAM0H,EAAM1H,GAAW8H,UAErCJ,EAAM1H,GAAG4E,QAAU,IACrB8C,EAAM1H,GAAG4E,QAAU,EAClB8C,EAAM1H,GAAW6H,UAAoC,IAAvB/M,KAAKuJ,SAAW,IAC9CqD,EAAM1H,GAAW8H,UAAoC,IAAvBhN,KAAKuJ,SAAW,KAGnDrC,EAAerE,QAAQ8J,WAAWxQ,SAAS8Q,aAAc,CAC3D,KAAO,CAEL,IAAMC,EAAQ/F,EAAkBE,eAAiBF,EAAkBM,eACnE,GAAImF,GAAwB,EAAfA,EAAM3H,SAAemE,EAAUnE,OAAQ,CAClD,IAAMkI,EAAYlG,EAAapE,QAAQY,SACnC0J,IAAWA,EAAUtS,KAAOsN,EAAYE,cAAgB,EAAuC,GAAnClB,EAAkBM,iBAClF,IAAK,IAAIvC,EAAI,EAAGA,EAAI0H,EAAM3H,OAAQC,IAAK,CACrC,IAAMiE,EAAOyD,EAAM1H,GACnBiE,EAAKG,GAAK4D,EAAQ7C,EAClB,IAAMb,EAAIrB,EAAYG,iBAChBmB,EAAItB,EAAYI,iBAChBe,EAAIH,EAAKG,EACTxI,EAAIqI,EAAKrI,EACTsM,EAAkB,EAAJlI,EACpBkE,EAAUgE,IAAgB5D,EAAIC,EAAIzJ,KAAK4J,IAAI9I,IAAMd,KAAK4J,IAAIN,GAC1DF,EAAUgE,EAAc,GAAK3D,EAAIzJ,KAAK6J,IAAI/I,GAC1CsI,EAAUgE,EAAc,IAAM5D,EAAIC,EAAIzJ,KAAK4J,IAAI9I,IAAMd,KAAK6J,IAAIP,EAChE,CACApC,EAAerE,QAAQ8J,WAAWxQ,SAAS8Q,aAAc,CAC3D,CACF,CAGAnG,EAAe,CACbuG,QAAS1E,EAAW9F,QACpBkG,gBAAiByB,EAAGzB,gBAAgB9D,UAExC,KAGExH,EAAAA,EAAAA,MAAA,SAAOV,IAAKgK,EAASrJ,SAAA,EACnBlC,EAAAA,EAAAA,KAAC0H,EAAiB,CAChBnG,IAAKiK,EACL5D,YAAaqF,EAAiBrF,YAC9BC,UAAWoF,EAAiBpF,UAC5BC,iBAAkBmF,EAAiBnF,iBACnCC,UAAWkF,EAAiBlF,UAC5BC,aAAciF,EAAiBjF,aAC/BG,UAAWwE,EAAYxE,UACvB2J,YAAU,EACVC,eAAa,EACbpR,SAAU,CAAC,EAAG,EAAG,GACjBqR,SAAU,CAAC,EAAG,EAAG,KAElBrF,EAAYK,gBACX/K,EAAAA,EAAAA,MAAA,UAAQV,IAAKkK,EAAcN,KAAK,iBAAgBjJ,SAAA,EAC9ClC,EAAAA,EAAAA,KAAA,kBAAgBuB,IAAKmK,KACrB1L,EAAAA,EAAAA,KAAA,kBACEmL,KAAK,mBACLhM,MAAO,MACPE,KAAMsN,EAAYE,aAClBoF,aAAW,EACXC,QAAS,GACTC,SAAUvO,EAAAA,iBACVwO,iBAAiB,EACjB9P,IAAK,YAMjB,EAoEM+P,GAID,SAAHC,GAAiE,IAA3DC,EAAMD,EAANC,OAAQC,EAAmBF,EAAnBE,oBAAqBC,EAAsBH,EAAtBG,uBAC7BC,EAAiBH,EAAOV,QACxBc,EAAiBnO,KAAKsH,IAAKyG,EAAOhF,gBAAkB,GAAM,IAAK,KAS/DqF,EAAoC,CACxCC,MAAO,QACPpS,OAAQ,OACRK,WAAY,OACZgS,aAAc,OACdC,SAAU,SACVC,aAAc,QAQhB,OACE/Q,EAAAA,EAAAA,MAAA,OAAKb,MAvBmC,CACxCT,SAAU,WACVL,IAAK,GACLC,KAAM,GACNpB,MAAO,OACP8T,WAAY,aACZvS,OAAQ,IAiBiBwB,SAAA,EACvBD,EAAAA,EAAAA,MAAA,OAAAC,SAAA,EACED,EAAAA,EAAAA,MAAA,OAAAC,SAAA,CAAK,YAAUwQ,EAAehN,QAAQ,GAAG,QACzC1F,EAAAA,EAAAA,KAAA,OAAKoB,MAAOwR,EAAa1Q,UACvBlC,EAAAA,EAAAA,KAAA,OAAKoB,MAAO,CAAEyR,MAAM,GAAD7R,OAAK0R,EAAc,KAAKjS,OAAQ,OAAQK,WAAY,qBAG3EmB,EAAAA,EAAAA,MAAA,OAAAC,SAAA,EACED,EAAAA,EAAAA,MAAA,OAAAC,SAAA,CAAK,qBAAmBqQ,EAAOhF,gBAAgB7H,QAAQ,OACvD1F,EAAAA,EAAAA,KAAA,OAAKoB,MAAOwR,EAAa1Q,UACvBlC,EAAAA,EAAAA,KAAA,OAAKoB,MAAO,CAAEyR,MAAM,GAAD7R,OAAK2R,EAAc,KAAKlS,OAAQ,OAAQK,WAAY,kBAG3Ed,EAAAA,EAAAA,KAAA,OAAAkC,UACElC,EAAAA,EAAAA,KAAA,UAAQoB,MArB2B,CACvC8R,QAAS,WACTC,SAAU,OACVL,aAAc,MACdM,OAAQ,WAiBwBC,QAAS,kBAAMZ,GAAwBD,EAAoB,EAACtQ,SACrFsQ,EAAsB,0BAA4B,+BAK7D,EAGMc,GAA+B,WACnC,OACErR,EAAAA,EAAAA,MAAA,QAAAC,SAAA,EACElC,EAAAA,EAAAA,KAAA,eAAa4B,KAAM,CAAC,GAAK,GAAK,OAC9B5B,EAAAA,EAAAA,KAAA,qBAAmBb,MAAM,SAASgJ,WAAS,EAAChG,OAAO,eAGzD,EAEA,GAhIyC,WACvC,IAAAoR,GAA4BlL,EAAAA,EAAAA,UAAS,CAAEwJ,QAAS,IAAKtE,gBAAiB,IAAIiG,GAAAjL,EAAAA,EAAAA,GAAAgL,EAAA,GAAnEhB,EAAMiB,EAAA,GAAEC,EAASD,EAAA,GAExBE,GAAsDrL,EAAAA,EAAAA,WAAS,GAAMsL,GAAApL,EAAAA,EAAAA,GAAAmL,EAAA,GAA9DlB,EAAmBmB,EAAA,GAAElB,EAAsBkB,EAAA,GAElD,OACE1R,EAAAA,EAAAA,MAAA2R,EAAAA,SAAA,CAAA1R,SAAA,EACElC,EAAAA,EAAAA,KAAC6T,EAAAA,GAAI,CAACC,WAAW,EAAOC,SAAU,CAAEC,MAAO,eAC3C/R,EAAAA,EAAAA,MAACgS,EAAAA,GAAM,CACL7S,MAAO,CACLT,SAAU,WACVL,IAAK,EACLC,KAAM,EACNsS,MAAO,QACPpS,OAAQ,QACRK,WAAY,UACZJ,OAAQ,GAEVkG,OAAQ,CAAEjG,SAAU,CAAC,EAAG,EAAG,GAAIuT,IAAK,IACpCrN,GAAI,CAAEsN,WAAW,GACjBC,SAAO,EAAAlS,SAAA,EAGPlC,EAAAA,EAAAA,KAAA,gBAAcqU,UAAW,KACzBrU,EAAAA,EAAAA,KAAA,mBAAiBsU,YAAa,QAAUD,UAAW,MACnDrU,EAAAA,EAAAA,KAAA,oBACEW,SAAU,CAAC,EAAG,GAAI,KAClB0T,UAAW,GACXvC,YAAU,EACV,uBAAsB,KACtB,wBAAuB,KACvB,oBAAmB,GACnB,sBAAqB,GACrB,sBAAqB,GACrB,oBAAmB,GACnB,wBAAuB,KAGxBU,IACCxS,EAAAA,EAAAA,KAAA,cACEqU,UAAW,GACXlV,MAAO,SACPoV,SAAU,EACVC,MAAO,IACP7T,SAAU,CAAC,EAAG,EAAG,GACjBwK,KAAK,mBAGTnL,EAAAA,EAAAA,KAAC0C,EAAa,CAAAR,UACZlC,EAAAA,EAAAA,KAACyU,EAAAA,SAAQ,CAACC,UAAU1U,EAAAA,EAAAA,KAACsT,GAAkB,IAAIpR,UACzClC,EAAAA,EAAAA,KAACoL,GAAmB,CAACE,eAAgBmI,SAGzCzT,EAAAA,EAAAA,KAACyG,EAAQ,QAEXzG,EAAAA,EAAAA,KAACqS,GAAa,CACZE,OAAQA,EACRC,oBAAqBA,EACrBC,uBAAwBA,MAIhC,EC5hBMkC,IAAaC,EAAAA,EAAAA,IAAO,MAAPA,EAAc,SAAA3V,GAAA,IAAG8B,EAAK9B,EAAL8B,MAAK,OAAAb,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,IACpC2U,EAAAA,EAAAA,IAAW,CACZ1V,OAAO2V,EAAAA,EAAAA,IAAM/T,EAAME,QAAQH,WAAWiU,QAAgC,UAAvBhU,EAAME,QAAQ+T,KAAmB,GAAM,KACtFC,OAAQ,sCACR,IAAAC,EAAAA,EAAAA,GAAA,CACFrC,MAAO,OACPpS,OAAQ,QACRE,SAAU,YACTI,EAAMoU,YAAYC,GAAG,MAAQ,CAC5B9U,IAAK,EACLC,KAAM,EACNI,SAAU,UACX,IAGG0U,IAAgBT,EAAAA,EAAAA,IAAO,MAAPA,EAAc,SAAAvJ,GAAA,IAAGtK,EAAKsK,EAALtK,MAAK,OAAAmU,EAAAA,EAAAA,GAAA,CAC1CzU,OAAQ,OACRoS,MAAO,OAEPlS,SAAU,YACTI,EAAMoU,YAAYC,GAAG,MAAQ,CAC5BE,UAAWC,EAAAA,EAAOC,kBACnB,IAGGC,IAAqBb,EAAAA,EAAAA,IAAOxU,EAAAA,EAAEsV,GAATd,EAAa,SAAAe,GAAA,IAAG5U,EAAK4U,EAAL5U,MAAK,OAAAb,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,IAC3C0V,EAAAA,EAAAA,IAAa,WAAD5U,OACFD,EAAME,QAAQ4U,QAAQ1U,KAAI,SAAAH,OAAQD,EAAME,QAAQ6U,QAAQ3U,KAAI,UAAAH,OAASD,EAAME,QAAQ4U,QAAQ1U,KAAI,UAAAH,OAASD,EAAME,QAAQ6U,QAAQ3U,KAAI,UAAAH,OAASD,EAAME,QAAQ4U,QAAQ1U,KAAI,WACjL,IAAA+T,EAAAA,EAAAA,GAAA,CACDhC,QAAS,EACToC,UAAW,EACXS,WAAY,EACZ/C,aAAc,GACdgD,cAAe,EACfC,UAAW,SACXC,eAAgB,OAChB/C,SAAS,GAADnS,OAAK,EAAO,OACpBiS,WAAY,wBACXlS,EAAMoU,YAAYC,GAAG,MAAQ,CAC5BjC,SAAS,GAADnS,OAAK,EAAO,SACrB,KAGsB4T,EAAAA,EAAAA,IAAO,MAAPA,EAAc,SAAAuB,GAAA,IAAGpV,EAAKoV,EAALpV,MAAK,MAAQ,CACrDT,KAAM,GACNuS,MAAO,IACPrS,OAAQ,GACRC,OAAQ,IACRqS,aAAc,MACdnS,SAAU,WACVyV,OAAQ,cACRC,aAAc,cACdC,iBAAiBxB,EAAAA,EAAAA,IAAM/T,EAAME,QAAQ4U,QAAQU,OAAQ,KACtD,KAE2B3B,EAAAA,EAAAA,IAAO,MAAPA,EAAc,SAAA4B,GAAA,IAAGzV,EAAKyV,EAALzV,MAAK,MAAQ,CACxDN,OAAQ,IACRgW,QAAS,IACTlW,KAAM,MACNC,MAAO,MACPsS,aAAc,MACdnS,SAAU,WACVyV,OAAQ,cACRC,aAAc,cACdC,iBAAiBxB,EAAAA,EAAAA,IAAM/T,EAAME,QAAQ4U,QAAQU,OAAQ,KACtD,KAOqB3B,EAAAA,EAAAA,IAAO,MAAPA,EACpB,SAAA8B,GAAA,IAAAC,EAAAD,EAAGxE,QAAAA,OAAO,IAAAyE,EAAG,EAACA,EAAAC,EAAAF,EAAEG,OAAAA,OAAM,IAAAD,EAAG,OAAMA,EAAE7V,EAAK2V,EAAL3V,MAAK,OAAAb,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,IACjC4W,EAAAA,EAAAA,IAAO,CACR5E,QAAAA,EACA/S,MAAO4B,EAAME,QAAQH,WAAWiU,WAChC,IACFrU,OAAQ,EACR+V,OAAQ,EACRhW,OAAQ,GACRoS,MAAO,MACPlS,SAAU,WACVoW,SAAU,sCACK,SAAXF,IAAiB3W,EAAAA,EAAAA,GAAA,CACnBK,KAAM,GACkB,QAApBQ,EAAMiW,WAAuB,CAC/BC,UAAW,kBAGA,UAAXJ,IAAkB3W,EAAAA,EAAAA,GAAA,CACpBM,MAAO,EACPyW,UAAW,cACa,QAApBlW,EAAMiW,WAAuB,CAC/BC,UAAW,cAEd,IAMU,SAASC,KACtB,IAAMC,GAAOC,EAAAA,EAAAA,GAAc,KAAM,MAE3BrW,GAAQsW,EAAAA,EAAAA,KAERC,GAAUvQ,EAAAA,EAAAA,QAA8B,MAEtCwQ,GAAYC,EAAAA,EAAAA,KAAZD,QAERnP,GAA8BC,EAAAA,EAAAA,UAAS,IAAIC,GAAAC,EAAAA,EAAAA,GAAAH,EAAA,GAApCqP,EAAOnP,EAAA,GAAEoP,EAAUpP,EAAA,GAEpBqP,EAAiC,UAAvB5W,EAAME,QAAQ+T,KAExB4C,GAAYC,EAAAA,EAAAA,cAAY,WAC5B,IAAIC,EAAa,EAEbR,EAAQjQ,UACVyQ,EAAaR,EAAQjQ,QAAQ0Q,cAG/BR,EAAQS,GAAG,UAAU,SAACC,GACpB,IAAMC,EAAgC,IAAfD,EAAsBH,EAE7CJ,EAAWlT,KAAK2T,MAAMD,GAAe,GACvC,GACF,GAAG,CAACX,KAEJvQ,EAAAA,EAAAA,YAAU,WACR4Q,GACF,GAAG,CAACA,IAEJ,IAAMQ,EAAyB,CAC7BC,WAAY,OACZC,KAAM,SACNC,SAAU,IACVC,OAAQC,KAGJvG,EAAU,EAAIuF,EAAU,IAExBiB,EAAOjB,EAAU,IAEjBkB,GACJ1W,EAAAA,EAAAA,MAAC2W,EAAAA,EAAK,CACJC,WAAW,SACXC,eAAe,SACfvZ,GAAI,CACFkB,OAAQ,EACRsY,GAAI,OACJC,SAAU,IACV9G,QAASA,EAAU,EAAIA,EAAU,EACjC+G,GAAI,CACFC,GAAG,IAADlY,OAAMuU,EAAAA,EAAO4D,UAAsB,IAAV1B,EAAa,QAE1CvV,SAAA,EAEFlC,EAAAA,EAAAA,KAACI,EAAAA,EAAEC,IAAG,CAAC+Y,UAAUC,EAAAA,EAAAA,MAAUC,GAAGpX,UAC7BlC,EAAAA,EAAAA,KAACuZ,EAAAA,EAAU,CAACC,QAAQ,KAAKja,GAAI,CAAE0W,UAAW,UAAW/T,SAAC,gDAKvDlC,EAAAA,EAAAA,KAACI,EAAAA,EAAEC,IAAG,CAAC+Y,UAAUC,EAAAA,EAAAA,MAAUC,GAAGpX,UAC5BlC,EAAAA,EAAAA,KAACyV,GAAkB,CACjBgE,QAAS,CAAEC,mBAAoB,eAC/BtB,WAAY,CACVC,WAAY,UACZC,KAAM,SACNC,SAAU,GACVC,OAAQC,KACRvW,SACH,kCAKHlC,EAAAA,EAAAA,KAACI,EAAAA,EAAEC,IAAG,CAAC+Y,UAAUC,EAAAA,EAAAA,MAAUC,GAAGpX,UAC5BlC,EAAAA,EAAAA,KAAC2Z,EAAAA,EAAI,CAAAzX,UACHlC,EAAAA,EAAAA,KAAC4Z,EAAAA,GAAQ,CAAA1X,UACPlC,EAAAA,EAAAA,KAAC6Z,EAAAA,EAAY,CACbta,GAAI,CAAEua,WAAY,OAAQ7D,UAAW,UACnCJ,QAAQ,yCACRkE,UAAU,kGAsClB/Z,EAAAA,EAAAA,KAACI,EAAAA,EAAEC,IAAG,CAAC+Y,UAAUC,EAAAA,EAAAA,MAAUC,GAAGpX,UAC5BlC,EAAAA,EAAAA,KAAC4Y,EAAAA,EAAK,CAACoB,QAAS,IAAKhD,UAAW,CAAEiD,GAAI,iBAAkBC,GAAI,OAAS3a,GAAI,CAAE4a,GAAI,IAAKjY,UAClFD,EAAAA,EAAAA,MAAC2W,EAAAA,EAAK,CAACC,WAAW,SAASmB,QAAS,EAAE9X,SAAA,EACpClC,EAAAA,EAAAA,KAACoa,EAAAA,EAAM,CACLja,UAAWka,EAAAA,EACXC,KAAK,uCACLlT,OAAO,SACPjI,MAAM,UACNE,KAAK,QACLma,QAAQ,YACRe,WAAWva,EAAAA,EAAAA,KAACwa,EAAAA,EAAO,CAACC,KAAK,iBAAiB5H,MAAO,KAAO3Q,SACzD,0BAEQlC,EAAAA,EAAAA,KAAA,UAAKA,EAAAA,EAAAA,KAAA,UAAKA,EAAAA,EAAAA,KAAA,mBAQvB0a,GACJ1a,EAAAA,EAAAA,KAAC4Y,EAAAA,EAAK,CACJ5B,UAAU,MACV6B,WAAW,aACXtZ,GAAI,CACFkB,OAAQ,OACRoS,MAAO,OACPlS,SAAU,WACVJ,KAAM,EACN2R,QAASA,EAAU,EAAIA,EAAU,GAC/BhQ,UAEJlC,EAAAA,EAAAA,KAAC2a,GAAsB,MAKxB/B,EAAAA,GAGG1Y,EAAAA,EAAAA,GAAA,CACAO,OAAQ,OACRE,SAAU,WACVuR,QAASA,EAAU,EAAIA,EAAU,EACjC+E,UAAU,QAADjW,QAAW,GAAKyW,EAAU,GAAE,SAAAzW,OAAQ,EAAIyW,EAAU,GAAE,SACrC,QAApB1W,EAAMiW,WAAuB,CAC/BC,UAAU,QAADjW,OAAU,GAAKyW,EAAU,GAAE,SAAAzW,OAAQ,EAAIyW,EAAU,GAAE,UAI/DmB,EAAAA,EACYxY,EAAAA,EAAEC,KACHgZ,EAAAA,EAAAA,MAAUC,GAMnBrZ,EAAAA,EACYG,EAAAA,EAAEwa,IAWd3a,EAAAA,EACYG,EAAAA,EAAEwa,IAahBhC,EAAAA,EACYxY,EAAAA,EAAEC,KACHgZ,EAAAA,EAAAA,MAAUC,GAGnBrZ,EAAAA,EACYG,EAAAA,EAAEwa,IAWd3a,EAAAA,EACYG,EAAAA,EAAEwa,IAgBnBhH,EAAAA,SASAA,EAAAA,SAMF,OACE5T,EAAAA,EAAAA,KAAA4T,EAAAA,SAAA,CAAA1R,UACElC,EAAAA,EAAAA,KAAC2U,GAAU,CACTpT,IAAK+V,EACL/X,IAAEW,EAAAA,EAAAA,GAAA,GAEIwY,GAAQ,CACVxG,QAAS,IAEXhQ,UAGFlC,EAAAA,EAAAA,KAACqV,GAAa,CAAAnT,UACZlC,EAAAA,EAAAA,KAAC6a,EAAAA,EAAS,CAAC1a,UAAW2a,EAAAA,GAAiBvb,GAAI,CAAEkB,OAAQ,GAAMW,MAAO,CAACyR,MAAM,QAAQ3Q,UAC/ED,EAAAA,EAAAA,MAAC8Y,EAAAA,EAAI,CAACC,WAAS,EAACC,cAAe,CAAE/B,GAAI,IAAM3Z,GAAI,CAAEkB,OAAQ,GAAIyB,SAAA,CACzDiV,IAAQnX,EAAAA,EAAAA,KAAC+a,EAAAA,EAAI,CAAC7B,GAAI,GAAGhX,SAAEwY,KACzB1a,EAAAA,EAAAA,KAAC+a,EAAAA,EAAI,CAACd,GAAI,GAAIf,GAAI,EAAEhX,SACjByW,cAgBjB,EC3YsB/D,EAAAA,EAAAA,IAAO,MAAPA,EAAkC,SAAA3V,GAAA,IAAAic,EAAAjc,EAAG4X,OAAAA,OAAM,IAAAqE,EAAG,MAAKA,EAAEna,EAAK9B,EAAL8B,MAAK,OAAAb,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,CAC9EK,KAAM,EACNG,OAAQ,EACRD,OAAQ,GACRoS,MAAO,OACPlS,SAAU,WACVoW,SAAU,qCACVT,gBAAiBvV,EAAME,QAAQH,WAAWiU,QAC1CoG,QAAS,QACTpF,WAAY,GACG,QAAXc,GAAoB,CACtBvW,KAAM,EACN2W,UAAW,kBAEE,WAAXJ,GAAuB,CACzBJ,QAAS,EACTH,gBAAiBvV,EAAME,QAAQma,KAAK,MACrC,IAKY,SAASC,KACtB,IAAQ/b,GAAoBkY,EAAAA,EAAAA,KAApBlY,gBAER,OACE2C,EAAAA,EAAAA,MAAA2R,EAAAA,SAAA,CAAA1R,SAAA,EACElC,EAAAA,EAAAA,KAAChB,EAAAA,EAAc,CAACM,gBAAiBA,KAEjCU,EAAAA,EAAAA,KAACkX,GAAQ,KAETlX,EAAAA,EAAAA,KAACC,EAAAA,EAAG,CACFV,GAAI,CACFwT,SAAU,SACVpS,SAAU,WACVE,QAAS,0BA2BnB,CChFe,SAASya,KACtB,OACErZ,EAAAA,EAAAA,MAAA2R,EAAAA,SAAA,CAAA1R,SAAA,EACElC,EAAAA,EAAAA,KAACub,EAAAA,GAAM,CAAArZ,UACLlC,EAAAA,EAAAA,KAAA,SAAAkC,SAAO,0DAGTlC,EAAAA,EAAAA,KAACqb,GAAQ,MAGf,C","sources":["components/scroll-progress/scroll-progress.tsx","components/three/customSphere.tsx","components/three/errorBoundary.tsx","components/three/mainView.tsx","sections/home/home-hero.tsx","sections/home/view/home-view.tsx","pages/home.tsx"],"sourcesContent":["import { m, useSpring, MotionValue } from 'framer-motion';\n// @mui\nimport Box, { BoxProps } from '@mui/material/Box';\n\n// ----------------------------------------------------------------------\n\nexport interface ScrollProgressProps extends BoxProps {\n  color?: 'inherit' | 'primary' | 'secondary' | 'info' | 'success' | 'warning' | 'error';\n  size?: number;\n  scrollYProgress: MotionValue<number>;\n}\n\nexport default function ScrollProgress({\n  color = 'primary',\n  size = 3,\n  scrollYProgress,\n  sx,\n  ...other\n}: ScrollProgressProps) {\n  const scaleX = useSpring(scrollYProgress, {\n    stiffness: 100,\n    damping: 30,\n    restDelta: 0.001,\n  });\n\n  return (\n    <Box\n      component={m.div}\n      sx={{\n        top: 0,\n        left: 0,\n        right: 0,\n        height: size,\n        zIndex: 1999,\n        position: 'fixed',\n        transformOrigin: '0%',\n        bgcolor: 'text.primary',\n        ...(color !== 'inherit' && {\n          background: (theme) =>\n            `linear-gradient(135deg, ${theme.palette[color].light} 0%, ${theme.palette[color].main} 100%)`,\n        }),\n        ...sx,\n      }}\n      style={{ scaleX }}\n      {...other}\n    />\n  );\n}\n","import React, { forwardRef } from 'react';\nimport { Mesh, Texture, BackSide } from 'three';\nimport { MeshStandardMaterialProps, MeshBasicMaterialProps } from '@react-three/fiber';\n\n\n// interface CustomSphereProps {\n//   radius: number;\n//   widthSegments: number;\n//   heightSegments: number;\n//   position?: [number, number, number];\n//   color?: string;\n//   texture?: Texture;\n//   materialType?: 'basic' | 'standard';\n//   materialProps?: JSX.IntrinsicElements['meshBasicMaterial'] | JSX.IntrinsicElements['meshStandardMaterial'];\n// }\n\n\ninterface CustomSphereProps {\n\n    position: [number, number, number];\n  \n    radius: number;\n  \n    widthSegments: number;\n  \n    heightSegments: number;\n  \n    material?: any;\n  \n    castShadow?: boolean;\n  \n    receiveShadow?: boolean;\n    args?: any;\n    normalMap?: Texture;\n    \n      color?: string;\n  texture?: Texture;\n  materialType?: 'basic' | 'standard';\n  materialProps?: JSX.IntrinsicElements['meshBasicMaterial'] | JSX.IntrinsicElements['meshStandardMaterial'];\n  \n  }\n\nconst CustomSphere = forwardRef<Mesh, CustomSphereProps>(\n  (\n    {\n      radius,\n      widthSegments,\n      heightSegments,\n      position,\n      color,\n      args,\n      texture,\n      materialType = 'standard',\n      materialProps = {},\n    },\n    ref\n  ) => (\n    <mesh ref={ref} position={position}>\n      <sphereGeometry args={[radius, widthSegments, heightSegments]} />\n      {materialType === 'basic' ? (\n        <meshBasicMaterial attach=\"material\" side={BackSide} map={texture} color={color} {...materialProps as MeshBasicMaterialProps} />\n      ) : (\n        <meshStandardMaterial map={texture} color={color} {...materialProps as MeshStandardMaterialProps} />\n      )}\n    </mesh>\n  )\n);\n\nCustomSphere.displayName = 'CustomSphere';\nexport default CustomSphere;\n\n// import React from 'react';\n// import { MeshProps, useLoader } from '@react-three/fiber';\n// import { TextureLoader, Mesh } from 'three';\n\n// interface CustomSphereProps extends MeshProps {\n//   radius: number;\n//   widthSegments: number;\n//   heightSegments: number;\n//   textureUrl?: string;\n//   color?: string;\n//   materialType?: 'basic' | 'standard';\n//   materialProps?: JSX.IntrinsicElements['meshBasicMaterial'] | JSX.IntrinsicElements['meshStandardMaterial'];\n// }\n\n// const CustomSphere = React.forwardRef<Mesh, CustomSphereProps>(\n//   (\n//     {\n//       radius,\n//       widthSegments,\n//       heightSegments,\n//       textureUrl,\n//       color,\n//       materialType = 'standard',\n//       materialProps = {}, \n//       ...props\n//     },\n//     ref\n//   ) => {\n//     const texture = useLoader(TextureLoader, textureUrl || '');\n//     // const texture = textureUrl ? useLoader(TextureLoader, textureUrl) : undefined;\n\n//     return (\n//       <mesh {...props} ref={ref}>\n//         <sphereGeometry attach=\"geometry\" args={[radius, widthSegments, heightSegments]} />\n//         {materialType === 'basic' ? (\n//           <meshBasicMaterial\n//             attach=\"material\"\n//             map={texture}\n//             color={color}\n//             {...(materialProps as JSX.IntrinsicElements['meshBasicMaterial'])}\n//           />\n//         ) : (\n//           <meshStandardMaterial\n//             map={texture}\n//             color={color}\n//             {...(materialProps as JSX.IntrinsicElements['meshStandardMaterial'])}\n//           />\n//         )}\n//       </mesh>\n//     );\n//   }\n// );\n  \n// CustomSphere.displayName = 'CustomSphere';\n// export default CustomSphere;","import React, { Component, ErrorInfo, ReactNode } from 'react';\n\ninterface Props {\n  children: ReactNode;\n}\n\ninterface State {\n  hasError: boolean;\n}\n\nclass ErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(_: Error): State {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('Error caught by ErrorBoundary:', error, errorInfo);\n  }\n\n  render() {\n    const { hasError } = this.state;\n    const { children } = this.props;\n\n    if (hasError) {\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return children;\n  }\n}\n\nexport default ErrorBoundary;","// === Full Code: TemporalResonatorScene_ToggleChargeThreshold_EasterEgg.tsx ===\n\nimport React, { useRef, useEffect, useMemo, Suspense, useState } from 'react';\nimport { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport * as THREE from 'three';\nimport ErrorBoundary from './errorBoundary'; // Adjust path if needed\nimport { useControls, Leva } from 'leva';\nimport { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\nimport { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n\n// --- BVH / CSG Setup ---\ntry {\n  (THREE.BufferGeometry.prototype as any).computeBoundsTree = computeBoundsTree;\n  (THREE.BufferGeometry.prototype as any).disposeBoundsTree = disposeBoundsTree;\n  (THREE.Mesh.prototype as any).raycast = acceleratedRaycast;\n} catch (error) {\n  console.error(\"Error setting up BVH extensions:\", error);\n}\n\nconst csgEvaluator = new Evaluator();\ncsgEvaluator.useGroups = true;\nextend({ OrbitControls });\n\n// --- Constants ---\nconst PHI = (1 + Math.sqrt(5)) / 2;\nconst INV_PHI = 1 / PHI;\n\n// --- Face Drag Coefficients ---\nconst FACE_DRAG_COEFFICIENTS = [\n  0.8, 1.0, 0.9, 1.1, 0.6, 1.2,\n  1.05, 0.75, 0.95, 1.3, 0.7, 1.15\n];\n\n// Helper: Compute effective drag multiplier based on face normals and magnetic field direction.\nfunction computeEffectiveDrag(\n  quat: THREE.Quaternion,\n  magneticFieldDir: THREE.Vector3,\n  faceData: { normal: THREE.Vector3 }[]\n) {\n  let dragSum = 0, weightSum = 0;\n  faceData.forEach((face, index) => {\n    const worldNormal = face.normal.clone().applyQuaternion(quat);\n    const alignment = Math.max(0, worldNormal.dot(magneticFieldDir));\n    dragSum += FACE_DRAG_COEFFICIENTS[index] * alignment;\n    weightSum += alignment;\n  });\n  return weightSum > 0 ? dragSum / weightSum : 1.0;\n}\n\n// Helper: Get dodecahedron data (vertices and face centers/normals).\nfunction getDodecahedronData(radius: number): {\n  vertices: THREE.Vector3[];\n  faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[];\n} {\n  if (typeof radius !== 'number' || radius <= 0 || !Number.isFinite(radius))\n    throw new Error(\"Invalid radius provided to getDodecahedronData\");\n  const uniqueVerticesMap = new Map<string, THREE.Vector3>();\n  const coords = [\n    [1, 1, 1], [-1, 1, 1], [1, -1, 1], [-1, -1, 1],\n    [1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1],\n    [0, PHI, INV_PHI], [0, -PHI, INV_PHI], [0, PHI, -INV_PHI], [0, -PHI, -INV_PHI],\n    [INV_PHI, 0, PHI], [-INV_PHI, 0, PHI], [INV_PHI, 0, -PHI], [-INV_PHI, 0, -PHI],\n    [PHI, INV_PHI, 0], [-PHI, INV_PHI, 0], [PHI, -INV_PHI, 0], [-PHI, -INV_PHI, 0]\n  ];\n  const distOriginToVertex = Math.sqrt(PHI * PHI + INV_PHI * INV_PHI);\n  const scale = radius / distOriginToVertex;\n  coords.forEach(v => {\n    const x = v[0] * scale, y = v[1] * scale, z = v[2] * scale;\n    const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`;\n    if (!uniqueVerticesMap.has(key)) {\n      uniqueVerticesMap.set(key, new THREE.Vector3(x, y, z));\n    }\n  });\n  const vertices = Array.from(uniqueVerticesMap.values());\n  const faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] = [];\n  const icoVerts = [\n    [0, 1, PHI], [0, -1, PHI], [0, 1, -PHI], [0, -1, -PHI],\n    [1, PHI, 0], [-1, PHI, 0], [1, -PHI, 0], [-1, -PHI, 0],\n    [PHI, 0, 1], [-PHI, 0, 1], [PHI, 0, -1], [-PHI, 0, -1]\n  ];\n  const faceCenterDist = radius * 1.53 / distOriginToVertex;\n  icoVerts.forEach(v => {\n    const normal = new THREE.Vector3(v[0], v[1], v[2]).normalize();\n    const center = normal.clone().multiplyScalar(faceCenterDist);\n    faceData.push({ center, normal });\n  });\n  return { vertices, faceData };\n}\n\n// --- OrbitControls Component ---\nconst Controls: React.FC = () => {\n  const { camera, gl } = useThree();\n  const controlsRef = useRef<OrbitControls>(null);\n  useEffect(() => {\n    const controls = new OrbitControls(camera, gl.domElement);\n    controls.enableDamping = true;\n    controls.target.set(0, 0, 0);\n    (controlsRef as React.MutableRefObject<OrbitControls>).current = controls;\n    return () => controls.dispose();\n  }, [camera, gl]);\n  useFrame(() => controlsRef.current?.update());\n  return null;\n};\n\n// --- Roman Dodecahedron CSG Component ---\ninterface RomanDodecahedronProps {\n  outerRadius: number;\n  thickness: number;\n  holeBaseDiameter: number;\n  holeRatio: number;\n  noduleRadius: number;\n  material?: THREE.Material;\n  wireframe?: boolean;\n  [key: string]: any;\n}\n\nconst RomanDodecahedron = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>(\n  ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, wireframe = false, ...props }, ref) => {\n    const [calculatedGeometry, setCalculatedGeometry] = useState<THREE.BufferGeometry | null>(null);\n    useEffect(() => {\n      if (\n        typeof outerRadius !== 'number' || outerRadius <= 0 ||\n        typeof thickness !== 'number' || thickness <= 0 ||\n        typeof holeBaseDiameter !== 'number' || holeBaseDiameter <= 0 ||\n        typeof holeRatio !== 'number' || holeRatio <= 0 ||\n        typeof noduleRadius !== 'number' || noduleRadius <= 0\n      ) {\n        setCalculatedGeometry(null);\n        return;\n      }\n      let geometry: THREE.BufferGeometry | null = null;\n      const tempGeoList: THREE.BufferGeometry[] = [];\n      try {\n        const { vertices: mathVertices, faceData: mathFaceData } = getDodecahedronData(outerRadius);\n        const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, 1);\n        outerDodecGeo.computeBoundsTree();\n        tempGeoList.push(outerDodecGeo);\n        const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, 1);\n        innerDodecGeo.computeBoundsTree();\n        tempGeoList.push(innerDodecGeo);\n        let outerBrush = new Brush(outerDodecGeo);\n        let innerBrush = new Brush(innerDodecGeo);\n        innerBrush.updateMatrixWorld();\n        let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n        const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * holeRatio ** i);\n        const cylinderHeight = thickness * 3.1;\n        const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16);\n        cylinderGeo.rotateX(Math.PI / 2);\n        cylinderGeo.computeBoundsTree();\n        tempGeoList.push(cylinderGeo);\n        const tempQuat = new THREE.Quaternion();\n        mathFaceData.forEach((face, index) => {\n          const holeRadius = holeDiameters[index] / 2;\n          if (!holeRadius || holeRadius <= 0) return;\n          const holeBrush = new Brush(cylinderGeo);\n          holeBrush.scale.set(holeRadius, holeRadius, 1);\n          tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), face.normal);\n          holeBrush.quaternion.copy(tempQuat);\n          holeBrush.position.copy(face.center);\n          holeBrush.updateMatrixWorld();\n          shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION);\n        });\n        const noduleGeo = new THREE.SphereGeometry(noduleRadius, 6, 6);\n        noduleGeo.computeBoundsTree();\n        tempGeoList.push(noduleGeo);\n        mathVertices.forEach(vertexPos => {\n          const noduleBrush = new Brush(noduleGeo);\n          noduleBrush.position.copy(vertexPos);\n          noduleBrush.updateMatrixWorld();\n          shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION);\n        });\n        geometry = shellBrush.geometry;\n        geometry.computeVertexNormals();\n        geometry.center();\n      } catch (error) {\n        geometry = null;\n      } finally {\n        tempGeoList.forEach(g => g.dispose());\n      }\n      setCalculatedGeometry(geometry);\n      return () => {\n        if (geometry && typeof geometry.dispose === 'function') {\n          geometry.dispose();\n        }\n      };\n    }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]);\n\n    const meshMaterial = useMemo(() => {\n      let baseMaterial: THREE.Material;\n      if (material instanceof THREE.Material) {\n        baseMaterial = material.clone();\n      } else {\n        baseMaterial = new THREE.MeshPhongMaterial({\n          color: 0xb87333,\n          specular: 0x444444,\n          shininess: 40,\n          name: \"DefaultPhongCopper\"\n        });\n      }\n      baseMaterial.side = THREE.DoubleSide;\n      if (\"wireframe\" in baseMaterial) {\n        (baseMaterial as any).wireframe = wireframe;\n      }\n      return baseMaterial;\n    }, [material, wireframe]);\n\n    if (!calculatedGeometry) return null;\n    return <mesh ref={ref} geometry={calculatedGeometry} material={meshMaterial} {...props} />;\n  }\n);\n\n// --- Physics State Interface ---\ninterface PhysicsState {\n  angularVelocity: THREE.Vector3;\n  fieldAngle: number;\n  currentTorque: THREE.Vector3;\n}\n\n// --- Main Simulation Component ---\n// Accepts an onStatusUpdate callback.\ninterface ResonatorSimulationProps {\n  onStatusUpdate: (status: { battery: number; angularVelocity: number }) => void;\n}\n\nconst ResonatorSimulation: React.FC<ResonatorSimulationProps> = ({ onStatusUpdate }) => {\n  const groupRef = useRef<THREE.Group>(null!);\n  const dodecahedronMeshRef = useRef<THREE.Mesh>(null!);\n  const particlesRef = useRef<THREE.Points>(null!);\n  const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n  // Controls (including fieldActive toggle)\n  const resonatorControls = useControls(\"Resonator Controls\", {\n    baseFieldSpeed: { value: 1.0, min: 0, max: 5, step: 0.1 },\n    fieldIntensity: { value: 1.0, min: 0, max: 5, step: 0.1 },\n    k_drag: { label: \"Induction Strength\", value: 0.5, min: 0, max: 2, step: 0.05 },\n    inertiaScale: { label: \"Inertia Scale\", value: 1.0, min: 0.1, max: 5, step: 0.1 },\n    damping: { value: 0.1, min: 0, max: 1, step: 0.01 },\n    spinUpRate: { value: 0.5, min: 0, max: 2, step: 0.1 },\n    velocityThreshold: { value: 1.5, min: 0, max: 10, step: 0.1 },\n    thresholdFeedbackFactor: { value: 2.1, min: 0, max: 5, step: 0.1 },\n    fieldActive: { value: true },\n    noduleAntifieldStrength: { value: 0.2, min: 0, max: 2, step: 0.05 }\n  });\n\n  const shellControls = useControls(\"Shell Geometry\", {\n    outerRadius: { value: 1.0 },\n    thickness: { value: 0.05 },\n    holeBaseDiameter: { value: 0.1 },\n    holeRatio: { value: 1.2 },\n    noduleRadius: { value: 0.1 }\n  });\n\n  const vizControls = useControls(\"Visualization\", {\n    particleCount: { value: 1000, min: 100, max: 50000, step: 100 },\n    particleSize: { value: 0.05, min: 0.01, max: 1.2, step: 0.01 },\n    torusMajorRadius: { value: 1.5, min: 0.5, max: 5, step: 0.1 },\n    torusMinorRadius: { value: 0.5, min: 0.1, max: 2, step: 0.05 },\n    showParticles: { value: true },\n    wireframe: { value: false }\n  });\n\n  const defaultShellParams = useMemo(() => ({\n    outerRadius: 1.0,\n    thickness: 0.05,\n    holeBaseDiameter: 0.1,\n    holeRatio: 1.2,\n    noduleRadius: 0.1\n  }), []);\n  const finalShellParams = useMemo(() => ({\n    outerRadius: shellControls.outerRadius,\n    thickness: shellControls.thickness,\n    holeBaseDiameter: shellControls.holeBaseDiameter,\n    holeRatio: shellControls.holeRatio,\n    noduleRadius: shellControls.noduleRadius\n  }), [shellControls]);\n\n  const effectiveInertia = useMemo(() => {\n    return resonatorControls.inertiaScale *\n      ((finalShellParams.outerRadius ** 5 - (finalShellParams.outerRadius - finalShellParams.thickness) ** 5) /\n       finalShellParams.outerRadius ** 5);\n  }, [resonatorControls.inertiaScale, finalShellParams.outerRadius, finalShellParams.thickness]);\n\n  // --- Battery (energy) state ---\n  const batteryRef = useRef(100);\n  const DRAIN_RATE = 10;\n  const RECHARGE_RATE = 5;\n\n  // --- New: Threshold Modifier & Charging Mode ---\n  const thresholdModifierRef = useRef(1); // multiplies the base threshold\n  const chargingModeRef = useRef(false); // true when charging\n\n  // --- Physics State ---\n  const physicsState = useRef<PhysicsState>({\n    angularVelocity: new THREE.Vector3(0, 0, 0),\n    fieldAngle: 0,\n    currentTorque: new THREE.Vector3(0, 0, 0)\n  });\n\n  // --- Particle Data ---\n  const particleData = useMemo(() => {\n    try {\n      const data = [];\n      const positions = new Float32Array(vizControls.particleCount * 3);\n      for (let i = 0; i < vizControls.particleCount; i++) {\n        const u = Math.random() * Math.PI * 2;\n        const v = Math.random() * Math.PI * 2;\n        const R = vizControls.torusMajorRadius;\n        const r = vizControls.torusMinorRadius;\n        const randR = R + (Math.random() - 0.5) * 0.2 * r;\n        const randr = r * Math.sqrt(Math.random());\n        positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u);\n        positions[i * 3 + 1] = randr * Math.sin(v);\n        positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u);\n        data.push({ u, v, R, r, yOffset: 0 }); // yOffset for easter egg mode.\n      }\n      return { positions, data };\n    } catch (error) {\n      return { positions: new Float32Array(0), data: [] };\n    }\n  }, [vizControls.particleCount, vizControls.torusMajorRadius, vizControls.torusMinorRadius]);\n\n  useEffect(() => {\n    if (particleGeoRef.current && particleData?.positions) {\n      const existingAttribute = particleGeoRef.current.getAttribute(\"position\") as THREE.BufferAttribute | undefined;\n      if (!existingAttribute || existingAttribute.array.length !== particleData.positions.length) {\n        particleGeoRef.current.setAttribute(\"position\", new THREE.BufferAttribute(particleData.positions, 3, false));\n      }\n      if (particleGeoRef.current.getAttribute(\"color\")) {\n        particleGeoRef.current.deleteAttribute(\"color\");\n      }\n    } else {\n      if (particleGeoRef.current?.getAttribute(\"position\")) {\n        particleGeoRef.current.deleteAttribute(\"position\");\n      }\n    }\n  }, [particleData]);\n\n  // --- 3D Vector Physics Update with Energy, Threshold Modulation, and Easter Egg ---\n  useFrame((state, delta) => {\n    const ps = physicsState.current;\n    const fieldActive = resonatorControls.fieldActive;\n    const baseThreshold = resonatorControls.velocityThreshold;\n    const actualThreshold = baseThreshold * thresholdModifierRef.current;\n\n    // Check if shell speed exceeds the current threshold â†’ enter charging mode.\n    if (ps.angularVelocity.length() > actualThreshold) {\n      chargingModeRef.current = true;\n    }\n\n    if (chargingModeRef.current) {\n      // Charging: battery increases.\n      batteryRef.current = Math.min(batteryRef.current + RECHARGE_RATE * delta, 100);\n      // Once battery fully charges, exit charging mode, boost angular velocity, and increase threshold.\n      if (batteryRef.current >= 100) {\n        chargingModeRef.current = false;\n        thresholdModifierRef.current += 0.2;\n        ps.angularVelocity.multiplyScalar(1.1);\n      }\n    } else {\n      // Draining: if field active and battery available.\n      if (fieldActive && batteryRef.current > 0) {\n        batteryRef.current = Math.max(batteryRef.current - DRAIN_RATE * delta, 0);\n      } else {\n        batteryRef.current = Math.min(batteryRef.current + RECHARGE_RATE * delta, 100);\n      }\n    }\n\n    // Only update field angle if field is active and battery > 0.\n    if (fieldActive && batteryRef.current > 0) {\n      ps.fieldAngle += resonatorControls.spinUpRate * delta;\n    }\n    const magneticFieldDir = new THREE.Vector3(Math.cos(ps.fieldAngle), Math.sin(ps.fieldAngle), 0).normalize();\n    const desiredAngularVel = fieldActive ? magneticFieldDir.clone().multiplyScalar(resonatorControls.baseFieldSpeed) : new THREE.Vector3(0, 0, 0);\n    const error = desiredAngularVel.clone().sub(ps.angularVelocity);\n    const { faceData } = getDodecahedronData(finalShellParams.outerRadius);\n    const effectiveDragFactor = computeEffectiveDrag(groupRef.current.quaternion, magneticFieldDir, faceData);\n    const dragTorque = error.clone().multiplyScalar(effectiveDragFactor * resonatorControls.k_drag * resonatorControls.fieldIntensity);\n    const currentSpeed = ps.angularVelocity.length();\n    let feedbackTorque = new THREE.Vector3(0, 0, 0);\n    if (currentSpeed > actualThreshold) {\n      const overage = currentSpeed - actualThreshold;\n      feedbackTorque = ps.angularVelocity.clone().normalize().multiplyScalar(-resonatorControls.thresholdFeedbackFactor * overage);\n    }\n    let netTorque = dragTorque.add(feedbackTorque);\n    // Nodule Antifield Torque:\n    let noduleTorque = new THREE.Vector3(0, 0, 0);\n    const nodulePositions = getDodecahedronData(finalShellParams.outerRadius).vertices;\n    nodulePositions.forEach(nodulePos => {\n      const worldPos = nodulePos.clone().applyQuaternion(groupRef.current.quaternion);\n      const contribution = worldPos.clone().cross(magneticFieldDir).multiplyScalar(resonatorControls.noduleAntifieldStrength);\n      noduleTorque.add(contribution);\n    });\n    netTorque.add(noduleTorque);\n    ps.currentTorque.copy(netTorque);\n    const angularAccel = netTorque.clone().divideScalar(effectiveInertia);\n    ps.angularVelocity.add(angularAccel.multiplyScalar(delta));\n    ps.angularVelocity.multiplyScalar(1 - resonatorControls.damping * delta);\n    const deltaAngle = ps.angularVelocity.length() * delta;\n    if (deltaAngle > 0) {\n      const rotationAxis = ps.angularVelocity.clone().normalize();\n      const deltaQuat = new THREE.Quaternion().setFromAxisAngle(rotationAxis, deltaAngle);\n      groupRef.current.quaternion.multiply(deltaQuat);\n    }\n    // Optional emissive update.\n    if (dodecahedronMeshRef.current) {\n      const currentMaterial = dodecahedronMeshRef.current.material;\n      if (currentMaterial instanceof THREE.MeshStandardMaterial || currentMaterial instanceof THREE.MeshPhysicalMaterial) {\n        if (currentMaterial.emissive) {\n          const maxTorqueEst = resonatorControls.k_drag * resonatorControls.fieldIntensity * (resonatorControls.baseFieldSpeed * 1.5 + 1);\n          const emissionStrength = Math.min(netTorque.length() / (maxTorqueEst + 0.01), 1.0);\n          currentMaterial.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5);\n        }\n      }\n    }\n\n    // --- Particle Update ---\n    // Get particle positions array.\n    const positions = particleGeoRef.current?.attributes.position?.array as Float32Array;\n    const pData = particleData.data;\n    // Easter Egg branch: if angular velocity becomes NaN, trigger special particle behavior.\n    const easterEggActive = isNaN(ps.angularVelocity.length());\n    if (easterEggActive) {\n      // In this mode, particles escape along vertical \"jets\" and leave trails.\n      for (let i = 0; i < pData.length; i++) {\n        // Initialize a vertical offset property if not present.\n        if (pData[i].yOffset === undefined) pData[i].yOffset = 0;\n        // Increase vertical offset.\n        pData[i].yOffset += 0.5 * delta; // Adjust speed as needed.\n        // For a vertical jet effect, let horizontal offsets be small random values.\n        if ((pData[i] as any).originalX === undefined) {\n          (pData[i] as any).originalX = (Math.random() - 0.5) * 0.2;\n          (pData[i] as any).originalZ = (Math.random() - 0.5) * 0.2;\n        }\n        positions[i * 3] = (pData[i] as any).originalX;\n        positions[i * 3 + 1] = pData[i].yOffset;\n        positions[i * 3 + 2] = (pData[i] as any).originalZ;\n        // If a particle moves too far, reset it (simulate disappearing and respawning).\n        if (pData[i].yOffset > 5) {\n          pData[i].yOffset = 0;\n          (pData[i] as any).originalX = (Math.random() - 0.5) * 0.2;\n          (pData[i] as any).originalZ = (Math.random() - 0.5) * 0.2;\n        }\n      }\n      particleGeoRef.current.attributes.position.needsUpdate = true;\n    } else {\n      // Normal particle update: toroidal swirl.\n      const speed = resonatorControls.baseFieldSpeed * resonatorControls.fieldIntensity;\n      if (pData && pData.length * 3 === positions.length) {\n        const pointsMat = particlesRef.current.material as THREE.PointsMaterial;\n        if (pointsMat) pointsMat.size = vizControls.particleSize * (1 + resonatorControls.fieldIntensity * 0.5);\n        for (let i = 0; i < pData.length; i++) {\n          const data = pData[i];\n          data.u += speed * delta;\n          const R = vizControls.torusMajorRadius;\n          const r = vizControls.torusMinorRadius;\n          const u = data.u;\n          const v = data.v;\n          const bufferIndex = i * 3;\n          positions[bufferIndex] = (R + r * Math.cos(v)) * Math.cos(u);\n          positions[bufferIndex + 1] = r * Math.sin(v);\n          positions[bufferIndex + 2] = (R + r * Math.cos(v)) * Math.sin(u);\n        }\n        particleGeoRef.current.attributes.position.needsUpdate = true;\n      }\n    }\n\n    // Report status.\n    onStatusUpdate({\n      battery: batteryRef.current,\n      angularVelocity: ps.angularVelocity.length()\n    });\n  });\n\n  return (\n    <group ref={groupRef}>\n      <RomanDodecahedron\n        ref={dodecahedronMeshRef}\n        outerRadius={finalShellParams.outerRadius}\n        thickness={finalShellParams.thickness}\n        holeBaseDiameter={finalShellParams.holeBaseDiameter}\n        holeRatio={finalShellParams.holeRatio}\n        noduleRadius={finalShellParams.noduleRadius}\n        wireframe={vizControls.wireframe}\n        castShadow\n        receiveShadow\n        position={[0, 0, 0]}\n        rotation={[0, 0, 0]}\n      />\n      {vizControls.showParticles && (\n        <points ref={particlesRef} name=\"FieldParticles\">\n          <bufferGeometry ref={particleGeoRef} />\n          <pointsMaterial\n            name=\"ParticleMaterial\"\n            color={0x00ffff}\n            size={vizControls.particleSize}\n            transparent\n            opacity={0.7}\n            blending={THREE.AdditiveBlending}\n            sizeAttenuation={false}\n            map={null}\n          />\n        </points>\n      )}\n    </group>\n  );\n};\n\nconst TemporalResonatorScene: React.FC = () => {\n  const [status, setStatus] = useState({ battery: 100, angularVelocity: 0 });\n  // Internal light toggle state.\n  const [internalLightActive, setInternalLightActive] = useState(false);\n\n  return (\n    <>\n      <Leva collapsed={false} titleBar={{ title: \"Controls\" }} />\n      <Canvas\n        style={{\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          width: \"100vw\",\n          height: \"100vh\",\n          background: \"#111122\",\n          zIndex: 0\n        }}\n        camera={{ position: [3, 3, 5], fov: 75 }}\n        gl={{ antialias: true }}\n        shadows\n      >\n        {/* Lower ambient light so that without internal light the copper shell is dark */}\n        <ambientLight intensity={0.0} />\n        <hemisphereLight groundColor={0x404040} intensity={0.3} />\n        <directionalLight\n          position={[5, 10, 7.5]}\n          intensity={0.8}\n          castShadow\n          shadow-mapSize-width={1024}\n          shadow-mapSize-height={1024}\n          shadow-camera-far={25}\n          shadow-camera-left={-10}\n          shadow-camera-right={10}\n          shadow-camera-top={10}\n          shadow-camera-bottom={-10}\n        />\n        {/* Internal light (heating effect) only on when toggled */}\n        {internalLightActive && (\n          <pointLight\n            intensity={0.5}\n            color={0xffddcc}\n            distance={3}\n            decay={1.5}\n            position={[0, 0, 0]}\n            name=\"InternalLight\"\n          />\n        )}\n        <ErrorBoundary>\n          <Suspense fallback={<LoadingPlaceholder />}>\n            <ResonatorSimulation onStatusUpdate={setStatus} />\n          </Suspense>\n        </ErrorBoundary>\n        <Controls />\n      </Canvas>\n      <StatusOverlay\n        status={status}\n        internalLightActive={internalLightActive}\n        setInternalLightActive={setInternalLightActive}\n      />\n    </>\n  );\n};\n\n// --- Status Overlay Component ---\n// Renders battery and angular velocity bars plus a button to toggle the internal light.\nconst StatusOverlay: React.FC<{\n  status: { battery: number; angularVelocity: number };\n  internalLightActive: boolean;\n  setInternalLightActive: (active: boolean) => void;\n}> = ({ status, internalLightActive, setInternalLightActive }) => {\n  const batteryPercent = status.battery;\n  const angularPercent = Math.min((status.angularVelocity / 10) * 100, 100);\n  const overlayStyle: React.CSSProperties = {\n    position: 'absolute',\n    top: 20,\n    left: 20,\n    color: '#fff',\n    fontFamily: 'sans-serif',\n    zIndex: 10\n  };\n  const barContainer: React.CSSProperties = {\n    width: '200px',\n    height: '20px',\n    background: '#555',\n    borderRadius: '10px',\n    overflow: 'hidden',\n    marginBottom: '10px'\n  };\n  const buttonStyle: React.CSSProperties = {\n    padding: '8px 16px',\n    fontSize: '14px',\n    borderRadius: '5px',\n    cursor: 'pointer'\n  };\n  return (\n    <div style={overlayStyle}>\n      <div>\n        <div>Battery: {batteryPercent.toFixed(0)}%</div>\n        <div style={barContainer}>\n          <div style={{ width: `${batteryPercent}%`, height: '100%', background: 'limegreen' }}></div>\n        </div>\n      </div>\n      <div>\n        <div>Angular Velocity: {status.angularVelocity.toFixed(2)}</div>\n        <div style={barContainer}>\n          <div style={{ width: `${angularPercent}%`, height: '100%', background: 'orange' }}></div>\n        </div>\n      </div>\n      <div>\n        <button style={buttonStyle} onClick={() => setInternalLightActive(!internalLightActive)}>\n          {internalLightActive ? \"Turn Off Internal Light\" : \"Turn On Internal Light\"}\n        </button>\n      </div>\n    </div>\n  );\n};\n\n// --- Loading Placeholder Component ---\nconst LoadingPlaceholder: React.FC = () => {\n  return (\n    <mesh>\n      <boxGeometry args={[0.1, 0.1, 0.1]} />\n      <meshBasicMaterial color=\"orange\" wireframe attach=\"material\" />\n    </mesh>\n  );\n};\n\nexport default TemporalResonatorScene;\n\n\n// // === Full Code: TemporalResonatorScene_ToggleChargeThreshold.tsx ===\n\n// import React, { useRef, useEffect, useMemo, Suspense, useState } from 'react';\n// import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// import * as THREE from 'three';\n// import ErrorBoundary from './errorBoundary'; // Adjust path if needed\n// import { useControls, Leva } from 'leva';\n// import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\n// import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n\n// // --- BVH / CSG Setup ---\n// try {\n//   (THREE.BufferGeometry.prototype as any).computeBoundsTree = computeBoundsTree;\n//   (THREE.BufferGeometry.prototype as any).disposeBoundsTree = disposeBoundsTree;\n//   (THREE.Mesh.prototype as any).raycast = acceleratedRaycast;\n// } catch (error) {\n//   console.error(\"Error setting up BVH extensions:\", error);\n// }\n\n// const csgEvaluator = new Evaluator();\n// csgEvaluator.useGroups = true;\n// extend({ OrbitControls });\n\n// // --- Constants ---\n// const PHI = (1 + Math.sqrt(5)) / 2;\n// const INV_PHI = 1 / PHI;\n\n// // --- Face Drag Coefficients ---\n// const FACE_DRAG_COEFFICIENTS = [\n//   0.8, 1.0, 0.9, 1.1, 0.6, 1.2,\n//   1.05, 0.75, 0.95, 1.3, 0.7, 1.15\n// ];\n\n// // Helper: Compute effective drag multiplier based on face normals and magnetic field direction.\n// function computeEffectiveDrag(\n//   quat: THREE.Quaternion,\n//   magneticFieldDir: THREE.Vector3,\n//   faceData: { normal: THREE.Vector3 }[]\n// ) {\n//   let dragSum = 0, weightSum = 0;\n//   faceData.forEach((face, index) => {\n//     const worldNormal = face.normal.clone().applyQuaternion(quat);\n//     const alignment = Math.max(0, worldNormal.dot(magneticFieldDir));\n//     dragSum += FACE_DRAG_COEFFICIENTS[index] * alignment;\n//     weightSum += alignment;\n//   });\n//   return weightSum > 0 ? dragSum / weightSum : 1.0;\n// }\n\n// // Helper: Generate dodecahedron math data.\n// function getDodecahedronData(radius: number): {\n//   vertices: THREE.Vector3[];\n//   faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[];\n// } {\n//   if (typeof radius !== 'number' || radius <= 0 || !Number.isFinite(radius)) {\n//     throw new Error(\"Invalid radius provided to getDodecahedronData\");\n//   }\n//   const uniqueVerticesMap = new Map<string, THREE.Vector3>();\n//   const coords = [\n//     [1, 1, 1], [-1, 1, 1], [1, -1, 1], [-1, -1, 1],\n//     [1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1],\n//     [0, PHI, INV_PHI], [0, -PHI, INV_PHI], [0, PHI, -INV_PHI], [0, -PHI, -INV_PHI],\n//     [INV_PHI, 0, PHI], [-INV_PHI, 0, PHI], [INV_PHI, 0, -PHI], [-INV_PHI, 0, -PHI],\n//     [PHI, INV_PHI, 0], [-PHI, INV_PHI, 0], [PHI, -INV_PHI, 0], [-PHI, -INV_PHI, 0]\n//   ];\n//   const distOriginToVertex = Math.sqrt(PHI * PHI + INV_PHI * INV_PHI);\n//   const scale = radius / distOriginToVertex;\n//   coords.forEach(v => {\n//     const x = v[0] * scale, y = v[1] * scale, z = v[2] * scale;\n//     const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`;\n//     if (!uniqueVerticesMap.has(key)) uniqueVerticesMap.set(key, new THREE.Vector3(x, y, z));\n//   });\n//   const vertices = Array.from(uniqueVerticesMap.values());\n//   const faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] = [];\n//   const icoVerts = [\n//     [0, 1, PHI], [0, -1, PHI], [0, 1, -PHI], [0, -1, -PHI],\n//     [1, PHI, 0], [-1, PHI, 0], [1, -PHI, 0], [-1, -PHI, 0],\n//     [PHI, 0, 1], [-PHI, 0, 1], [PHI, 0, -1], [-PHI, 0, -1]\n//   ];\n//   const faceCenterDist = radius * 1.53 / distOriginToVertex;\n//   icoVerts.forEach(v => {\n//     const normal = new THREE.Vector3(v[0], v[1], v[2]).normalize();\n//     const center = normal.clone().multiplyScalar(faceCenterDist);\n//     faceData.push({ center, normal });\n//   });\n//   return { vertices, faceData };\n// }\n\n// // --- OrbitControls Component ---\n// const Controls: React.FC = () => {\n//   const { camera, gl } = useThree();\n//   const controlsRef = useRef<OrbitControls>(null);\n//   useEffect(() => {\n//     const controls = new OrbitControls(camera, gl.domElement);\n//     controls.enableDamping = true;\n//     controls.target.set(0, 0, 0);\n//     (controlsRef as React.MutableRefObject<OrbitControls>).current = controls;\n//     return () => controls.dispose();\n//   }, [camera, gl]);\n//   useFrame(() => controlsRef.current?.update());\n//   return null;\n// };\n\n// // --- Roman Dodecahedron CSG Component ---\n// interface RomanDodecahedronProps {\n//   outerRadius: number;\n//   thickness: number;\n//   holeBaseDiameter: number;\n//   holeRatio: number;\n//   noduleRadius: number;\n//   material?: THREE.Material;\n//   wireframe?: boolean;\n//   [key: string]: any;\n// }\n\n// const RomanDodecahedron = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>(\n//   ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, wireframe = false, ...props }, ref) => {\n//     const [calculatedGeometry, setCalculatedGeometry] = useState<THREE.BufferGeometry | null>(null);\n//     useEffect(() => {\n//       if (\n//         typeof outerRadius !== 'number' || outerRadius <= 0 ||\n//         typeof thickness !== 'number' || thickness <= 0 ||\n//         typeof holeBaseDiameter !== 'number' || holeBaseDiameter <= 0 ||\n//         typeof holeRatio !== 'number' || holeRatio <= 0 ||\n//         typeof noduleRadius !== 'number' || noduleRadius <= 0\n//       ) {\n//         setCalculatedGeometry(null);\n//         return;\n//       }\n//       let geometry: THREE.BufferGeometry | null = null;\n//       const tempGeoList: THREE.BufferGeometry[] = [];\n//       try {\n//         const { vertices: mathVertices, faceData: mathFaceData } = getDodecahedronData(outerRadius);\n//         const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, 1);\n//         outerDodecGeo.computeBoundsTree();\n//         tempGeoList.push(outerDodecGeo);\n//         const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, 1);\n//         innerDodecGeo.computeBoundsTree();\n//         tempGeoList.push(innerDodecGeo);\n//         let outerBrush = new Brush(outerDodecGeo);\n//         let innerBrush = new Brush(innerDodecGeo);\n//         innerBrush.updateMatrixWorld();\n//         let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n//         const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * holeRatio ** i);\n//         const cylinderHeight = thickness * 3.1;\n//         const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16);\n//         cylinderGeo.rotateX(Math.PI / 2);\n//         cylinderGeo.computeBoundsTree();\n//         tempGeoList.push(cylinderGeo);\n//         const tempQuat = new THREE.Quaternion();\n//         mathFaceData.forEach((face, index) => {\n//           const holeRadius = holeDiameters[index] / 2;\n//           if (!holeRadius || holeRadius <= 0) return;\n//           const holeBrush = new Brush(cylinderGeo);\n//           holeBrush.scale.set(holeRadius, holeRadius, 1);\n//           tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), face.normal);\n//           holeBrush.quaternion.copy(tempQuat);\n//           holeBrush.position.copy(face.center);\n//           holeBrush.updateMatrixWorld();\n//           shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION);\n//         });\n//         const noduleGeo = new THREE.SphereGeometry(noduleRadius, 6, 6);\n//         noduleGeo.computeBoundsTree();\n//         tempGeoList.push(noduleGeo);\n//         mathVertices.forEach(vertexPos => {\n//           const noduleBrush = new Brush(noduleGeo);\n//           noduleBrush.position.copy(vertexPos);\n//           noduleBrush.updateMatrixWorld();\n//           shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION);\n//         });\n//         geometry = shellBrush.geometry;\n//         geometry.computeVertexNormals();\n//         geometry.center();\n//       } catch (error) {\n//         geometry = null;\n//       } finally {\n//         tempGeoList.forEach(g => g.dispose());\n//       }\n//       setCalculatedGeometry(geometry);\n//       return () => {\n//         if (geometry && typeof geometry.dispose === 'function') {\n//           geometry.dispose();\n//         }\n//       };\n//     }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]);\n\n//     const meshMaterial = useMemo(() => {\n//       let baseMaterial: THREE.Material;\n//       if (material instanceof THREE.Material) {\n//         baseMaterial = material.clone();\n//       } else {\n//         baseMaterial = new THREE.MeshPhongMaterial({\n//           color: 0xb87333,\n//           specular: 0x444444,\n//           shininess: 40,\n//           name: \"DefaultPhongCopper\"\n//         });\n//       }\n//       baseMaterial.side = THREE.DoubleSide;\n//       if (\"wireframe\" in baseMaterial) {\n//         (baseMaterial as any).wireframe = wireframe;\n//       }\n//       return baseMaterial;\n//     }, [material, wireframe]);\n\n//     if (!calculatedGeometry) return null;\n//     return <mesh ref={ref} geometry={calculatedGeometry} material={meshMaterial} {...props} />;\n//   }\n// );\n\n// // --- Physics State Interface ---\n// interface PhysicsState {\n//   angularVelocity: THREE.Vector3;\n//   fieldAngle: number;\n//   currentTorque: THREE.Vector3;\n// }\n\n// // --- Main Simulation Component ---\n// // Accepts an onStatusUpdate callback to report battery and angular velocity.\n// interface ResonatorSimulationProps {\n//   onStatusUpdate: (status: { battery: number; angularVelocity: number }) => void;\n// }\n\n// const ResonatorSimulation: React.FC<ResonatorSimulationProps> = ({ onStatusUpdate }) => {\n//   const groupRef = useRef<THREE.Group>(null!);\n//   const dodecahedronMeshRef = useRef<THREE.Mesh>(null!);\n//   const particlesRef = useRef<THREE.Points>(null!);\n//   const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n//   // Controls (including fieldActive toggle)\n//   const resonatorControls = useControls(\"Resonator Controls\", {\n//     baseFieldSpeed: { value: 1.0, min: 0, max: 5, step: 0.1 },\n//     fieldIntensity: { value: 1.0, min: 0, max: 5, step: 0.1 },\n//     k_drag: { label: \"Induction Strength\", value: 0.5, min: 0, max: 2, step: 0.05 },\n//     inertiaScale: { label: \"Inertia Scale\", value: 1.0, min: 0.1, max: 5, step: 0.1 },\n//     damping: { value: 0.1, min: 0, max: 1, step: 0.01 },\n//     spinUpRate: { value: 0.5, min: 0, max: 2, step: 0.1 },\n//     velocityThreshold: { value: 1.5, min: 0, max: 10, step: 0.1 },\n//     thresholdFeedbackFactor: { value: 2.1, min: 0, max: 5, step: 0.1 },\n//     fieldActive: { value: true },\n//     noduleAntifieldStrength: { value: 0.2, min: 0, max: 2, step: 0.05 }\n//   });\n\n//   const shellControls = useControls(\"Shell Geometry\", {\n//     outerRadius: { value: 1.0 },\n//     thickness: { value: 0.05 },\n//     holeBaseDiameter: { value: 0.1 },\n//     holeRatio: { value: 1.2 },\n//     noduleRadius: { value: 0.1 }\n//   });\n\n//   const vizControls = useControls(\"Visualization\", {\n//     particleCount: { value: 1000, min: 100, max: 5000, step: 100 },\n//     particleSize: { value: 0.05, min: 0.01, max: 0.2, step: 0.01 },\n//     torusMajorRadius: { value: 1.5, min: 0.5, max: 5, step: 0.1 },\n//     torusMinorRadius: { value: 0.5, min: 0.1, max: 2, step: 0.05 },\n//     showParticles: { value: true },\n//     wireframe: { value: false }\n//   });\n\n//   const defaultShellParams = useMemo(() => ({\n//     outerRadius: 1.0,\n//     thickness: 0.05,\n//     holeBaseDiameter: 0.1,\n//     holeRatio: 1.2,\n//     noduleRadius: 0.1\n//   }), []);\n//   const finalShellParams = useMemo(() => ({\n//     outerRadius: shellControls.outerRadius,\n//     thickness: shellControls.thickness,\n//     holeBaseDiameter: shellControls.holeBaseDiameter,\n//     holeRatio: shellControls.holeRatio,\n//     noduleRadius: shellControls.noduleRadius\n//   }), [shellControls]);\n\n//   const effectiveInertia = useMemo(() => {\n//     return resonatorControls.inertiaScale *\n//       ((finalShellParams.outerRadius ** 5 -\n//         (finalShellParams.outerRadius - finalShellParams.thickness) ** 5) /\n//        finalShellParams.outerRadius ** 5);\n//   }, [resonatorControls.inertiaScale, finalShellParams.outerRadius, finalShellParams.thickness]);\n\n//   // --- Battery (energy) state ---\n//   const batteryRef = useRef(100);\n//   const DRAIN_RATE = 10;\n//   const RECHARGE_RATE = 5;\n\n//   // --- New: Threshold Modifier & Charging Mode ---\n//   const thresholdModifierRef = useRef(1); // multiplies the base threshold\n//   const chargingModeRef = useRef(false); // true when charging\n\n//   // --- Physics State ---\n//   const physicsState = useRef<PhysicsState>({\n//     angularVelocity: new THREE.Vector3(0, 0, 0),\n//     fieldAngle: 0,\n//     currentTorque: new THREE.Vector3(0, 0, 0)\n//   });\n\n//   // --- Particle Data ---\n//   const particleData = useMemo(() => {\n//     try {\n//       const data = [];\n//       const positions = new Float32Array(vizControls.particleCount * 3);\n//       for (let i = 0; i < vizControls.particleCount; i++) {\n//         const u = Math.random() * Math.PI * 2;\n//         const v = Math.random() * Math.PI * 2;\n//         const R = vizControls.torusMajorRadius;\n//         const r = vizControls.torusMinorRadius;\n//         const randR = R + (Math.random() - 0.5) * 0.2 * r;\n//         const randr = r * Math.sqrt(Math.random());\n//         positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u);\n//         positions[i * 3 + 1] = randr * Math.sin(v);\n//         positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u);\n//         data.push({ u, v, R, r: randr });\n//       }\n//       return { positions, data };\n//     } catch (error) {\n//       return { positions: new Float32Array(0), data: [] };\n//     }\n//   }, [vizControls.particleCount, vizControls.torusMajorRadius, vizControls.torusMinorRadius]);\n\n//   useEffect(() => {\n//     if (particleGeoRef.current && particleData?.positions) {\n//       const existingAttribute = particleGeoRef.current.getAttribute(\"position\") as THREE.BufferAttribute | undefined;\n//       if (!existingAttribute || existingAttribute.array.length !== particleData.positions.length) {\n//         particleGeoRef.current.setAttribute(\"position\", new THREE.BufferAttribute(particleData.positions, 3, false));\n//       }\n//       if (particleGeoRef.current.getAttribute(\"color\")) {\n//         particleGeoRef.current.deleteAttribute(\"color\");\n//       }\n//     } else {\n//       if (particleGeoRef.current?.getAttribute(\"position\")) {\n//         particleGeoRef.current.deleteAttribute(\"position\");\n//       }\n//     }\n//   }, [particleData]);\n\n//   // --- 3D Vector Physics Update with Energy, Threshold Modulation, and Nodule Antifield ---\n//   useFrame((state, delta) => {\n//     const ps = physicsState.current;\n//     const fieldActive = resonatorControls.fieldActive;\n//     const baseThreshold = resonatorControls.velocityThreshold;\n//     const actualThreshold = baseThreshold * thresholdModifierRef.current;\n\n//     // Check if shell speed exceeds the current threshold â†’ enter charging mode.\n//     if (ps.angularVelocity.length() > actualThreshold) {\n//       chargingModeRef.current = true;\n//     }\n\n//     if (chargingModeRef.current) {\n//       // Charging: battery increases.\n//       batteryRef.current = Math.min(batteryRef.current + RECHARGE_RATE * delta, 100);\n//       // Once battery fully charges, exit charging mode and boost threshold and angular velocity.\n//       if (batteryRef.current >= 100) {\n//         chargingModeRef.current = false;\n//         thresholdModifierRef.current += 0.2; // Increase required speed for next cycle.\n//         // Boost angular velocity by 10% to simulate momentum.\n//         ps.angularVelocity.multiplyScalar(1.1);\n//       }\n//     } else {\n//       // Draining: if field active and battery > 0, battery decreases.\n//       if (fieldActive && batteryRef.current > 0) {\n//         batteryRef.current = Math.max(batteryRef.current - DRAIN_RATE * delta, 0);\n//       } else {\n//         // If not field active, battery slowly recharges.\n//         batteryRef.current = Math.min(batteryRef.current + RECHARGE_RATE * delta, 100);\n//       }\n//     }\n\n//     // Field evolution: if field active and battery available, update field angle.\n//     if (fieldActive && batteryRef.current > 0) {\n//       ps.fieldAngle += resonatorControls.spinUpRate * delta;\n//     }\n//     const magneticFieldDir = new THREE.Vector3(Math.cos(ps.fieldAngle), Math.sin(ps.fieldAngle), 0).normalize();\n//     const desiredAngularVel = fieldActive ? magneticFieldDir.clone().multiplyScalar(resonatorControls.baseFieldSpeed) : new THREE.Vector3(0, 0, 0);\n//     const error = desiredAngularVel.clone().sub(ps.angularVelocity);\n//     const { faceData } = getDodecahedronData(finalShellParams.outerRadius);\n//     const effectiveDragFactor = computeEffectiveDrag(groupRef.current.quaternion, magneticFieldDir, faceData);\n//     const dragTorque = error.clone().multiplyScalar(effectiveDragFactor * resonatorControls.k_drag * resonatorControls.fieldIntensity);\n//     const currentSpeed = ps.angularVelocity.length();\n//     let feedbackTorque = new THREE.Vector3(0, 0, 0);\n//     if (currentSpeed > actualThreshold) {\n//       const overage = currentSpeed - actualThreshold;\n//       feedbackTorque = ps.angularVelocity.clone().normalize().multiplyScalar(-resonatorControls.thresholdFeedbackFactor * overage);\n//     }\n//     let netTorque = dragTorque.add(feedbackTorque);\n//     // Nodule Antifield Torque:\n//     let noduleTorque = new THREE.Vector3(0, 0, 0);\n//     const nodulePositions = getDodecahedronData(finalShellParams.outerRadius).vertices;\n//     nodulePositions.forEach(nodulePos => {\n//       const worldPos = nodulePos.clone().applyQuaternion(groupRef.current.quaternion);\n//       const contribution = worldPos.clone().cross(magneticFieldDir).multiplyScalar(resonatorControls.noduleAntifieldStrength);\n//       noduleTorque.add(contribution);\n//     });\n//     netTorque.add(noduleTorque);\n//     ps.currentTorque.copy(netTorque);\n//     const angularAccel = netTorque.clone().divideScalar(effectiveInertia);\n//     ps.angularVelocity.add(angularAccel.multiplyScalar(delta));\n//     ps.angularVelocity.multiplyScalar(1 - resonatorControls.damping * delta);\n//     const deltaAngle = ps.angularVelocity.length() * delta;\n//     if (deltaAngle > 0) {\n//       const rotationAxis = ps.angularVelocity.clone().normalize();\n//       const deltaQuat = new THREE.Quaternion().setFromAxisAngle(rotationAxis, deltaAngle);\n//       groupRef.current.quaternion.multiply(deltaQuat);\n//     }\n//     // Optional emissive update.\n//     if (dodecahedronMeshRef.current) {\n//       const currentMaterial = dodecahedronMeshRef.current.material;\n//       if (currentMaterial instanceof THREE.MeshStandardMaterial || currentMaterial instanceof THREE.MeshPhysicalMaterial) {\n//         if (currentMaterial.emissive) {\n//           const maxTorqueEst = resonatorControls.k_drag * resonatorControls.fieldIntensity * (resonatorControls.baseFieldSpeed * 1.5 + 1);\n//           const emissionStrength = Math.min(netTorque.length() / (maxTorqueEst + 0.01), 1.0);\n//           currentMaterial.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5);\n//         }\n//       }\n//     }\n//     // Update particle positions.\n//     if (\n//       vizControls.showParticles &&\n//       particleGeoRef.current?.attributes.position &&\n//       particlesRef.current &&\n//       particleData?.data\n//     ) {\n//       const positions = particleGeoRef.current.attributes.position.array as Float32Array;\n//       const speed = resonatorControls.baseFieldSpeed * resonatorControls.fieldIntensity;\n//       const pData = particleData.data;\n//       if (pData && pData.length * 3 === positions.length) {\n//         const pointsMat = particlesRef.current.material as THREE.PointsMaterial;\n//         if (pointsMat) pointsMat.size = vizControls.particleSize * (1 + resonatorControls.fieldIntensity * 0.5);\n//         for (let i = 0; i < pData.length; i++) {\n//           const data = pData[i];\n//           data.u += speed * delta;\n//           const R = vizControls.torusMajorRadius;\n//           const r = data.r;\n//           const u = data.u;\n//           const v = data.v;\n//           const bufferIndex = i * 3;\n//           positions[bufferIndex] = (R + r * Math.cos(v)) * Math.cos(u);\n//           positions[bufferIndex + 1] = r * Math.sin(v);\n//           positions[bufferIndex + 2] = (R + r * Math.cos(v)) * Math.sin(u);\n//         }\n//         particleGeoRef.current.attributes.position.needsUpdate = true;\n//       }\n//     }\n//     // Report status.\n//     onStatusUpdate({\n//       battery: batteryRef.current,\n//       angularVelocity: ps.angularVelocity.length()\n//     });\n//   });\n\n//   return (\n//     <group ref={groupRef}>\n//       <RomanDodecahedron\n//         ref={dodecahedronMeshRef}\n//         outerRadius={finalShellParams.outerRadius}\n//         thickness={finalShellParams.thickness}\n//         holeBaseDiameter={finalShellParams.holeBaseDiameter}\n//         holeRatio={finalShellParams.holeRatio}\n//         noduleRadius={finalShellParams.noduleRadius}\n//         wireframe={vizControls.wireframe}\n//         castShadow\n//         receiveShadow\n//         position={[0, 0, 0]}\n//         rotation={[0, 0, 0]}\n//       />\n//       {/* Note: The internal (heating) light is now controlled via overlay below. */}\n//       {vizControls.showParticles && (\n//         <points ref={particlesRef} name=\"FieldParticles\">\n//           <bufferGeometry ref={particleGeoRef} />\n//           <pointsMaterial\n//             name=\"ParticleMaterial\"\n//             color={0x00ffff}\n//             size={vizControls.particleSize}\n//             transparent\n//             opacity={0.7}\n//             blending={THREE.AdditiveBlending}\n//             sizeAttenuation={false}\n//             map={null}\n//           />\n//         </points>\n//       )}\n//     </group>\n//   );\n// };\n\n// const TemporalResonatorScene: React.FC = () => {\n//   // Global status state.\n//   const [status, setStatus] = useState({ battery: 100, angularVelocity: 0 });\n//   // Internal light toggle state.\n//   const [internalLightActive, setInternalLightActive] = useState(false);\n\n//   return (\n//     <>\n//       <Leva collapsed={false} titleBar={{ title: \"Controls\" }} />\n//       <Canvas\n//         style={{\n//           position: \"absolute\",\n//           top: 0,\n//           left: 0,\n//           width: \"100vw\",\n//           height: \"100vh\",\n//           background: \"#111122\",\n//           zIndex: 0\n//         }}\n//         camera={{ position: [3, 3, 5], fov: 75 }}\n//         gl={{ antialias: true }}\n//         shadows\n//       >\n//         {/** Lower ambient light so that without internal light the copper shell is dark */}\n//         <ambientLight intensity={0.0} />\n//         <hemisphereLight groundColor={0x404040} intensity={0.3} />\n//         <directionalLight\n//           position={[5, 10, 7.5]}\n//           intensity={0.8}\n//           castShadow\n//           shadow-mapSize-width={1024}\n//           shadow-mapSize-height={1024}\n//           shadow-camera-far={25}\n//           shadow-camera-left={-10}\n//           shadow-camera-right={10}\n//           shadow-camera-top={10}\n//           shadow-camera-bottom={-10}\n//         />\n//         {/** Internal light (heating effect) renders only when toggled on */}\n//         {internalLightActive && (\n//           <pointLight\n//             intensity={0.5}\n//             color={0xffddcc}\n//             distance={3}\n//             decay={1.5}\n//             position={[0, 0, 0]}\n//             name=\"InternalLight\"\n//           />\n//         )}\n//         <ErrorBoundary>\n//           <Suspense fallback={<LoadingPlaceholder />}>\n//             <ResonatorSimulation onStatusUpdate={setStatus} />\n//           </Suspense>\n//         </ErrorBoundary>\n//         <Controls />\n//       </Canvas>\n//       {/** Render overlay outside Canvas: battery & angular velocity bars plus a button */}\n//       <StatusOverlay\n//         status={status}\n//         internalLightActive={internalLightActive}\n//         setInternalLightActive={setInternalLightActive}\n//       />\n//     </>\n//   );\n// };\n\n// // --- Status Overlay Component ---\n// // Displays battery, angular velocity, and a button to toggle internal light.\n// // Additionally, the battery logic now uses threshold-modulation (see main simulation).\n// const StatusOverlay: React.FC<{\n//   status: { battery: number; angularVelocity: number };\n//   internalLightActive: boolean;\n//   setInternalLightActive: (active: boolean) => void;\n// }> = ({ status, internalLightActive, setInternalLightActive }) => {\n//   const batteryPercent = status.battery;\n//   const angularPercent = Math.min((status.angularVelocity / 10) * 100, 100);\n//   const overlayStyle: React.CSSProperties = {\n//     position: 'absolute',\n//     top: 20,\n//     left: 20,\n//     color: '#fff',\n//     fontFamily: 'sans-serif',\n//     zIndex: 10\n//   };\n//   const barContainer: React.CSSProperties = {\n//     width: '200px',\n//     height: '20px',\n//     background: '#555',\n//     borderRadius: '10px',\n//     overflow: 'hidden',\n//     marginBottom: '10px'\n//   };\n//   const buttonStyle: React.CSSProperties = {\n//     padding: '8px 16px',\n//     fontSize: '14px',\n//     borderRadius: '5px',\n//     cursor: 'pointer'\n//   };\n//   return (\n//     <div style={overlayStyle}>\n//       <div>\n//         <div>Battery: {batteryPercent.toFixed(0)}%</div>\n//         <div style={barContainer}>\n//           <div style={{ width: `${batteryPercent}%`, height: '100%', background: 'limegreen' }}></div>\n//         </div>\n//       </div>\n//       <div>\n//         <div>Angular Velocity: {status.angularVelocity.toFixed(2)}</div>\n//         <div style={barContainer}>\n//           <div style={{ width: `${angularPercent}%`, height: '100%', background: 'orange' }}></div>\n//         </div>\n//       </div>\n//       <div>\n//         <button style={buttonStyle} onClick={() => setInternalLightActive(!internalLightActive)}>\n//           {internalLightActive ? \"Turn Off Internal Light\" : \"Turn On Internal Light\"}\n//         </button>\n//       </div>\n//     </div>\n//   );\n// };\n\n// // --- Loading Placeholder Component ---\n// const LoadingPlaceholder: React.FC = () => {\n//   return (\n//     <mesh>\n//       <boxGeometry args={[0.1, 0.1, 0.1]} />\n//       <meshBasicMaterial color=\"orange\" wireframe attach=\"material\" />\n//     </mesh>\n//   );\n// };\n\n// export default TemporalResonatorScene;\n\n\n// // // === Full Code: TemporalResonatorScene_EnhancedWithEnergyOverlay.tsx ===\n\n// // import React, { useRef, useEffect, useMemo, Suspense, useState } from 'react';\n// // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // import * as THREE from 'three';\n// // import ErrorBoundary from './errorBoundary'; // Adjust path if needed\n// // import { useControls, Leva } from 'leva';\n// // import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\n// // import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n\n// // // --- BVH / CSG Setup ---\n// // try {\n// //   (THREE.BufferGeometry.prototype as any).computeBoundsTree = computeBoundsTree;\n// //   (THREE.BufferGeometry.prototype as any).disposeBoundsTree = disposeBoundsTree;\n// //   (THREE.Mesh.prototype as any).raycast = acceleratedRaycast;\n// // } catch (error) {\n// //   console.error(\"Error setting up BVH extensions:\", error);\n// // }\n\n// // const csgEvaluator = new Evaluator();\n// // csgEvaluator.useGroups = true;\n// // extend({ OrbitControls });\n\n// // // --- Constants ---\n// // const PHI = (1 + Math.sqrt(5)) / 2;\n// // const INV_PHI = 1 / PHI;\n\n// // // --- Face Drag Coefficients ---\n// // const FACE_DRAG_COEFFICIENTS = [\n// //   0.8, 1.0, 0.9, 1.1, 0.6, 1.2,\n// //   1.05, 0.75, 0.95, 1.3, 0.7, 1.15\n// // ];\n\n// // // Helper: Compute effective drag multiplier based on face normals and field direction.\n// // function computeEffectiveDrag(\n// //   quat: THREE.Quaternion,\n// //   magneticFieldDir: THREE.Vector3,\n// //   faceData: { normal: THREE.Vector3 }[]\n// // ) {\n// //   let dragSum = 0, weightSum = 0;\n// //   faceData.forEach((face, index) => {\n// //     const worldNormal = face.normal.clone().applyQuaternion(quat);\n// //     const alignment = Math.max(0, worldNormal.dot(magneticFieldDir));\n// //     dragSum += FACE_DRAG_COEFFICIENTS[index] * alignment;\n// //     weightSum += alignment;\n// //   });\n// //   return weightSum > 0 ? dragSum / weightSum : 1.0;\n// // }\n\n// // // Helper: Get Dodecahedron Data (vertices and face centers/normals)\n// // function getDodecahedronData(radius: number): {\n// //   vertices: THREE.Vector3[];\n// //   faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[];\n// // } {\n// //   console.log(`--- Calculating Dodecahedron Data for radius: ${radius} ---`);\n// //   if (typeof radius !== 'number' || radius <= 0 || !Number.isFinite(radius)) {\n// //     console.error(\"Invalid radius passed to getDodecahedronData:\", radius);\n// //     throw new Error(\"Invalid radius provided to getDodecahedronData\");\n// //   }\n// //   const uniqueVerticesMap = new Map<string, THREE.Vector3>();\n// //   const coords = [\n// //     [1, 1, 1], [-1, 1, 1], [1, -1, 1], [-1, -1, 1],\n// //     [1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1],\n// //     [0, PHI, INV_PHI], [0, -PHI, INV_PHI], [0, PHI, -INV_PHI], [0, -PHI, -INV_PHI],\n// //     [INV_PHI, 0, PHI], [-INV_PHI, 0, PHI], [INV_PHI, 0, -PHI], [-INV_PHI, 0, -PHI],\n// //     [PHI, INV_PHI, 0], [-PHI, INV_PHI, 0], [PHI, -INV_PHI, 0], [-PHI, -INV_PHI, 0]\n// //   ];\n// //   const distOriginToVertex = Math.sqrt(PHI * PHI + INV_PHI * INV_PHI);\n// //   const scale = radius / distOriginToVertex;\n// //   if (!Number.isFinite(scale) || scale === 0) throw new Error(\"Invalid scale factor\");\n// //   coords.forEach(v => {\n// //     const x = v[0] * scale, y = v[1] * scale, z = v[2] * scale;\n// //     const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`;\n// //     if (!uniqueVerticesMap.has(key)) uniqueVerticesMap.set(key, new THREE.Vector3(x, y, z));\n// //   });\n// //   const vertices = Array.from(uniqueVerticesMap.values());\n// //   const faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] = [];\n// //   const icoVerts = [\n// //     [0, 1, PHI], [0, -1, PHI], [0, 1, -PHI], [0, -1, -PHI],\n// //     [1, PHI, 0], [-1, PHI, 0], [1, -PHI, 0], [-1, -PHI, 0],\n// //     [PHI, 0, 1], [-PHI, 0, 1], [PHI, 0, -1], [-PHI, 0, -1]\n// //   ];\n// //   const faceCenterDist = radius * 1.53 / distOriginToVertex;\n// //   icoVerts.forEach(v => {\n// //     const normal = new THREE.Vector3(v[0], v[1], v[2]).normalize();\n// //     const center = normal.clone().multiplyScalar(faceCenterDist);\n// //     faceData.push({ center, normal });\n// //   });\n// //   if (vertices.length !== 20 || faceData.length !== 12) {\n// //     console.error(\"Vertex/Face generation failed.\", vertices, faceData);\n// //     throw new Error(`Incorrect data count: ${vertices.length} vertices, ${faceData.length} faces`);\n// //   }\n// //   console.log(`Generated ${vertices.length} vertices, ${faceData.length} faces.`);\n// //   return { vertices, faceData };\n// // }\n\n// // // --- Controls Component ---\n// // const Controls: React.FC = () => {\n// //   const { camera, gl } = useThree();\n// //   const controlsRef = useRef<OrbitControls>(null);\n// //   useEffect(() => {\n// //     const controls = new OrbitControls(camera, gl.domElement);\n// //     controls.enableDamping = true;\n// //     controls.target.set(0, 0, 0);\n// //     (controlsRef as React.MutableRefObject<OrbitControls>).current = controls;\n// //     return () => controls.dispose();\n// //   }, [camera, gl]);\n// //   useFrame(() => controlsRef.current?.update());\n// //   return null;\n// // };\n\n// // // --- Roman Dodecahedron CSG Component ---\n// // interface RomanDodecahedronProps {\n// //   outerRadius: number;\n// //   thickness: number;\n// //   holeBaseDiameter: number;\n// //   holeRatio: number;\n// //   noduleRadius: number;\n// //   material?: THREE.Material;\n// //   wireframe?: boolean;\n// //   [key: string]: any;\n// // }\n\n// // const RomanDodecahedron = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>(\n// //   ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, wireframe = false, ...props }, ref) => {\n// //     const [calculatedGeometry, setCalculatedGeometry] = useState<THREE.BufferGeometry | null>(null);\n// //     useEffect(() => {\n// //       console.log(`CSG Props: outerRadius=${outerRadius}, thickness=${thickness}, holeBaseDiameter=${holeBaseDiameter}, holeRatio=${holeRatio}, noduleRadius=${noduleRadius}`);\n// //       if (\n// //         typeof outerRadius !== 'number' || outerRadius <= 0 || !Number.isFinite(outerRadius) ||\n// //         typeof thickness !== 'number' || thickness <= 0 || !Number.isFinite(thickness) ||\n// //         typeof holeBaseDiameter !== 'number' || holeBaseDiameter <= 0 || !Number.isFinite(holeBaseDiameter) ||\n// //         typeof holeRatio !== 'number' || holeRatio <= 0 || !Number.isFinite(holeRatio) ||\n// //         typeof noduleRadius !== 'number' || noduleRadius <= 0 || !Number.isFinite(noduleRadius)\n// //       ) {\n// //         console.log(\"--> Skipping CSG: invalid props.\");\n// //         setCalculatedGeometry(null);\n// //         return;\n// //       }\n// //       const detailLevel = 1;\n// //       console.log(`Calculating CSG Geometry (Detail=${detailLevel}) for radius: ${outerRadius}`);\n// //       let geometry: THREE.BufferGeometry | null = null;\n// //       const tempGeoList: THREE.BufferGeometry[] = [];\n// //       try {\n// //         const { vertices: mathVertices, faceData: mathFaceData } = getDodecahedronData(outerRadius);\n// //         const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, detailLevel);\n// //         outerDodecGeo.computeBoundsTree();\n// //         tempGeoList.push(outerDodecGeo);\n// //         const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, detailLevel);\n// //         innerDodecGeo.computeBoundsTree();\n// //         tempGeoList.push(innerDodecGeo);\n// //         let outerBrush = new Brush(outerDodecGeo);\n// //         let innerBrush = new Brush(innerDodecGeo);\n// //         innerBrush.updateMatrixWorld();\n// //         let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n// //         const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * holeRatio ** i);\n// //         console.log(\"Hole Diameters:\", holeDiameters.map(d => d.toFixed(4)));\n// //         const cylinderHeight = thickness * 3.1;\n// //         const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16);\n// //         cylinderGeo.rotateX(Math.PI / 2);\n// //         cylinderGeo.computeBoundsTree();\n// //         tempGeoList.push(cylinderGeo);\n// //         const tempQuat = new THREE.Quaternion();\n// //         let holesSubtracted = 0;\n// //         mathFaceData.forEach((face, index) => {\n// //           const holeRadius = holeDiameters[index] / 2;\n// //           console.log(`Face ${index}: Radius=${holeRadius?.toFixed(4)}, Center=(${face.center.x.toFixed(2)},${face.center.y.toFixed(2)},${face.center.z.toFixed(2)}), Normal=(${face.normal.x.toFixed(2)},${face.normal.y.toFixed(2)},${face.normal.z.toFixed(2)})`);\n// //           if (!holeRadius || holeRadius <= 0 || !Number.isFinite(holeRadius)) {\n// //             console.warn(`--> Skipping Face ${index}`);\n// //             return;\n// //           }\n// //           const holeBrush = new Brush(cylinderGeo);\n// //           holeBrush.scale.set(holeRadius, holeRadius, 1);\n// //           tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), face.normal);\n// //           holeBrush.quaternion.copy(tempQuat);\n// //           holeBrush.position.copy(face.center);\n// //           holeBrush.updateMatrixWorld();\n// //           try {\n// //             shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION);\n// //             holesSubtracted++;\n// //             console.log(`--> Subtracted hole ${index}`);\n// //           } catch (evalError) {\n// //             console.error(`--> CSG subtraction FAILED for face ${index}:`, evalError);\n// //           }\n// //         });\n// //         console.log(`Total holes subtracted: ${holesSubtracted}`);\n// //         const noduleGeo = new THREE.SphereGeometry(noduleRadius, 6, 6);\n// //         noduleGeo.computeBoundsTree();\n// //         tempGeoList.push(noduleGeo);\n// //         mathVertices.forEach(vertexPos => {\n// //           const noduleBrush = new Brush(noduleGeo);\n// //           noduleBrush.position.copy(vertexPos);\n// //           noduleBrush.updateMatrixWorld();\n// //           shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION);\n// //         });\n// //         geometry = shellBrush.geometry;\n// //         geometry.computeVertexNormals();\n// //         geometry.center();\n// //         console.log(\"CSG Calculation Complete.\");\n// //       } catch (error) {\n// //         console.error(\"CSG Error:\", error);\n// //         geometry = null;\n// //       } finally {\n// //         tempGeoList.forEach(g => g.dispose());\n// //         console.log(`Disposed ${tempGeoList.length} temporary geometries.`);\n// //       }\n// //       setCalculatedGeometry(geometry);\n// //       return () => {\n// //         if (geometry && typeof geometry.dispose === 'function') {\n// //           geometry.dispose();\n// //           console.log(\"Disposed final CSG geometry on cleanup.\");\n// //         }\n// //       };\n// //     }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]);\n\n// //     const meshMaterial = useMemo(() => {\n// //       let baseMaterial: THREE.Material;\n// //       if (material instanceof THREE.Material) {\n// //         baseMaterial = material.clone();\n// //         baseMaterial.side = THREE.DoubleSide;\n// //       } else {\n// //         baseMaterial = new THREE.MeshPhongMaterial({\n// //           color: 0xb87333,\n// //           side: THREE.DoubleSide,\n// //           specular: 0x444444,\n// //           shininess: 40,\n// //           name: \"DefaultPhongCopper\"\n// //         });\n// //       }\n// //       if (\"wireframe\" in baseMaterial) {\n// //         (baseMaterial as any).wireframe = wireframe;\n// //       }\n// //       baseMaterial.side = THREE.DoubleSide;\n// //       return baseMaterial;\n// //     }, [material, wireframe]);\n\n// //     useEffect(() => {\n// //       return () => {\n// //         meshMaterial?.dispose();\n// //       };\n// //     }, [meshMaterial]);\n\n// //     if (!calculatedGeometry) return null;\n// //     return <mesh ref={ref} geometry={calculatedGeometry} material={meshMaterial} {...props} />;\n// //   }\n// // );\n\n// // // --- Physics State Interface ---\n// // interface PhysicsState {\n// //   angularVelocity: THREE.Vector3;\n// //   fieldAngle: number;\n// //   currentTorque: THREE.Vector3;\n// // }\n\n// // // --- Main Simulation Component ---\n// // // Accepts an onStatusUpdate prop to report battery and angular velocity status.\n// // interface ResonatorSimulationProps {\n// //   onStatusUpdate: (status: { battery: number; angularVelocity: number }) => void;\n// // }\n\n// // const ResonatorSimulation: React.FC<ResonatorSimulationProps> = ({ onStatusUpdate }) => {\n// //   const groupRef = useRef<THREE.Group>(null!);\n// //   const dodecahedronMeshRef = useRef<THREE.Mesh>(null!);\n// //   const particlesRef = useRef<THREE.Points>(null!);\n// //   const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n// //   // We'll store a boolean that indicates whether we're in \"charging\" mode\n// //   const chargingModeRef = useRef(false);\n\n\n// //   // Controls â€“ including fieldActive toggle.\n// //   const resonatorControls = useControls(\"Resonator Controls\", {\n// //     baseFieldSpeed: { value: 1.0, min: 0, max: 5, step: 0.1 },\n// //     fieldIntensity: { value: 1.0, min: 0.0, max: 5, step: 0.1 },\n// //     k_drag: { label: \"Induction Strength\", value: 0.5, min: 0, max: 2, step: 0.05 },\n// //     inertiaScale: { label: \"Inertia Scale\", value: 1.0, min: 0.1, max: 5, step: 0.1 },\n// //     damping: { value: 0.1, min: 0, max: 1, step: 0.01 },\n// //     spinUpRate: { value: 0.5, min: 0, max: 2, step: 0.1 },\n// //     velocityThreshold: { value: 1.5, min: 0, max: 10, step: 0.1 },\n// //     thresholdFeedbackFactor: { value: 1.0, min: 0, max: 5, step: 0.1 },\n// //     fieldActive: { value: true },\n// //     noduleAntifieldStrength: { value: 0.2, min: 0, max: 2, step: 0.05 }\n// //   });\n\n// //   const shellControls = useControls(\"Shell Geometry\", {\n// //     outerRadius: 1.0,\n// //     thickness: 0.05,\n// //     holeBaseDiameter: 0.1,\n// //     holeRatio: 1.2,\n// //     noduleRadius: 0.1\n// //   });\n\n// //   const vizControls = useControls(\"Visualization\", {\n// //     particleCount: { value: 1000, min: 100, max: 5000, step: 100 },\n// //     particleSize: { value: 0.05, min: 0.01, max: 0.2, step: 0.01 },\n// //     torusMajorRadius: { value: 1.5, min: 0.5, max: 5, step: 0.1 },\n// //     torusMinorRadius: { value: 0.5, min: 0.1, max: 2, step: 0.05 },\n// //     showParticles: true,\n// //     wireframe: false\n// //   });\n\n// //   const defaultShellParams = useMemo(() => ({\n// //     outerRadius: 1.0,\n// //     thickness: 0.05,\n// //     holeBaseDiameter: 0.1,\n// //     holeRatio: 1.2,\n// //     noduleRadius: 0.1\n// //   }), []);\n// //   const finalShellParams = useMemo(() => ({\n// //     outerRadius:\n// //       typeof shellControls.outerRadius === 'number' && Number.isFinite(shellControls.outerRadius)\n// //         ? shellControls.outerRadius : defaultShellParams.outerRadius,\n// //     thickness:\n// //       typeof shellControls.thickness === 'number' && Number.isFinite(shellControls.thickness)\n// //         ? shellControls.thickness : defaultShellParams.thickness,\n// //     holeBaseDiameter:\n// //       typeof shellControls.holeBaseDiameter === 'number' && Number.isFinite(shellControls.holeBaseDiameter)\n// //         ? shellControls.holeBaseDiameter : defaultShellParams.holeBaseDiameter,\n// //     holeRatio:\n// //       typeof shellControls.holeRatio === 'number' && Number.isFinite(shellControls.holeRatio)\n// //         ? shellControls.holeRatio : defaultShellParams.holeRatio,\n// //     noduleRadius:\n// //       typeof shellControls.noduleRadius === 'number' && Number.isFinite(shellControls.noduleRadius)\n// //         ? shellControls.noduleRadius : defaultShellParams.noduleRadius\n// //   }), [shellControls, defaultShellParams]);\n\n// //   const effectiveInertia = useMemo(() => {\n// //     return resonatorControls.inertiaScale *\n// //       ((finalShellParams.outerRadius ** 5 - (finalShellParams.outerRadius - finalShellParams.thickness) ** 5) /\n// //        finalShellParams.outerRadius ** 5);\n// //   }, [resonatorControls.inertiaScale, finalShellParams.outerRadius, finalShellParams.thickness]);\n\n// //   // --- Battery (energy) state (ref) ---\n// //   const batteryRef = useRef(100); // 0-100\n// //   const DRAIN_RATE = 10;\n// //   const RECHARGE_RATE = 5;\n\n// //   // --- Physics State (vector-based) ---\n// //   const physicsState = useRef<PhysicsState>({\n// //     angularVelocity: new THREE.Vector3(0, 0, 0),\n// //     fieldAngle: 0,\n// //     currentTorque: new THREE.Vector3(0, 0, 0)\n// //   });\n\n// //   // --- Particle Data ---\n// //   const particleData = useMemo(() => {\n// //     console.log(`Creating particle data for count: ${vizControls.particleCount}`);\n// //     try {\n// //       const data = [];\n// //       const positions = new Float32Array(vizControls.particleCount * 3);\n// //       for (let i = 0; i < vizControls.particleCount; i++) {\n// //         const u = Math.random() * Math.PI * 2;\n// //         const v = Math.random() * Math.PI * 2;\n// //         const R = vizControls.torusMajorRadius;\n// //         const r = vizControls.torusMinorRadius;\n// //         const randR = R + (Math.random() - 0.5) * 0.2 * r;\n// //         const randr = r * Math.sqrt(Math.random());\n// //         positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u);\n// //         positions[i * 3 + 1] = randr * Math.sin(v);\n// //         positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u);\n// //         data.push({ u, v, R, r: randr });\n// //       }\n// //       return { positions, data };\n// //     } catch (error) {\n// //       console.error(\"Error creating particle data:\", error);\n// //       return { positions: new Float32Array(0), data: [] };\n// //     }\n// //   }, [vizControls.particleCount, vizControls.torusMajorRadius, vizControls.torusMinorRadius]);\n\n// //   useEffect(() => {\n// //     if (particleGeoRef.current && particleData?.positions) {\n// //       const existingAttribute = particleGeoRef.current.getAttribute(\"position\") as THREE.BufferAttribute | undefined;\n// //       if (!existingAttribute || existingAttribute.array.length !== particleData.positions.length) {\n// //         particleGeoRef.current.setAttribute(\"position\", new THREE.BufferAttribute(particleData.positions, 3, false));\n// //         console.log(`Particle position attribute CREATED/REPLACED (Count: ${particleData.positions.length / 3}).`);\n// //       }\n// //       if (particleGeoRef.current.getAttribute(\"color\")) {\n// //         particleGeoRef.current.deleteAttribute(\"color\");\n// //         console.log(\"Removed old particle color attribute.\");\n// //       }\n// //     } else {\n// //       if (particleGeoRef.current?.getAttribute(\"position\")) {\n// //         particleGeoRef.current.deleteAttribute(\"position\");\n// //         console.log(\"Particle position attribute removed.\");\n// //       }\n// //     }\n// //   }, [particleData]);\n\n// //   // --- 3D Vector Physics Update with Energy and Nodule Antifield ---\n// //   useFrame((state, delta) => {\n    \n// //     const ps = physicsState.current;\n// //     const fieldActive = resonatorControls.fieldActive;\n// //     if (fieldActive && batteryRef.current > 0) {\n// //       ps.fieldAngle += resonatorControls.spinUpRate * delta;\n// //       batteryRef.current = Math.max(batteryRef.current - DRAIN_RATE * delta, 0);\n// //     } else {\n// //       batteryRef.current = Math.min(batteryRef.current + RECHARGE_RATE * delta, 100);\n// //     }\n// //     const magneticFieldDir = new THREE.Vector3(Math.cos(ps.fieldAngle), Math.sin(ps.fieldAngle), 0).normalize();\n// //     const desiredAngularVel = fieldActive ? magneticFieldDir.clone().multiplyScalar(resonatorControls.baseFieldSpeed) : new THREE.Vector3(0, 0, 0);\n// //     const error = desiredAngularVel.clone().sub(ps.angularVelocity);\n// //     const { faceData } = getDodecahedronData(finalShellParams.outerRadius);\n// //     const effectiveDragFactor = computeEffectiveDrag(groupRef.current.quaternion, magneticFieldDir, faceData);\n// //     const dragTorque = error.clone().multiplyScalar(effectiveDragFactor * resonatorControls.k_drag * resonatorControls.fieldIntensity);\n// //     const currentSpeed = ps.angularVelocity.length();\n// //     let feedbackTorque = new THREE.Vector3(0, 0, 0);\n// //     if (currentSpeed > resonatorControls.velocityThreshold) {\n// //       const overage = currentSpeed - resonatorControls.velocityThreshold;\n// //       feedbackTorque = ps.angularVelocity.clone().normalize().multiplyScalar(-resonatorControls.thresholdFeedbackFactor * overage);\n// //     }\n// //     let netTorque = dragTorque.add(feedbackTorque);\n// //     // --- Nodule Antifield Torque ---\n// //     let noduleTorque = new THREE.Vector3(0, 0, 0);\n// //     const nodulePositions = getDodecahedronData(finalShellParams.outerRadius).vertices;\n// //     nodulePositions.forEach(nodulePos => {\n// //       const worldPos = nodulePos.clone().applyQuaternion(groupRef.current.quaternion);\n// //       const contribution = worldPos.clone().cross(magneticFieldDir).multiplyScalar(resonatorControls.noduleAntifieldStrength);\n// //       noduleTorque.add(contribution);\n// //     });\n// //     netTorque.add(noduleTorque);\n// //     ps.currentTorque.copy(netTorque);\n// //     const angularAccel = netTorque.clone().divideScalar(effectiveInertia);\n// //     ps.angularVelocity.add(angularAccel.multiplyScalar(delta));\n// //     ps.angularVelocity.multiplyScalar(1 - resonatorControls.damping * delta);\n// //     const deltaAngle = ps.angularVelocity.length() * delta;\n// //     if (deltaAngle > 0) {\n// //       const rotationAxis = ps.angularVelocity.clone().normalize();\n// //       const deltaQuat = new THREE.Quaternion().setFromAxisAngle(rotationAxis, deltaAngle);\n// //       groupRef.current.quaternion.multiply(deltaQuat);\n// //     }\n// //     // Optional emissive update.\n// //     if (dodecahedronMeshRef.current) {\n// //       const currentMaterial = dodecahedronMeshRef.current.material;\n// //       if (currentMaterial instanceof THREE.MeshStandardMaterial || currentMaterial instanceof THREE.MeshPhysicalMaterial) {\n// //         if (currentMaterial.emissive) {\n// //           const maxTorqueEst = resonatorControls.k_drag * resonatorControls.fieldIntensity * (resonatorControls.baseFieldSpeed * 1.5 + 1);\n// //           const emissionStrength = Math.min(netTorque.length() / (maxTorqueEst + 0.01), 1.0);\n// //           currentMaterial.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5);\n// //         }\n// //       }\n// //     }\n// //     // Update particle positions.\n// //     if (\n// //       vizControls.showParticles &&\n// //       particleGeoRef.current?.attributes.position &&\n// //       particlesRef.current &&\n// //       particleData?.data\n// //     ) {\n// //       const positions = particleGeoRef.current.attributes.position.array as Float32Array;\n// //       const speed = resonatorControls.baseFieldSpeed * resonatorControls.fieldIntensity;\n// //       const pData = particleData.data;\n// //       if (pData && pData.length * 3 === positions.length) {\n// //         const pointsMat = particlesRef.current.material as THREE.PointsMaterial;\n// //         if (pointsMat) pointsMat.size = vizControls.particleSize * (1 + resonatorControls.fieldIntensity * 0.5);\n// //         for (let i = 0; i < pData.length; i++) {\n// //           const data = pData[i];\n// //           data.u += speed * delta;\n// //           const R = vizControls.torusMajorRadius;\n// //           const r = data.r;\n// //           const u = data.u;\n// //           const v = data.v;\n// //           const bufferIndex = i * 3;\n// //           positions[bufferIndex] = (R + r * Math.cos(v)) * Math.cos(u);\n// //           positions[bufferIndex + 1] = r * Math.sin(v);\n// //           positions[bufferIndex + 2] = (R + r * Math.cos(v)) * Math.sin(u);\n// //         }\n// //         particleGeoRef.current.attributes.position.needsUpdate = true;\n// //       } else {\n// //         console.warn(\"Mismatch in particle data/buffer length.\");\n// //       }\n// //     }\n// //     // Report status (battery and angular velocity magnitude) via callback.\n// //     onStatusUpdate({\n// //       battery: batteryRef.current,\n// //       angularVelocity: ps.angularVelocity.length()\n// //     });\n// //   });\n\n// //   return (\n// //     <group ref={groupRef}>\n// //       <RomanDodecahedron\n// //         ref={dodecahedronMeshRef}\n// //         outerRadius={finalShellParams.outerRadius}\n// //         thickness={finalShellParams.thickness}\n// //         holeBaseDiameter={finalShellParams.holeBaseDiameter}\n// //         holeRatio={finalShellParams.holeRatio}\n// //         noduleRadius={finalShellParams.noduleRadius}\n// //         wireframe={vizControls.wireframe}\n// //         castShadow\n// //         receiveShadow\n// //         position={[0, 0, 0]}\n// //         rotation={[0, 0, 0]}\n// //       />\n// //       {/* Internal pointLight is now controlled externally */}\n// //       {/** We do not render this light in the scene by default */}\n// //       {vizControls.showParticles && (\n// //         <points ref={particlesRef} name=\"FieldParticles\">\n// //           <bufferGeometry ref={particleGeoRef} />\n// //           <pointsMaterial\n// //             name=\"ParticleMaterial\"\n// //             color={0x00ffff}\n// //             size={vizControls.particleSize}\n// //             transparent\n// //             opacity={0.7}\n// //             blending={THREE.AdditiveBlending}\n// //             sizeAttenuation={false}\n// //             map={null}\n// //           />\n// //         </points>\n// //       )}\n// //     </group>\n// //   );\n// // };\n\n// // const TemporalResonatorScene: React.FC = () => {\n// //   // Lift status state outside Canvas.\n// //   const [status, setStatus] = useState({ battery: 100, angularVelocity: 0 });\n// //   // New state: toggle internal light (heating light)\n// //   const [internalLightActive, setInternalLightActive] = useState(false);\n// //   return (\n// //     <>\n// //       <Leva collapsed={false} titleBar={{ title: \"Controls\" }} />\n// //       <Canvas\n// //         style={{\n// //           position: \"absolute\",\n// //           top: 0,\n// //           left: 0,\n// //           width: \"100vw\",\n// //           height: \"100vh\",\n// //           background: \"#111122\",\n// //           zIndex: 0\n// //         }}\n// //         camera={{ position: [3, 3, 5], fov: 75 }}\n// //         gl={{ antialias: true }}\n// //         shadows\n// //       >\n// //         {/** Reduce ambient light so that the copper shell remains dark when internal light is off */}\n// //         <ambientLight intensity={0.0} />\n// //         <hemisphereLight groundColor={0x404040} intensity={0.3} />\n// //         <directionalLight\n// //           position={[5, 10, 7.5]}\n// //           intensity={0.8}\n// //           castShadow\n// //           shadow-mapSize-width={1024}\n// //           shadow-mapSize-height={1024}\n// //           shadow-camera-far={25}\n// //           shadow-camera-left={-10}\n// //           shadow-camera-right={10}\n// //           shadow-camera-top={10}\n// //           shadow-camera-bottom={-10}\n// //         />\n// //         {/** Internal light: only render when toggled on */}\n// //         {internalLightActive && (\n// //           <pointLight\n// //             intensity={0.5}\n// //             color={0xffddcc}\n// //             distance={3}\n// //             decay={1.5}\n// //             position={[0, 0, 0]}\n// //             name=\"InternalLight\"\n// //           />\n// //         )}\n// //         <ErrorBoundary>\n// //           <Suspense fallback={<LoadingPlaceholder />}>\n// //             <ResonatorSimulation onStatusUpdate={setStatus} />\n// //           </Suspense>\n// //         </ErrorBoundary>\n// //         <Controls />\n// //       </Canvas>\n// //       {/** StatusOverlay rendered outside the Canvas */}\n// //       <StatusOverlay status={status} internalLightActive={internalLightActive} setInternalLightActive={setInternalLightActive} />\n// //     </>\n// //   );\n// // };\n\n// // // --- Status Overlay Component ---\n// // // Renders battery and angular velocity bars and adds a button to toggle the internal light.\n// // const StatusOverlay: React.FC<{\n// //   status: { battery: number; angularVelocity: number };\n// //   internalLightActive: boolean;\n// //   setInternalLightActive: (active: boolean) => void;\n// // }> = ({ status, internalLightActive, setInternalLightActive }) => {\n// //   const batteryPercent = status.battery;\n// //   const angularPercent = Math.min((status.angularVelocity / 10) * 100, 100);\n// //   const overlayStyle: React.CSSProperties = {\n// //     position: 'absolute',\n// //     top: 20,\n// //     left: 20,\n// //     color: '#fff',\n// //     fontFamily: 'sans-serif',\n// //     zIndex: 10\n// //   };\n// //   const barContainer: React.CSSProperties = {\n// //     width: '200px',\n// //     height: '20px',\n// //     background: '#555',\n// //     borderRadius: '10px',\n// //     overflow: 'hidden',\n// //     marginBottom: '10px'\n// //   };\n// //   const buttonStyle: React.CSSProperties = {\n// //     padding: '8px 16px',\n// //     fontSize: '14px',\n// //     borderRadius: '5px',\n// //     cursor: 'pointer'\n// //   };\n// //   return (\n// //     <div style={overlayStyle}>\n// //       <div>\n// //         <div>Battery: {batteryPercent.toFixed(0)}%</div>\n// //         <div style={barContainer}>\n// //           <div style={{ width: `${batteryPercent}%`, height: '100%', background: 'limegreen' }}></div>\n// //         </div>\n// //       </div>\n// //       <div>\n// //         <div>Angular Velocity: {status.angularVelocity.toFixed(2)}</div>\n// //         <div style={barContainer}>\n// //           <div style={{ width: `${angularPercent}%`, height: '100%', background: 'orange' }}></div>\n// //         </div>\n// //       </div>\n// //       <div>\n// //         <button style={buttonStyle} onClick={() => setInternalLightActive(!internalLightActive)}>\n// //           {internalLightActive ? \"Turn Off Internal Light\" : \"Turn On Internal Light\"}\n// //         </button>\n// //       </div>\n// //     </div>\n// //   );\n// // };\n\n// // // --- Loading Placeholder Component ---\n// // const LoadingPlaceholder: React.FC = () => {\n// //   return (\n// //     <mesh>\n// //       <boxGeometry args={[0.1, 0.1, 0.1]} />\n// //       <meshBasicMaterial color=\"orange\" wireframe attach=\"material\" />\n// //     </mesh>\n// //   );\n// // };\n\n// // export default TemporalResonatorScene;\n\n\n\n// // // // === Full Code: TemporalResonatorScene_EnhancedWithEnergyOverlay.tsx ===\n\n// // // import React, { useRef, useEffect, useMemo, Suspense, useState } from 'react';\n// // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // import * as THREE from 'three';\n// // // import ErrorBoundary from './errorBoundary'; // Adjust path if needed\n// // // import { useControls, Leva } from 'leva';\n// // // import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\n// // // import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n\n// // // // --- BVH / CSG Setup ---\n// // // try {\n// // //   (THREE.BufferGeometry.prototype as any).computeBoundsTree = computeBoundsTree;\n// // //   (THREE.BufferGeometry.prototype as any).disposeBoundsTree = disposeBoundsTree;\n// // //   (THREE.Mesh.prototype as any).raycast = acceleratedRaycast;\n// // // } catch (error) {\n// // //   console.error(\"Error setting up BVH extensions:\", error);\n// // // }\n\n// // // const csgEvaluator = new Evaluator();\n// // // csgEvaluator.useGroups = true;\n// // // extend({ OrbitControls });\n\n// // // // --- Constants ---\n// // // const PHI = (1 + Math.sqrt(5)) / 2;\n// // // const INV_PHI = 1 / PHI;\n\n// // // // --- Face Drag Coefficients ---\n// // // const FACE_DRAG_COEFFICIENTS = [\n// // //   0.8, 1.0, 0.9, 1.1, 0.6, 1.2,\n// // //   1.05, 0.75, 0.95, 1.3, 0.7, 1.15\n// // // ];\n\n// // // // Helper: Compute effective drag multiplier based on face normals and field direction.\n// // // function computeEffectiveDrag(\n// // //   quat: THREE.Quaternion,\n// // //   magneticFieldDir: THREE.Vector3,\n// // //   faceData: { normal: THREE.Vector3 }[]\n// // // ) {\n// // //   let dragSum = 0, weightSum = 0;\n// // //   faceData.forEach((face, index) => {\n// // //     const worldNormal = face.normal.clone().applyQuaternion(quat);\n// // //     const alignment = Math.max(0, worldNormal.dot(magneticFieldDir));\n// // //     dragSum += FACE_DRAG_COEFFICIENTS[index] * alignment;\n// // //     weightSum += alignment;\n// // //   });\n// // //   return weightSum > 0 ? dragSum / weightSum : 1.0;\n// // // }\n\n// // // // Helper: Get Dodecahedron Data (vertices and face centers/normals)\n// // // function getDodecahedronData(radius: number): {\n// // //   vertices: THREE.Vector3[];\n// // //   faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[];\n// // // } {\n// // //   console.log(`--- Calculating Dodecahedron Data for radius: ${radius} ---`);\n// // //   if (typeof radius !== 'number' || radius <= 0 || !Number.isFinite(radius)) {\n// // //     console.error(\"Invalid radius passed to getDodecahedronData:\", radius);\n// // //     throw new Error(\"Invalid radius provided to getDodecahedronData\");\n// // //   }\n// // //   const uniqueVerticesMap = new Map<string, THREE.Vector3>();\n// // //   const coords = [\n// // //     [1, 1, 1], [-1, 1, 1], [1, -1, 1], [-1, -1, 1],\n// // //     [1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1],\n// // //     [0, PHI, INV_PHI], [0, -PHI, INV_PHI], [0, PHI, -INV_PHI], [0, -PHI, -INV_PHI],\n// // //     [INV_PHI, 0, PHI], [-INV_PHI, 0, PHI], [INV_PHI, 0, -PHI], [-INV_PHI, 0, -PHI],\n// // //     [PHI, INV_PHI, 0], [-PHI, INV_PHI, 0], [PHI, -INV_PHI, 0], [-PHI, -INV_PHI, 0]\n// // //   ];\n// // //   const distOriginToVertex = Math.sqrt(PHI * PHI + INV_PHI * INV_PHI);\n// // //   const scale = radius / distOriginToVertex;\n// // //   if (!Number.isFinite(scale) || scale === 0) throw new Error(\"Invalid scale factor\");\n// // //   coords.forEach(v => {\n// // //     const x = v[0] * scale, y = v[1] * scale, z = v[2] * scale;\n// // //     const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`;\n// // //     if (!uniqueVerticesMap.has(key)) uniqueVerticesMap.set(key, new THREE.Vector3(x, y, z));\n// // //   });\n// // //   const vertices = Array.from(uniqueVerticesMap.values());\n// // //   const faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] = [];\n// // //   const icoVerts = [\n// // //     [0, 1, PHI], [0, -1, PHI], [0, 1, -PHI], [0, -1, -PHI],\n// // //     [1, PHI, 0], [-1, PHI, 0], [1, -PHI, 0], [-1, -PHI, 0],\n// // //     [PHI, 0, 1], [-PHI, 0, 1], [PHI, 0, -1], [-PHI, 0, -1]\n// // //   ];\n// // //   const faceCenterDist = radius * 1.53 / distOriginToVertex;\n// // //   icoVerts.forEach(v => {\n// // //     const normal = new THREE.Vector3(v[0], v[1], v[2]).normalize();\n// // //     const center = normal.clone().multiplyScalar(faceCenterDist);\n// // //     faceData.push({ center, normal });\n// // //   });\n// // //   if (vertices.length !== 20 || faceData.length !== 12) {\n// // //     console.error(\"Vertex/Face generation failed.\", vertices, faceData);\n// // //     throw new Error(`Incorrect data count: ${vertices.length} vertices, ${faceData.length} faces`);\n// // //   }\n// // //   console.log(`Generated ${vertices.length} vertices, ${faceData.length} faces.`);\n// // //   return { vertices, faceData };\n// // // }\n\n// // // // --- Controls Component ---\n// // // const Controls: React.FC = () => {\n// // //   const { camera, gl } = useThree();\n// // //   const controlsRef = useRef<OrbitControls>(null);\n// // //   useEffect(() => {\n// // //     const controls = new OrbitControls(camera, gl.domElement);\n// // //     controls.enableDamping = true;\n// // //     controls.target.set(0, 0, 0);\n// // //     (controlsRef as React.MutableRefObject<OrbitControls>).current = controls;\n// // //     return () => controls.dispose();\n// // //   }, [camera, gl]);\n// // //   useFrame(() => controlsRef.current?.update());\n// // //   return null;\n// // // };\n\n// // // // --- Roman Dodecahedron CSG Component ---\n// // // interface RomanDodecahedronProps {\n// // //   outerRadius: number;\n// // //   thickness: number;\n// // //   holeBaseDiameter: number;\n// // //   holeRatio: number;\n// // //   noduleRadius: number;\n// // //   material?: THREE.Material;\n// // //   wireframe?: boolean;\n// // //   [key: string]: any;\n// // // }\n\n// // // const RomanDodecahedron = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>(\n// // //   ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, wireframe = false, ...props }, ref) => {\n// // //     const [calculatedGeometry, setCalculatedGeometry] = useState<THREE.BufferGeometry | null>(null);\n// // //     useEffect(() => {\n// // //       console.log(`CSG Props: outerRadius=${outerRadius}, thickness=${thickness}, holeBaseDiameter=${holeBaseDiameter}, holeRatio=${holeRatio}, noduleRadius=${noduleRadius}`);\n// // //       if (\n// // //         typeof outerRadius !== 'number' || outerRadius <= 0 || !Number.isFinite(outerRadius) ||\n// // //         typeof thickness !== 'number' || thickness <= 0 || !Number.isFinite(thickness) ||\n// // //         typeof holeBaseDiameter !== 'number' || holeBaseDiameter <= 0 || !Number.isFinite(holeBaseDiameter) ||\n// // //         typeof holeRatio !== 'number' || holeRatio <= 0 || !Number.isFinite(holeRatio) ||\n// // //         typeof noduleRadius !== 'number' || noduleRadius <= 0 || !Number.isFinite(noduleRadius)\n// // //       ) {\n// // //         console.log(\"--> Skipping CSG: invalid props.\");\n// // //         setCalculatedGeometry(null);\n// // //         return;\n// // //       }\n// // //       const detailLevel = 1;\n// // //       console.log(`Calculating CSG Geometry (Detail=${detailLevel}) for radius: ${outerRadius}`);\n// // //       let geometry: THREE.BufferGeometry | null = null;\n// // //       const tempGeoList: THREE.BufferGeometry[] = [];\n// // //       try {\n// // //         const { vertices: mathVertices, faceData: mathFaceData } = getDodecahedronData(outerRadius);\n// // //         const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, detailLevel);\n// // //         outerDodecGeo.computeBoundsTree();\n// // //         tempGeoList.push(outerDodecGeo);\n// // //         const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, detailLevel);\n// // //         innerDodecGeo.computeBoundsTree();\n// // //         tempGeoList.push(innerDodecGeo);\n// // //         let outerBrush = new Brush(outerDodecGeo);\n// // //         let innerBrush = new Brush(innerDodecGeo);\n// // //         innerBrush.updateMatrixWorld();\n// // //         let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n// // //         const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * holeRatio ** i);\n// // //         console.log(\"Hole Diameters:\", holeDiameters.map(d => d.toFixed(4)));\n// // //         const cylinderHeight = thickness * 3.1;\n// // //         const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16);\n// // //         cylinderGeo.rotateX(Math.PI / 2);\n// // //         cylinderGeo.computeBoundsTree();\n// // //         tempGeoList.push(cylinderGeo);\n// // //         const tempQuat = new THREE.Quaternion();\n// // //         let holesSubtracted = 0;\n// // //         mathFaceData.forEach((face, index) => {\n// // //           const holeRadius = holeDiameters[index] / 2;\n// // //           console.log(`Face ${index}: Radius=${holeRadius?.toFixed(4)}, Center=(${face.center.x.toFixed(2)},${face.center.y.toFixed(2)},${face.center.z.toFixed(2)}), Normal=(${face.normal.x.toFixed(2)},${face.normal.y.toFixed(2)},${face.normal.z.toFixed(2)})`);\n// // //           if (!holeRadius || holeRadius <= 0 || !Number.isFinite(holeRadius)) {\n// // //             console.warn(`--> Skipping Face ${index}`);\n// // //             return;\n// // //           }\n// // //           const holeBrush = new Brush(cylinderGeo);\n// // //           holeBrush.scale.set(holeRadius, holeRadius, 1);\n// // //           tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), face.normal);\n// // //           holeBrush.quaternion.copy(tempQuat);\n// // //           holeBrush.position.copy(face.center);\n// // //           holeBrush.updateMatrixWorld();\n// // //           try {\n// // //             shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION);\n// // //             holesSubtracted++;\n// // //             console.log(`--> Subtracted hole ${index}`);\n// // //           } catch (evalError) {\n// // //             console.error(`--> CSG subtraction FAILED for face ${index}:`, evalError);\n// // //           }\n// // //         });\n// // //         console.log(`Total holes subtracted: ${holesSubtracted}`);\n// // //         const noduleGeo = new THREE.SphereGeometry(noduleRadius, 6, 6);\n// // //         noduleGeo.computeBoundsTree();\n// // //         tempGeoList.push(noduleGeo);\n// // //         mathVertices.forEach(vertexPos => {\n// // //           const noduleBrush = new Brush(noduleGeo);\n// // //           noduleBrush.position.copy(vertexPos);\n// // //           noduleBrush.updateMatrixWorld();\n// // //           shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION);\n// // //         });\n// // //         geometry = shellBrush.geometry;\n// // //         geometry.computeVertexNormals();\n// // //         geometry.center();\n// // //         console.log(\"CSG Calculation Complete.\");\n// // //       } catch (error) {\n// // //         console.error(\"CSG Error:\", error);\n// // //         geometry = null;\n// // //       } finally {\n// // //         tempGeoList.forEach(g => g.dispose());\n// // //         console.log(`Disposed ${tempGeoList.length} temporary geometries.`);\n// // //       }\n// // //       setCalculatedGeometry(geometry);\n// // //       return () => {\n// // //         if (geometry && typeof geometry.dispose === 'function') {\n// // //           geometry.dispose();\n// // //           console.log(\"Disposed final CSG geometry on cleanup.\");\n// // //         }\n// // //       };\n// // //     }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]);\n\n// // //     const meshMaterial = useMemo(() => {\n// // //       let baseMaterial: THREE.Material;\n// // //       if (material instanceof THREE.Material) {\n// // //         baseMaterial = material.clone();\n// // //         baseMaterial.side = THREE.DoubleSide;\n// // //       } else {\n// // //         baseMaterial = new THREE.MeshPhongMaterial({\n// // //           color: 0xb87333,\n// // //           side: THREE.DoubleSide,\n// // //           specular: 0x444444,\n// // //           shininess: 40,\n// // //           name: \"DefaultPhongCopper\"\n// // //         });\n// // //       }\n// // //       if (\"wireframe\" in baseMaterial) {\n// // //         (baseMaterial as any).wireframe = wireframe;\n// // //       }\n// // //       baseMaterial.side = THREE.DoubleSide;\n// // //       return baseMaterial;\n// // //     }, [material, wireframe]);\n\n// // //     useEffect(() => {\n// // //       return () => {\n// // //         meshMaterial?.dispose();\n// // //       };\n// // //     }, [meshMaterial]);\n\n// // //     if (!calculatedGeometry) return null;\n// // //     return <mesh ref={ref} geometry={calculatedGeometry} material={meshMaterial} {...props} />;\n// // //   }\n// // // );\n\n// // // // --- Physics State Interface ---\n// // // interface PhysicsState {\n// // //   angularVelocity: THREE.Vector3;\n// // //   fieldAngle: number;\n// // //   currentTorque: THREE.Vector3;\n// // // }\n\n// // // // --- Main Simulation Component ---\n// // // // Accepts an onStatusUpdate prop to report battery and angular velocity status.\n// // // interface ResonatorSimulationProps {\n// // //   onStatusUpdate: (status: { battery: number; angularVelocity: number }) => void;\n// // // }\n\n// // // const ResonatorSimulation: React.FC<ResonatorSimulationProps> = ({ onStatusUpdate }) => {\n// // //   const groupRef = useRef<THREE.Group>(null!);\n// // //   const dodecahedronMeshRef = useRef<THREE.Mesh>(null!);\n// // //   const particlesRef = useRef<THREE.Points>(null!);\n// // //   const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // //   // Controls â€“ note new control \"fieldActive\" for start/stop and \"noduleAntifieldStrength\"\n// // //   const resonatorControls = useControls(\"Resonator Controls\", {\n// // //     baseFieldSpeed: { value: 1.0, min: 0, max: 5, step: 0.1 },\n// // //     fieldIntensity: { value: 1.0, min: 0.0, max: 5, step: 0.1 },\n// // //     k_drag: { label: \"Induction Strength\", value: 0.5, min: 0, max: 2, step: 0.05 },\n// // //     inertiaScale: { label: \"Inertia Scale\", value: 1.0, min: 0.1, max: 5, step: 0.1 },\n// // //     damping: { value: 0.1, min: 0, max: 1, step: 0.01 },\n// // //     spinUpRate: { value: 0.5, min: 0, max: 2, step: 0.1 },\n// // //     velocityThreshold: { value: 1.5, min: 0, max: 10, step: 0.1 },\n// // //     thresholdFeedbackFactor: { value: 1.0, min: 0, max: 5, step: 0.1 },\n// // //     fieldActive: { value: true },\n// // //     noduleAntifieldStrength: { value: 0.2, min: 0, max: 2, step: 0.05 }\n// // //   });\n\n// // //   const shellControls = useControls(\"Shell Geometry\", {\n// // //     outerRadius: 1.0,\n// // //     thickness: 0.05,\n// // //     holeBaseDiameter: 0.1,\n// // //     holeRatio: 1.2,\n// // //     noduleRadius: 0.1\n// // //   });\n\n// // //   const vizControls = useControls(\"Visualization\", {\n// // //     particleCount: { value: 1000, min: 100, max: 5000, step: 100 },\n// // //     particleSize: { value: 0.05, min: 0.01, max: 0.2, step: 0.01 },\n// // //     torusMajorRadius: { value: 1.5, min: 0.5, max: 5, step: 0.1 },\n// // //     torusMinorRadius: { value: 0.5, min: 0.1, max: 2, step: 0.05 },\n// // //     showParticles: true,\n// // //     wireframe: false\n// // //   });\n\n// // //   const defaultShellParams = useMemo(() => ({\n// // //     outerRadius: 1.0,\n// // //     thickness: 0.05,\n// // //     holeBaseDiameter: 0.1,\n// // //     holeRatio: 1.2,\n// // //     noduleRadius: 0.1\n// // //   }), []);\n// // //   const finalShellParams = useMemo(() => ({\n// // //     outerRadius:\n// // //       typeof shellControls.outerRadius === 'number' && Number.isFinite(shellControls.outerRadius)\n// // //         ? shellControls.outerRadius : defaultShellParams.outerRadius,\n// // //     thickness:\n// // //       typeof shellControls.thickness === 'number' && Number.isFinite(shellControls.thickness)\n// // //         ? shellControls.thickness : defaultShellParams.thickness,\n// // //     holeBaseDiameter:\n// // //       typeof shellControls.holeBaseDiameter === 'number' && Number.isFinite(shellControls.holeBaseDiameter)\n// // //         ? shellControls.holeBaseDiameter : defaultShellParams.holeBaseDiameter,\n// // //     holeRatio:\n// // //       typeof shellControls.holeRatio === 'number' && Number.isFinite(shellControls.holeRatio)\n// // //         ? shellControls.holeRatio : defaultShellParams.holeRatio,\n// // //     noduleRadius:\n// // //       typeof shellControls.noduleRadius === 'number' && Number.isFinite(shellControls.noduleRadius)\n// // //         ? shellControls.noduleRadius : defaultShellParams.noduleRadius\n// // //   }), [shellControls, defaultShellParams]);\n\n// // //   const effectiveInertia = useMemo(() => {\n// // //     return resonatorControls.inertiaScale *\n// // //       ((finalShellParams.outerRadius ** 5 - (finalShellParams.outerRadius - finalShellParams.thickness) ** 5) /\n// // //        finalShellParams.outerRadius ** 5);\n// // //   }, [resonatorControls.inertiaScale, finalShellParams.outerRadius, finalShellParams.thickness]);\n\n// // //   // --- Battery (energy) state (ref) ---\n// // //   const batteryRef = useRef(100); // 0-100\n// // //   const DRAIN_RATE = 10;\n// // //   const RECHARGE_RATE = 5;\n\n// // //   // --- Physics State (vector-based) ---\n// // //   const physicsState = useRef<PhysicsState>({\n// // //     angularVelocity: new THREE.Vector3(0, 0, 0),\n// // //     fieldAngle: 0,\n// // //     currentTorque: new THREE.Vector3(0, 0, 0)\n// // //   });\n\n// // //   // --- Particle Data ---\n// // //   const particleData = useMemo(() => {\n// // //     console.log(`Creating particle data for count: ${vizControls.particleCount}`);\n// // //     try {\n// // //       const data = [];\n// // //       const positions = new Float32Array(vizControls.particleCount * 3);\n// // //       for (let i = 0; i < vizControls.particleCount; i++) {\n// // //         const u = Math.random() * Math.PI * 2;\n// // //         const v = Math.random() * Math.PI * 2;\n// // //         const R = vizControls.torusMajorRadius;\n// // //         const r = vizControls.torusMinorRadius;\n// // //         const randR = R + (Math.random() - 0.5) * 0.2 * r;\n// // //         const randr = r * Math.sqrt(Math.random());\n// // //         positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u);\n// // //         positions[i * 3 + 1] = randr * Math.sin(v);\n// // //         positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u);\n// // //         data.push({ u, v, R, r: randr });\n// // //       }\n// // //       return { positions, data };\n// // //     } catch (error) {\n// // //       console.error(\"Error creating particle data:\", error);\n// // //       return { positions: new Float32Array(0), data: [] };\n// // //     }\n// // //   }, [vizControls.particleCount, vizControls.torusMajorRadius, vizControls.torusMinorRadius]);\n\n// // //   useEffect(() => {\n// // //     if (particleGeoRef.current && particleData?.positions) {\n// // //       const existingAttribute = particleGeoRef.current.getAttribute(\"position\") as THREE.BufferAttribute | undefined;\n// // //       if (!existingAttribute || existingAttribute.array.length !== particleData.positions.length) {\n// // //         particleGeoRef.current.setAttribute(\"position\", new THREE.BufferAttribute(particleData.positions, 3, false));\n// // //         console.log(`Particle position attribute CREATED/REPLACED (Count: ${particleData.positions.length / 3}).`);\n// // //       }\n// // //       if (particleGeoRef.current.getAttribute(\"color\")) {\n// // //         particleGeoRef.current.deleteAttribute(\"color\");\n// // //         console.log(\"Removed old particle color attribute.\");\n// // //       }\n// // //     } else {\n// // //       if (particleGeoRef.current?.getAttribute(\"position\")) {\n// // //         particleGeoRef.current.deleteAttribute(\"position\");\n// // //         console.log(\"Particle position attribute removed.\");\n// // //       }\n// // //     }\n// // //   }, [particleData]);\n\n// // //   // --- 3D Vector Physics Update with Energy and Nodule Antifield ---\n// // //   useFrame((state, delta) => {\n// // //     const ps = physicsState.current;\n// // //     const fieldActive = resonatorControls.fieldActive;\n// // //     if (fieldActive && batteryRef.current > 0) {\n// // //       ps.fieldAngle += resonatorControls.spinUpRate * delta;\n// // //       batteryRef.current = Math.max(batteryRef.current - DRAIN_RATE * delta, 0);\n// // //     } else {\n// // //       batteryRef.current = Math.min(batteryRef.current + RECHARGE_RATE * delta, 100);\n// // //     }\n// // //     const magneticFieldDir = new THREE.Vector3(Math.cos(ps.fieldAngle), Math.sin(ps.fieldAngle), 0).normalize();\n// // //     const desiredAngularVel = fieldActive ? magneticFieldDir.clone().multiplyScalar(resonatorControls.baseFieldSpeed) : new THREE.Vector3(0, 0, 0);\n// // //     const error = desiredAngularVel.clone().sub(ps.angularVelocity);\n// // //     const { faceData } = getDodecahedronData(finalShellParams.outerRadius);\n// // //     const effectiveDragFactor = computeEffectiveDrag(groupRef.current.quaternion, magneticFieldDir, faceData);\n// // //     const dragTorque = error.clone().multiplyScalar(effectiveDragFactor * resonatorControls.k_drag * resonatorControls.fieldIntensity);\n// // //     const currentSpeed = ps.angularVelocity.length();\n// // //     let feedbackTorque = new THREE.Vector3(0, 0, 0);\n// // //     if (currentSpeed > resonatorControls.velocityThreshold) {\n// // //       const overage = currentSpeed - resonatorControls.velocityThreshold;\n// // //       feedbackTorque = ps.angularVelocity.clone().normalize().multiplyScalar(-resonatorControls.thresholdFeedbackFactor * overage);\n// // //     }\n// // //     let netTorque = dragTorque.add(feedbackTorque);\n// // //     // --- Nodule Antifield Torque ---\n// // //     let noduleTorque = new THREE.Vector3(0, 0, 0);\n// // //     const nodulePositions = getDodecahedronData(finalShellParams.outerRadius).vertices;\n// // //     nodulePositions.forEach(nodulePos => {\n// // //       const worldPos = nodulePos.clone().applyQuaternion(groupRef.current.quaternion);\n// // //       const contribution = worldPos.clone().cross(magneticFieldDir).multiplyScalar(resonatorControls.noduleAntifieldStrength);\n// // //       noduleTorque.add(contribution);\n// // //     });\n// // //     netTorque.add(noduleTorque);\n// // //     ps.currentTorque.copy(netTorque);\n// // //     const angularAccel = netTorque.clone().divideScalar(effectiveInertia);\n// // //     ps.angularVelocity.add(angularAccel.multiplyScalar(delta));\n// // //     ps.angularVelocity.multiplyScalar(1 - resonatorControls.damping * delta);\n// // //     const deltaAngle = ps.angularVelocity.length() * delta;\n// // //     if (deltaAngle > 0) {\n// // //       const rotationAxis = ps.angularVelocity.clone().normalize();\n// // //       const deltaQuat = new THREE.Quaternion().setFromAxisAngle(rotationAxis, deltaAngle);\n// // //       groupRef.current.quaternion.multiply(deltaQuat);\n// // //     }\n// // //     // Optional emissive update.\n// // //     if (dodecahedronMeshRef.current) {\n// // //       const currentMaterial = dodecahedronMeshRef.current.material;\n// // //       if (currentMaterial instanceof THREE.MeshStandardMaterial || currentMaterial instanceof THREE.MeshPhysicalMaterial) {\n// // //         if (currentMaterial.emissive) {\n// // //           const maxTorqueEst = resonatorControls.k_drag * resonatorControls.fieldIntensity * (resonatorControls.baseFieldSpeed * 1.5 + 1);\n// // //           const emissionStrength = Math.min(netTorque.length() / (maxTorqueEst + 0.01), 1.0);\n// // //           currentMaterial.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5);\n// // //         }\n// // //       }\n// // //     }\n// // //     // Update particle positions.\n// // //     if (\n// // //       vizControls.showParticles &&\n// // //       particleGeoRef.current?.attributes.position &&\n// // //       particlesRef.current &&\n// // //       particleData?.data\n// // //     ) {\n// // //       const positions = particleGeoRef.current.attributes.position.array as Float32Array;\n// // //       const speed = resonatorControls.baseFieldSpeed * resonatorControls.fieldIntensity;\n// // //       const pData = particleData.data;\n// // //       if (pData && pData.length * 3 === positions.length) {\n// // //         const pointsMat = particlesRef.current.material as THREE.PointsMaterial;\n// // //         if (pointsMat) pointsMat.size = vizControls.particleSize * (1 + resonatorControls.fieldIntensity * 0.5);\n// // //         for (let i = 0; i < pData.length; i++) {\n// // //           const data = pData[i];\n// // //           data.u += speed * delta;\n// // //           const R = vizControls.torusMajorRadius;\n// // //           const r = data.r;\n// // //           const u = data.u;\n// // //           const v = data.v;\n// // //           const bufferIndex = i * 3;\n// // //           positions[bufferIndex] = (R + r * Math.cos(v)) * Math.cos(u);\n// // //           positions[bufferIndex + 1] = r * Math.sin(v);\n// // //           positions[bufferIndex + 2] = (R + r * Math.cos(v)) * Math.sin(u);\n// // //         }\n// // //         particleGeoRef.current.attributes.position.needsUpdate = true;\n// // //       } else {\n// // //         console.warn(\"Mismatch in particle data/buffer length.\");\n// // //       }\n// // //     }\n// // //     // Report status (battery and angular velocity magnitude) via callback.\n// // //     onStatusUpdate({\n// // //       battery: batteryRef.current,\n// // //       angularVelocity: ps.angularVelocity.length()\n// // //     });\n// // //   });\n\n// // //   return (\n// // //     <group ref={groupRef}>\n// // //       <RomanDodecahedron\n// // //         ref={dodecahedronMeshRef}\n// // //         outerRadius={finalShellParams.outerRadius}\n// // //         thickness={finalShellParams.thickness}\n// // //         holeBaseDiameter={finalShellParams.holeBaseDiameter}\n// // //         holeRatio={finalShellParams.holeRatio}\n// // //         noduleRadius={finalShellParams.noduleRadius}\n// // //         wireframe={vizControls.wireframe}\n// // //         castShadow\n// // //         receiveShadow\n// // //         position={[0, 0, 0]}\n// // //         rotation={[0, 0, 0]}\n// // //       />\n// // //       <pointLight intensity={0.5} color={0xffddcc} distance={3} decay={1.5} position={[0, 0, 0]} name=\"InternalLight\" />\n// // //       {vizControls.showParticles && (\n// // //         <points ref={particlesRef} name=\"FieldParticles\">\n// // //           <bufferGeometry ref={particleGeoRef} />\n// // //           <pointsMaterial\n// // //             name=\"ParticleMaterial\"\n// // //             color={0x00ffff}\n// // //             size={vizControls.particleSize}\n// // //             transparent\n// // //             opacity={0.7}\n// // //             blending={THREE.AdditiveBlending}\n// // //             sizeAttenuation={false}\n// // //             map={null}\n// // //           />\n// // //         </points>\n// // //       )}\n// // //     </group>\n// // //   );\n// // // };\n\n// // // const TemporalResonatorScene: React.FC = () => {\n// // //   // Lift status state outside Canvas.\n// // //   const [status, setStatus] = useState({ battery: 100, angularVelocity: 0 });\n// // //   return (\n// // //     <>\n// // //       <Leva collapsed={false} titleBar={{ title: \"Controls\" }} />\n// // //       <Canvas\n// // //         style={{\n// // //           position: \"absolute\",\n// // //           top: 0,\n// // //           left: 0,\n// // //           width: \"100vw\",\n// // //           height: \"100vh\",\n// // //           background: \"#111122\",\n// // //           zIndex: 0\n// // //         }}\n// // //         camera={{ position: [3, 3, 5], fov: 75 }}\n// // //         gl={{ antialias: true }}\n// // //         shadows\n// // //       >\n// // //         <ambientLight intensity={0.4} />\n// // //         <hemisphereLight groundColor={0x404040} intensity={0.8} />\n// // //         <directionalLight\n// // //           position={[5, 10, 7.5]}\n// // //           intensity={1.2}\n// // //           castShadow\n// // //           shadow-mapSize-width={1024}\n// // //           shadow-mapSize-height={1024}\n// // //           shadow-camera-far={25}\n// // //           shadow-camera-left={-10}\n// // //           shadow-camera-right={10}\n// // //           shadow-camera-top={10}\n// // //           shadow-camera-bottom={-10}\n// // //         />\n// // //         <ErrorBoundary>\n// // //           <Suspense fallback={<LoadingPlaceholder />}>\n// // //             <ResonatorSimulation onStatusUpdate={setStatus} />\n// // //           </Suspense>\n// // //         </ErrorBoundary>\n// // //         <Controls />\n// // //       </Canvas>\n// // //       {/* StatusOverlay is rendered outside the Canvas as standard HTML */}\n// // //       <StatusOverlay status={status} />\n// // //     </>\n// // //   );\n// // // };\n\n// // // // --- Status Overlay Component ---\n// // // const StatusOverlay: React.FC<{ status: { battery: number; angularVelocity: number } }> = ({ status }) => {\n// // //   const batteryPercent = status.battery;\n// // //   // Map angular velocity to percentage (assuming max ~10 for display)\n// // //   const angularPercent = Math.min((status.angularVelocity / 10) * 100, 100);\n// // //   const overlayStyle: React.CSSProperties = {\n// // //     position: 'absolute',\n// // //     top: 20,\n// // //     left: 20,\n// // //     color: '#fff',\n// // //     fontFamily: 'sans-serif',\n// // //     zIndex: 10\n// // //   };\n// // //   const barContainer: React.CSSProperties = {\n// // //     width: '200px',\n// // //     height: '20px',\n// // //     background: '#555',\n// // //     borderRadius: '10px',\n// // //     overflow: 'hidden',\n// // //     marginBottom: '10px'\n// // //   };\n// // //   return (\n// // //     <div style={overlayStyle}>\n// // //       <div>\n// // //         <div>Battery: {batteryPercent.toFixed(0)}%</div>\n// // //         <div style={barContainer}>\n// // //           <div style={{ width: `${batteryPercent}%`, height: '100%', background: 'limegreen' }}></div>\n// // //         </div>\n// // //       </div>\n// // //       <div>\n// // //         <div>Angular Velocity: {status.angularVelocity.toFixed(2)}</div>\n// // //         <div style={barContainer}>\n// // //           <div style={{ width: `${angularPercent}%`, height: '100%', background: 'orange' }}></div>\n// // //         </div>\n// // //       </div>\n// // //     </div>\n// // //   );\n// // // };\n\n// // // // --- Loading Placeholder Component ---\n// // // const LoadingPlaceholder: React.FC = () => {\n// // //   return (\n// // //     <mesh>\n// // //       <boxGeometry args={[0.1, 0.1, 0.1]} />\n// // //       <meshBasicMaterial color=\"orange\" wireframe attach=\"material\" />\n// // //     </mesh>\n// // //   );\n// // // };\n\n// // // export default TemporalResonatorScene;\n\n\n\n// // // // // === Full Code: TemporalResonatorScene_VectorizedWithNodules.tsx ===\n\n// // // // import React, { useRef, useEffect, useMemo, Suspense, useState } from 'react';\n// // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // import * as THREE from 'three';\n// // // // import ErrorBoundary from './errorBoundary'; // Adjust path if needed\n// // // // import { useControls, Leva } from 'leva';\n// // // // import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\n// // // // import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n\n// // // // // --- BVH / CSG Setup ---\n// // // // try {\n// // // //   (THREE.BufferGeometry.prototype as any).computeBoundsTree = computeBoundsTree;\n// // // //   (THREE.BufferGeometry.prototype as any).disposeBoundsTree = disposeBoundsTree;\n// // // //   (THREE.Mesh.prototype as any).raycast = acceleratedRaycast;\n// // // // } catch (error) {\n// // // //   console.error(\"Error setting up BVH extensions:\", error);\n// // // // }\n\n// // // // const csgEvaluator = new Evaluator();\n// // // // csgEvaluator.useGroups = true;\n// // // // extend({ OrbitControls });\n\n// // // // // --- Constants ---\n// // // // const PHI = (1 + Math.sqrt(5)) / 2;\n// // // // const INV_PHI = 1 / PHI;\n\n// // // // // --- Face Drag Coefficients ---\n// // // // // Twelve coefficients corresponding to the 12 faces (holes) of the dodecahedron.\n// // // // const FACE_DRAG_COEFFICIENTS = [\n// // // //   0.8, 1.0, 0.9, 1.1, 0.6, 1.2,\n// // // //   1.05, 0.75, 0.95, 1.3, 0.7, 1.15\n// // // // ];\n\n// // // // // Helper: Given an objectâ€™s quaternion and the dodecahedronâ€™s face normals (in object space),\n// // // // // compute an effective drag multiplier by weighting each faceâ€™s coefficient by its alignment\n// // // // // with the magnetic field direction.\n// // // // function computeEffectiveDrag(\n// // // //   quat: THREE.Quaternion,\n// // // //   magneticFieldDir: THREE.Vector3,\n// // // //   faceData: { normal: THREE.Vector3 }[]\n// // // // ) {\n// // // //   let dragSum = 0, weightSum = 0;\n// // // //   faceData.forEach((face, index) => {\n// // // //     const worldNormal = face.normal.clone().applyQuaternion(quat);\n// // // //     const alignment = Math.max(0, worldNormal.dot(magneticFieldDir));\n// // // //     dragSum += FACE_DRAG_COEFFICIENTS[index] * alignment;\n// // // //     weightSum += alignment;\n// // // //   });\n// // // //   return weightSum > 0 ? dragSum / weightSum : 1.0;\n// // // // }\n\n// // // // // --- Helper: Get Dodecahedron Math Data ---\n// // // // function getDodecahedronData(radius: number): {\n// // // //   vertices: THREE.Vector3[];\n// // // //   faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[];\n// // // // } {\n// // // //   console.log(`--- Calculating Dodecahedron Data for radius: ${radius} ---`);\n// // // //   if (typeof radius !== 'number' || radius <= 0 || !Number.isFinite(radius)) {\n// // // //     console.error(\"Invalid radius passed to getDodecahedronData:\", radius);\n// // // //     throw new Error(\"Invalid radius provided to getDodecahedronData\");\n// // // //   }\n// // // //   const uniqueVerticesMap = new Map<string, THREE.Vector3>();\n// // // //   const coords = [\n// // // //     [1, 1, 1], [-1, 1, 1], [1, -1, 1], [-1, -1, 1],\n// // // //     [1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1],\n// // // //     [0, PHI, INV_PHI], [0, -PHI, INV_PHI], [0, PHI, -INV_PHI], [0, -PHI, -INV_PHI],\n// // // //     [INV_PHI, 0, PHI], [-INV_PHI, 0, PHI], [INV_PHI, 0, -PHI], [-INV_PHI, 0, -PHI],\n// // // //     [PHI, INV_PHI, 0], [-PHI, INV_PHI, 0], [PHI, -INV_PHI, 0], [-PHI, -INV_PHI, 0]\n// // // //   ];\n// // // //   const distOriginToVertex = Math.sqrt(PHI * PHI + INV_PHI * INV_PHI);\n// // // //   const scale = radius / distOriginToVertex;\n// // // //   if (!Number.isFinite(scale) || scale === 0) throw new Error(\"Invalid scale factor\");\n// // // //   coords.forEach(v => {\n// // // //     const x = v[0] * scale, y = v[1] * scale, z = v[2] * scale;\n// // // //     const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`;\n// // // //     if (!uniqueVerticesMap.has(key)) uniqueVerticesMap.set(key, new THREE.Vector3(x, y, z));\n// // // //   });\n// // // //   const vertices = Array.from(uniqueVerticesMap.values());\n// // // //   const faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] = [];\n// // // //   const icoVerts = [\n// // // //     [0, 1, PHI], [0, -1, PHI], [0, 1, -PHI], [0, -1, -PHI],\n// // // //     [1, PHI, 0], [-1, PHI, 0], [1, -PHI, 0], [-1, -PHI, 0],\n// // // //     [PHI, 0, 1], [-PHI, 0, 1], [PHI, 0, -1], [-PHI, 0, -1]\n// // // //   ];\n// // // //   const faceCenterDist = radius * 1.53 / distOriginToVertex;\n// // // //   icoVerts.forEach(v => {\n// // // //     const normal = new THREE.Vector3(v[0], v[1], v[2]).normalize();\n// // // //     const center = normal.clone().multiplyScalar(faceCenterDist);\n// // // //     faceData.push({ center, normal });\n// // // //   });\n// // // //   if (vertices.length !== 20 || faceData.length !== 12) {\n// // // //     console.error(\"Vertex/Face generation failed.\", vertices, faceData);\n// // // //     throw new Error(`Incorrect data count: ${vertices.length} vertices, ${faceData.length} faces`);\n// // // //   }\n// // // //   console.log(`Generated ${vertices.length} vertices, ${faceData.length} faces.`);\n// // // //   return { vertices, faceData };\n// // // // }\n\n// // // // // --- Controls Component ---\n// // // // const Controls: React.FC = () => {\n// // // //   const { camera, gl } = useThree();\n// // // //   const controlsRef = useRef<OrbitControls>(null);\n// // // //   useEffect(() => {\n// // // //     const controls = new OrbitControls(camera, gl.domElement);\n// // // //     controls.enableDamping = true;\n// // // //     controls.target.set(0, 0, 0);\n// // // //     (controlsRef as React.MutableRefObject<OrbitControls>).current = controls;\n// // // //     return () => controls.dispose();\n// // // //   }, [camera, gl]);\n// // // //   useFrame(() => controlsRef.current?.update());\n// // // //   return null;\n// // // // };\n\n// // // // // --- Roman Dodecahedron CSG Component ---\n// // // // interface RomanDodecahedronProps {\n// // // //   outerRadius: number;\n// // // //   thickness: number;\n// // // //   holeBaseDiameter: number;\n// // // //   holeRatio: number;\n// // // //   noduleRadius: number;\n// // // //   material?: THREE.Material;\n// // // //   wireframe?: boolean;\n// // // //   [key: string]: any;\n// // // // }\n\n// // // // const RomanDodecahedron = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>(\n// // // //   ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, wireframe = false, ...props }, ref) => {\n// // // //     const [calculatedGeometry, setCalculatedGeometry] = useState<THREE.BufferGeometry | null>(null);\n// // // //     useEffect(() => {\n// // // //       console.log(`CSG Props: outerRadius=${outerRadius}, thickness=${thickness}, holeBaseDiameter=${holeBaseDiameter}, holeRatio=${holeRatio}, noduleRadius=${noduleRadius}`);\n// // // //       if (\n// // // //         typeof outerRadius !== 'number' || outerRadius <= 0 || !Number.isFinite(outerRadius) ||\n// // // //         typeof thickness !== 'number' || thickness <= 0 || !Number.isFinite(thickness) ||\n// // // //         typeof holeBaseDiameter !== 'number' || holeBaseDiameter <= 0 || !Number.isFinite(holeBaseDiameter) ||\n// // // //         typeof holeRatio !== 'number' || holeRatio <= 0 || !Number.isFinite(holeRatio) ||\n// // // //         typeof noduleRadius !== 'number' || noduleRadius <= 0 || !Number.isFinite(noduleRadius)\n// // // //       ) {\n// // // //         console.log(\"--> Skipping CSG: invalid props.\");\n// // // //         setCalculatedGeometry(null);\n// // // //         return;\n// // // //       }\n// // // //       const detailLevel = 1;\n// // // //       console.log(`Calculating CSG Geometry (Detail=${detailLevel}) for radius: ${outerRadius}`);\n// // // //       let geometry: THREE.BufferGeometry | null = null;\n// // // //       const tempGeoList: THREE.BufferGeometry[] = [];\n// // // //       try {\n// // // //         const { vertices: mathVertices, faceData: mathFaceData } = getDodecahedronData(outerRadius);\n// // // //         const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, detailLevel);\n// // // //         outerDodecGeo.computeBoundsTree();\n// // // //         tempGeoList.push(outerDodecGeo);\n// // // //         const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, detailLevel);\n// // // //         innerDodecGeo.computeBoundsTree();\n// // // //         tempGeoList.push(innerDodecGeo);\n// // // //         let outerBrush = new Brush(outerDodecGeo);\n// // // //         let innerBrush = new Brush(innerDodecGeo);\n// // // //         innerBrush.updateMatrixWorld();\n// // // //         let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n// // // //         const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * holeRatio ** i);\n// // // //         console.log(\"Hole Diameters:\", holeDiameters.map(d => d.toFixed(4)));\n// // // //         const cylinderHeight = thickness * 3.1;\n// // // //         const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16);\n// // // //         cylinderGeo.rotateX(Math.PI / 2);\n// // // //         cylinderGeo.computeBoundsTree();\n// // // //         tempGeoList.push(cylinderGeo);\n// // // //         const tempQuat = new THREE.Quaternion();\n// // // //         let holesSubtracted = 0;\n// // // //         mathFaceData.forEach((face, index) => {\n// // // //           const holeRadius = holeDiameters[index] / 2;\n// // // //           console.log(`Face ${index}: Radius=${holeRadius?.toFixed(4)}, Center=(${face.center.x.toFixed(2)},${face.center.y.toFixed(2)},${face.center.z.toFixed(2)}), Normal=(${face.normal.x.toFixed(2)},${face.normal.y.toFixed(2)},${face.normal.z.toFixed(2)})`);\n// // // //           if (!holeRadius || holeRadius <= 0 || !Number.isFinite(holeRadius)) {\n// // // //             console.warn(`--> Skipping Face ${index}`);\n// // // //             return;\n// // // //           }\n// // // //           const holeBrush = new Brush(cylinderGeo);\n// // // //           holeBrush.scale.set(holeRadius, holeRadius, 1);\n// // // //           tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), face.normal);\n// // // //           holeBrush.quaternion.copy(tempQuat);\n// // // //           holeBrush.position.copy(face.center);\n// // // //           holeBrush.updateMatrixWorld();\n// // // //           try {\n// // // //             shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION);\n// // // //             holesSubtracted++;\n// // // //             console.log(`--> Subtracted hole ${index}`);\n// // // //           } catch (evalError) {\n// // // //             console.error(`--> CSG subtraction FAILED for face ${index}:`, evalError);\n// // // //           }\n// // // //         });\n// // // //         console.log(`Total holes subtracted: ${holesSubtracted}`);\n// // // //         const noduleGeo = new THREE.SphereGeometry(noduleRadius, 6, 6);\n// // // //         noduleGeo.computeBoundsTree();\n// // // //         tempGeoList.push(noduleGeo);\n// // // //         mathVertices.forEach(vertexPos => {\n// // // //           const noduleBrush = new Brush(noduleGeo);\n// // // //           noduleBrush.position.copy(vertexPos);\n// // // //           noduleBrush.updateMatrixWorld();\n// // // //           shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION);\n// // // //         });\n// // // //         geometry = shellBrush.geometry;\n// // // //         geometry.computeVertexNormals();\n// // // //         geometry.center();\n// // // //         console.log(\"CSG Calculation Complete.\");\n// // // //       } catch (error) {\n// // // //         console.error(\"CSG Error:\", error);\n// // // //         geometry = null;\n// // // //       } finally {\n// // // //         tempGeoList.forEach(g => g.dispose());\n// // // //         console.log(`Disposed ${tempGeoList.length} temporary geometries.`);\n// // // //       }\n// // // //       setCalculatedGeometry(geometry);\n// // // //       return () => {\n// // // //         if (geometry && typeof geometry.dispose === 'function') {\n// // // //           geometry.dispose();\n// // // //           console.log(\"Disposed final CSG geometry on cleanup.\");\n// // // //         }\n// // // //       };\n// // // //     }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]);\n\n// // // //     const meshMaterial = useMemo(() => {\n// // // //       let baseMaterial: THREE.Material;\n// // // //       if (material instanceof THREE.Material) {\n// // // //         baseMaterial = material.clone();\n// // // //         baseMaterial.side = THREE.DoubleSide;\n// // // //       } else {\n// // // //         baseMaterial = new THREE.MeshPhongMaterial({\n// // // //           color: 0xb87333,\n// // // //           side: THREE.DoubleSide,\n// // // //           specular: 0x444444,\n// // // //           shininess: 40,\n// // // //           name: \"DefaultPhongCopper\"\n// // // //         });\n// // // //       }\n// // // //       if (\"wireframe\" in baseMaterial) {\n// // // //         (baseMaterial as any).wireframe = wireframe;\n// // // //       }\n// // // //       baseMaterial.side = THREE.DoubleSide;\n// // // //       return baseMaterial;\n// // // //     }, [material, wireframe]);\n\n// // // //     useEffect(() => {\n// // // //       return () => {\n// // // //         meshMaterial?.dispose();\n// // // //       };\n// // // //     }, [meshMaterial]);\n\n// // // //     if (!calculatedGeometry) return null;\n// // // //     return <mesh ref={ref} geometry={calculatedGeometry} material={meshMaterial} {...props} />;\n// // // //   }\n// // // // );\n\n// // // // // --- Physics State Interface ---\n// // // // // Now we store a full vector angular velocity and a fieldAngle to drive the magnetic field.\n// // // // interface PhysicsState {\n// // // //   angularVelocity: THREE.Vector3;\n// // // //   fieldAngle: number;\n// // // //   currentTorque: THREE.Vector3;\n// // // // }\n\n// // // // // --- Main Simulation Component ---\n// // // // const ResonatorSimulation: React.FC = () => {\n// // // //   const groupRef = useRef<THREE.Group>(null!);\n// // // //   const dodecahedronMeshRef = useRef<THREE.Mesh>(null!);\n// // // //   const particlesRef = useRef<THREE.Points>(null!);\n// // // //   const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // // //   // Controls â€“ note the new parameter noduleAntifieldStrength is added.\n// // // //   const resonatorControls = useControls(\"Resonator Controls\", {\n// // // //     baseFieldSpeed: { value: 1.0, min: 0, max: 5, step: 0.1 },\n// // // //     fieldIntensity: { value: 1.0, min: 0.0, max: 5, step: 0.1 },\n// // // //     k_drag: { label: \"Induction Strength\", value: 0.5, min: 0, max: 2, step: 0.05 },\n// // // //     inertiaScale: { label: \"Inertia Scale\", value: 1.0, min: 0.1, max: 5, step: 0.1 },\n// // // //     damping: { value: 0.1, min: 0, max: 1, step: 0.01 },\n// // // //     spinUpRate: { value: 0.5, min: 0, max: 2, step: 0.1 },\n// // // //     velocityThreshold: { value: 1.5, min: 0, max: 10, step: 0.1 },\n// // // //     thresholdFeedbackFactor: { value: 1.0, min: 0, max: 5, step: 0.1 },\n// // // //     // New parameter for the nodulesâ€™ antifield effect:\n// // // //     noduleAntifieldStrength: { value: 0.2, min: 0, max: 2, step: 0.05 }\n// // // //   });\n\n// // // //   const shellControls = useControls(\"Shell Geometry\", {\n// // // //     outerRadius: 1.0,\n// // // //     thickness: 0.05,\n// // // //     holeBaseDiameter: 0.1,\n// // // //     holeRatio: 1.2,\n// // // //     noduleRadius: 0.1\n// // // //   });\n\n// // // //   const vizControls = useControls(\"Visualization\", {\n// // // //     particleCount: { value: 1000, min: 100, max: 5000, step: 100 },\n// // // //     particleSize: { value: 0.05, min: 0.01, max: 0.2, step: 0.01 },\n// // // //     torusMajorRadius: { value: 1.5, min: 0.5, max: 5, step: 0.1 },\n// // // //     torusMinorRadius: { value: 0.5, min: 0.1, max: 2, step: 0.05 },\n// // // //     showParticles: true,\n// // // //     wireframe: false\n// // // //   });\n\n// // // //   const defaultShellParams = useMemo(() => ({\n// // // //     outerRadius: 1.0,\n// // // //     thickness: 0.05,\n// // // //     holeBaseDiameter: 0.1,\n// // // //     holeRatio: 1.2,\n// // // //     noduleRadius: 0.1\n// // // //   }), []);\n// // // //   const finalShellParams = useMemo(() => ({\n// // // //     outerRadius: (typeof shellControls.outerRadius === 'number' && Number.isFinite(shellControls.outerRadius))\n// // // //       ? shellControls.outerRadius : defaultShellParams.outerRadius,\n// // // //     thickness: (typeof shellControls.thickness === 'number' && Number.isFinite(shellControls.thickness))\n// // // //       ? shellControls.thickness : defaultShellParams.thickness,\n// // // //     holeBaseDiameter: (typeof shellControls.holeBaseDiameter === 'number' && Number.isFinite(shellControls.holeBaseDiameter))\n// // // //       ? shellControls.holeBaseDiameter : defaultShellParams.holeBaseDiameter,\n// // // //     holeRatio: (typeof shellControls.holeRatio === 'number' && Number.isFinite(shellControls.holeRatio))\n// // // //       ? shellControls.holeRatio : defaultShellParams.holeRatio,\n// // // //     noduleRadius: (typeof shellControls.noduleRadius === 'number' && Number.isFinite(shellControls.noduleRadius))\n// // // //       ? shellControls.noduleRadius : defaultShellParams.noduleRadius\n// // // //   }), [shellControls, defaultShellParams]);\n\n// // // //   const effectiveInertia = useMemo(() => {\n// // // //     return resonatorControls.inertiaScale *\n// // // //       ((finalShellParams.outerRadius ** 5 - (finalShellParams.outerRadius - finalShellParams.thickness) ** 5) /\n// // // //        finalShellParams.outerRadius ** 5);\n// // // //   }, [resonatorControls.inertiaScale, finalShellParams.outerRadius, finalShellParams.thickness]);\n\n// // // //   // New physics state: full vector angular velocity and field angle.\n// // // //   const physicsState = useRef<PhysicsState>({\n// // // //     angularVelocity: new THREE.Vector3(0, 0, 0),\n// // // //     fieldAngle: 0,\n// // // //     currentTorque: new THREE.Vector3(0, 0, 0)\n// // // //   });\n\n// // // //   // Particle Data (as before)\n// // // //   const particleData = useMemo(() => {\n// // // //     console.log(`Creating particle data for count: ${vizControls.particleCount}`);\n// // // //     try {\n// // // //       const data = [];\n// // // //       const positions = new Float32Array(vizControls.particleCount * 3);\n// // // //       for (let i = 0; i < vizControls.particleCount; i++) {\n// // // //         const u = Math.random() * Math.PI * 2;\n// // // //         const v = Math.random() * Math.PI * 2;\n// // // //         const R = vizControls.torusMajorRadius;\n// // // //         const r = vizControls.torusMinorRadius;\n// // // //         const randR = R + (Math.random() - 0.5) * 0.2 * r;\n// // // //         const randr = r * Math.sqrt(Math.random());\n// // // //         positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u);\n// // // //         positions[i * 3 + 1] = randr * Math.sin(v);\n// // // //         positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u);\n// // // //         data.push({ u, v, R, r: randr });\n// // // //       }\n// // // //       return { positions, data };\n// // // //     } catch (error) {\n// // // //       console.error(\"Error creating particle data:\", error);\n// // // //       return { positions: new Float32Array(0), data: [] };\n// // // //     }\n// // // //   }, [vizControls.particleCount, vizControls.torusMajorRadius, vizControls.torusMinorRadius]);\n\n// // // //   useEffect(() => {\n// // // //     if (particleGeoRef.current && particleData?.positions) {\n// // // //       const existingAttribute = particleGeoRef.current.getAttribute(\"position\") as THREE.BufferAttribute | undefined;\n// // // //       if (!existingAttribute || existingAttribute.array.length !== particleData.positions.length) {\n// // // //         particleGeoRef.current.setAttribute(\"position\", new THREE.BufferAttribute(particleData.positions, 3, false));\n// // // //         console.log(`Particle position attribute CREATED/REPLACED (Count: ${particleData.positions.length / 3}).`);\n// // // //       }\n// // // //       if (particleGeoRef.current.getAttribute(\"color\")) {\n// // // //         particleGeoRef.current.deleteAttribute(\"color\");\n// // // //         console.log(\"Removed old particle color attribute.\");\n// // // //       }\n// // // //     } else {\n// // // //       if (particleGeoRef.current?.getAttribute(\"position\")) {\n// // // //         particleGeoRef.current.deleteAttribute(\"position\");\n// // // //         console.log(\"Particle position attribute removed.\");\n// // // //       }\n// // // //     }\n// // // //   }, [particleData]);\n\n// // // //   // --- 3D Vector Physics Update with Nodule Antifield ---\n// // // //   useFrame((state, delta) => {\n// // // //     const ps = physicsState.current;\n\n// // // //     // 1) Update the magnetic field's angle (spin-up)\n// // // //     ps.fieldAngle += resonatorControls.spinUpRate * delta;\n// // // //     const magneticFieldDir = new THREE.Vector3(Math.cos(ps.fieldAngle), Math.sin(ps.fieldAngle), 0).normalize();\n// // // //     const desiredAngularVel = magneticFieldDir.clone().multiplyScalar(resonatorControls.baseFieldSpeed);\n\n// // // //     // 2) Compute error between desired and current angular velocity\n// // // //     const error = desiredAngularVel.clone().sub(ps.angularVelocity);\n\n// // // //     // 3) Get effective drag factor based on current shell orientation\n// // // //     const { faceData } = getDodecahedronData(finalShellParams.outerRadius);\n// // // //     const effectiveDragFactor = computeEffectiveDrag(groupRef.current.quaternion, magneticFieldDir, faceData);\n// // // //     const dragTorque = error.clone().multiplyScalar(effectiveDragFactor * resonatorControls.k_drag * resonatorControls.fieldIntensity);\n\n// // // //     // 4) Threshold feedback torque (if angular speed exceeds threshold)\n// // // //     const currentSpeed = ps.angularVelocity.length();\n// // // //     let feedbackTorque = new THREE.Vector3(0, 0, 0);\n// // // //     if (currentSpeed > resonatorControls.velocityThreshold) {\n// // // //       const overage = currentSpeed - resonatorControls.velocityThreshold;\n// // // //       feedbackTorque = ps.angularVelocity.clone().normalize().multiplyScalar(-resonatorControls.thresholdFeedbackFactor * overage);\n// // // //     }\n\n// // // //     // 5) Sum net torque from drag and threshold feedback\n// // // //     const netTorque = dragTorque.add(feedbackTorque);\n\n// // // //     // 6) --- NEW: Nodule Antifield Torque ---  \n// // // //     // Get the nodule positions (using vertices from dodecahedron data) and add their influence.\n// // // //     let noduleTorque = new THREE.Vector3(0, 0, 0);\n// // // //     const nodulePositions = getDodecahedronData(finalShellParams.outerRadius).vertices;\n// // // //     nodulePositions.forEach(nodulePos => {\n// // // //       const worldPos = nodulePos.clone().applyQuaternion(groupRef.current.quaternion);\n// // // //       // Compute torque contribution: cross product of worldPos and magnetic field direction\n// // // //       const contribution = worldPos.clone().cross(magneticFieldDir).multiplyScalar(resonatorControls.noduleAntifieldStrength);\n// // // //       noduleTorque.add(contribution);\n// // // //     });\n// // // //     netTorque.add(noduleTorque);\n// // // //     ps.currentTorque.copy(netTorque);\n\n// // // //     // 7) Compute angular acceleration (netTorque divided by inertia)\n// // // //     const angularAccel = netTorque.clone().divideScalar(effectiveInertia);\n// // // //     ps.angularVelocity.add(angularAccel.multiplyScalar(delta));\n\n// // // //     // 8) Apply damping\n// // // //     ps.angularVelocity.multiplyScalar(1 - resonatorControls.damping * delta);\n\n// // // //     // 9) Integrate angular velocity to update shell orientation using quaternions\n// // // //     const deltaAngle = ps.angularVelocity.length() * delta;\n// // // //     if (deltaAngle > 0) {\n// // // //       const rotationAxis = ps.angularVelocity.clone().normalize();\n// // // //       const deltaQuat = new THREE.Quaternion().setFromAxisAngle(rotationAxis, deltaAngle);\n// // // //       groupRef.current.quaternion.multiply(deltaQuat);\n// // // //     }\n\n// // // //     // --- Optional: Update emissive intensity ---\n// // // //     if (dodecahedronMeshRef.current) {\n// // // //       const currentMaterial = dodecahedronMeshRef.current.material;\n// // // //       if (currentMaterial instanceof THREE.MeshStandardMaterial || currentMaterial instanceof THREE.MeshPhysicalMaterial) {\n// // // //         if (currentMaterial.emissive) {\n// // // //           const maxTorqueEst = resonatorControls.k_drag * resonatorControls.fieldIntensity * (resonatorControls.baseFieldSpeed * 1.5 + 1);\n// // // //           const emissionStrength = Math.min(netTorque.length() / (maxTorqueEst + 0.01), 1.0);\n// // // //           currentMaterial.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5);\n// // // //         }\n// // // //       }\n// // // //     }\n\n// // // //     // --- Update Particle Swirl (as before) ---\n// // // //     if (\n// // // //       vizControls.showParticles &&\n// // // //       particleGeoRef.current?.attributes.position &&\n// // // //       particlesRef.current &&\n// // // //       particleData?.data\n// // // //     ) {\n// // // //       const positions = particleGeoRef.current.attributes.position.array as Float32Array;\n// // // //       const speed = resonatorControls.baseFieldSpeed * resonatorControls.fieldIntensity;\n// // // //       const pData = particleData.data;\n// // // //       if (pData && pData.length * 3 === positions.length) {\n// // // //         const pointsMat = particlesRef.current.material as THREE.PointsMaterial;\n// // // //         if (pointsMat) pointsMat.size = vizControls.particleSize * (1 + resonatorControls.fieldIntensity * 0.5);\n// // // //         for (let i = 0; i < pData.length; i++) {\n// // // //           const data = pData[i];\n// // // //           data.u += speed * delta;\n// // // //           const R = vizControls.torusMajorRadius;\n// // // //           const r = data.r;\n// // // //           const u = data.u;\n// // // //           const v = data.v;\n// // // //           const bufferIndex = i * 3;\n// // // //           positions[bufferIndex] = (R + r * Math.cos(v)) * Math.cos(u);\n// // // //           positions[bufferIndex + 1] = r * Math.sin(v);\n// // // //           positions[bufferIndex + 2] = (R + r * Math.cos(v)) * Math.sin(u);\n// // // //         }\n// // // //         particleGeoRef.current.attributes.position.needsUpdate = true;\n// // // //       } else {\n// // // //         console.warn(\"Mismatch in particle data/buffer length.\");\n// // // //       }\n// // // //     }\n// // // //   });\n\n// // // //   return (\n// // // //     <group ref={groupRef}>\n// // // //       <RomanDodecahedron\n// // // //         ref={dodecahedronMeshRef}\n// // // //         outerRadius={finalShellParams.outerRadius}\n// // // //         thickness={finalShellParams.thickness}\n// // // //         holeBaseDiameter={finalShellParams.holeBaseDiameter}\n// // // //         holeRatio={finalShellParams.holeRatio}\n// // // //         noduleRadius={finalShellParams.noduleRadius}\n// // // //         wireframe={vizControls.wireframe}\n// // // //         castShadow\n// // // //         receiveShadow\n// // // //         position={[0, 0, 0]}\n// // // //         rotation={[0, 0, 0]}\n// // // //       />\n// // // //       <pointLight intensity={0.5} color={0xffddcc} distance={3} decay={1.5} position={[0, 0, 0]} name=\"InternalLight\" />\n// // // //       {vizControls.showParticles && (\n// // // //         <points ref={particlesRef} name=\"FieldParticles\">\n// // // //           <bufferGeometry ref={particleGeoRef} />\n// // // //           <pointsMaterial\n// // // //             name=\"ParticleMaterial\"\n// // // //             color={0x00ffff}\n// // // //             size={vizControls.particleSize}\n// // // //             transparent\n// // // //             opacity={0.7}\n// // // //             blending={THREE.AdditiveBlending}\n// // // //             sizeAttenuation={false}\n// // // //             map={null}\n// // // //           />\n// // // //         </points>\n// // // //       )}\n// // // //     </group>\n// // // //   );\n// // // // };\n\n// // // // const TemporalResonatorScene: React.FC = () => {\n// // // //   return (\n// // // //     <>\n// // // //       <Leva collapsed={false} titleBar={{ title: \"Controls\" }} />\n// // // //       <Canvas\n// // // //         style={{\n// // // //           position: \"absolute\",\n// // // //           top: 0,\n// // // //           left: 0,\n// // // //           width: \"100vw\",\n// // // //           height: \"100vh\",\n// // // //           background: \"#111122\",\n// // // //           zIndex: 0\n// // // //         }}\n// // // //         camera={{ position: [3, 3, 5], fov: 75 }}\n// // // //         gl={{ antialias: true }}\n// // // //         shadows\n// // // //       >\n// // // //         <ambientLight intensity={0.4} />\n// // // //         <hemisphereLight groundColor={0x404040} intensity={0.8} />\n// // // //         <directionalLight\n// // // //           position={[5, 10, 7.5]}\n// // // //           intensity={1.2}\n// // // //           castShadow\n// // // //           shadow-mapSize-width={1024}\n// // // //           shadow-mapSize-height={1024}\n// // // //           shadow-camera-far={25}\n// // // //           shadow-camera-left={-10}\n// // // //           shadow-camera-right={10}\n// // // //           shadow-camera-top={10}\n// // // //           shadow-camera-bottom={-10}\n// // // //         />\n// // // //         <ErrorBoundary>\n// // // //           <Suspense fallback={<LoadingPlaceholder />}>\n// // // //             <ResonatorSimulation />\n// // // //           </Suspense>\n// // // //         </ErrorBoundary>\n// // // //         <Controls />\n// // // //       </Canvas>\n// // // //     </>\n// // // //   );\n// // // // };\n\n// // // // // Loading Placeholder Component\n// // // // const LoadingPlaceholder: React.FC = () => {\n// // // //   return (\n// // // //     <mesh>\n// // // //       <boxGeometry args={[0.1, 0.1, 0.1]} />\n// // // //       <meshBasicMaterial color=\"orange\" wireframe attach=\"material\" />\n// // // //     </mesh>\n// // // //   );\n// // // // };\n\n// // // // export default TemporalResonatorScene;\n\n\n// // // // // // === Full Code: TemporalResonatorScene_Vectorized.tsx ===\n\n// // // // // import React, { useRef, useEffect, useMemo, Suspense, useState } from 'react';\n// // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // import * as THREE from 'three';\n// // // // // import ErrorBoundary from './errorBoundary'; // Adjust path if needed\n// // // // // import { useControls, Leva } from 'leva';\n// // // // // import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\n// // // // // import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n\n// // // // // // --- BVH / CSG Setup ---\n// // // // // try {\n// // // // //   (THREE.BufferGeometry.prototype as any).computeBoundsTree = computeBoundsTree;\n// // // // //   (THREE.BufferGeometry.prototype as any).disposeBoundsTree = disposeBoundsTree;\n// // // // //   (THREE.Mesh.prototype as any).raycast = acceleratedRaycast;\n// // // // // } catch (error) {\n// // // // //   console.error(\"Error setting up BVH extensions:\", error);\n// // // // // }\n\n// // // // // const csgEvaluator = new Evaluator();\n// // // // // csgEvaluator.useGroups = true;\n// // // // // extend({ OrbitControls });\n\n// // // // // // --- Constants ---\n// // // // // const PHI = (1 + Math.sqrt(5)) / 2;\n// // // // // const INV_PHI = 1 / PHI;\n\n// // // // // // --- Face Drag Coefficients ---\n// // // // // // Twelve coefficients corresponding to the 12 faces (holes) of the dodecahedron.\n// // // // // // Adjust these to emphasize the effect of the holes.\n// // // // // const FACE_DRAG_COEFFICIENTS = [\n// // // // //   0.8, 1.0, 0.9, 1.1, 0.6, 1.2,\n// // // // //   1.05, 0.75, 0.95, 1.3, 0.7, 1.15\n// // // // // ];\n\n// // // // // // Helper: Given an objectâ€™s quaternion and the dodecahedronâ€™s face normals (in object space),\n// // // // // // compute an effective drag multiplier. We weight each faceâ€™s coefficient by how aligned it is\n// // // // // // with the magnetic field direction.\n// // // // // function computeEffectiveDrag(\n// // // // //   quat: THREE.Quaternion,\n// // // // //   magneticFieldDir: THREE.Vector3,\n// // // // //   faceData: { normal: THREE.Vector3 }[]\n// // // // // ) {\n// // // // //   let dragSum = 0, weightSum = 0;\n// // // // //   faceData.forEach((face, index) => {\n// // // // //     // Transform face normal from object to world space.\n// // // // //     const worldNormal = face.normal.clone().applyQuaternion(quat);\n// // // // //     // How much is this face â€œfacingâ€ the field?\n// // // // //     const alignment = Math.max(0, worldNormal.dot(magneticFieldDir));\n// // // // //     dragSum += FACE_DRAG_COEFFICIENTS[index] * alignment;\n// // // // //     weightSum += alignment;\n// // // // //   });\n// // // // //   return weightSum > 0 ? dragSum / weightSum : 1.0;\n// // // // // }\n\n// // // // // // --- Helper: Get Dodecahedron Math Data ---\n// // // // // function getDodecahedronData(radius: number): {\n// // // // //   vertices: THREE.Vector3[];\n// // // // //   faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[];\n// // // // // } {\n// // // // //   console.log(`--- Calculating Dodecahedron Data for radius: ${radius} ---`);\n// // // // //   if (typeof radius !== 'number' || radius <= 0 || !Number.isFinite(radius)) {\n// // // // //     console.error(\"Invalid radius passed to getDodecahedronData:\", radius);\n// // // // //     throw new Error(\"Invalid radius provided to getDodecahedronData\");\n// // // // //   }\n// // // // //   const uniqueVerticesMap = new Map<string, THREE.Vector3>();\n// // // // //   const coords = [\n// // // // //     [1, 1, 1], [-1, 1, 1], [1, -1, 1], [-1, -1, 1],\n// // // // //     [1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1],\n// // // // //     [0, PHI, INV_PHI], [0, -PHI, INV_PHI], [0, PHI, -INV_PHI], [0, -PHI, -INV_PHI],\n// // // // //     [INV_PHI, 0, PHI], [-INV_PHI, 0, PHI], [INV_PHI, 0, -PHI], [-INV_PHI, 0, -PHI],\n// // // // //     [PHI, INV_PHI, 0], [-PHI, INV_PHI, 0], [PHI, -INV_PHI, 0], [-PHI, -INV_PHI, 0]\n// // // // //   ];\n// // // // //   const distOriginToVertex = Math.sqrt(PHI * PHI + INV_PHI * INV_PHI);\n// // // // //   const scale = radius / distOriginToVertex;\n// // // // //   if (!Number.isFinite(scale) || scale === 0) throw new Error(\"Invalid scale factor\");\n// // // // //   coords.forEach(v => {\n// // // // //     const x = v[0] * scale, y = v[1] * scale, z = v[2] * scale;\n// // // // //     const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`;\n// // // // //     if (!uniqueVerticesMap.has(key)) uniqueVerticesMap.set(key, new THREE.Vector3(x, y, z));\n// // // // //   });\n// // // // //   const vertices = Array.from(uniqueVerticesMap.values());\n// // // // //   const faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] = [];\n// // // // //   const icoVerts = [\n// // // // //     [0, 1, PHI], [0, -1, PHI], [0, 1, -PHI], [0, -1, -PHI],\n// // // // //     [1, PHI, 0], [-1, PHI, 0], [1, -PHI, 0], [-1, -PHI, 0],\n// // // // //     [PHI, 0, 1], [-PHI, 0, 1], [PHI, 0, -1], [-PHI, 0, -1]\n// // // // //   ];\n// // // // //   const faceCenterDist = radius * 1.53 / distOriginToVertex;\n// // // // //   icoVerts.forEach(v => {\n// // // // //     const normal = new THREE.Vector3(v[0], v[1], v[2]).normalize();\n// // // // //     const center = normal.clone().multiplyScalar(faceCenterDist);\n// // // // //     faceData.push({ center, normal });\n// // // // //   });\n// // // // //   if (vertices.length !== 20 || faceData.length !== 12) {\n// // // // //     console.error(\"Vertex/Face generation failed.\", vertices, faceData);\n// // // // //     throw new Error(`Incorrect data count: ${vertices.length} vertices, ${faceData.length} faces`);\n// // // // //   }\n// // // // //   console.log(`Generated ${vertices.length} vertices, ${faceData.length} faces.`);\n// // // // //   return { vertices, faceData };\n// // // // // }\n\n// // // // // // --- Controls Component ---\n// // // // // const Controls: React.FC = () => {\n// // // // //   const { camera, gl } = useThree();\n// // // // //   const controlsRef = useRef<OrbitControls>(null);\n// // // // //   useEffect(() => {\n// // // // //     const controls = new OrbitControls(camera, gl.domElement);\n// // // // //     controls.enableDamping = true;\n// // // // //     controls.target.set(0, 0, 0);\n// // // // //     (controlsRef as React.MutableRefObject<OrbitControls>).current = controls;\n// // // // //     return () => controls.dispose();\n// // // // //   }, [camera, gl]);\n// // // // //   useFrame(() => controlsRef.current?.update());\n// // // // //   return null;\n// // // // // };\n\n// // // // // // --- Roman Dodecahedron CSG Component ---\n// // // // // interface RomanDodecahedronProps {\n// // // // //   outerRadius: number;\n// // // // //   thickness: number;\n// // // // //   holeBaseDiameter: number;\n// // // // //   holeRatio: number;\n// // // // //   noduleRadius: number;\n// // // // //   material?: THREE.Material;\n// // // // //   wireframe?: boolean;\n// // // // //   [key: string]: any;\n// // // // // }\n\n// // // // // const RomanDodecahedron = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>(\n// // // // //   ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, wireframe = false, ...props }, ref) => {\n// // // // //     const [calculatedGeometry, setCalculatedGeometry] = useState<THREE.BufferGeometry | null>(null);\n// // // // //     useEffect(() => {\n// // // // //       console.log(`CSG Props: outerRadius=${outerRadius}, thickness=${thickness}, holeBaseDiameter=${holeBaseDiameter}, holeRatio=${holeRatio}, noduleRadius=${noduleRadius}`);\n// // // // //       if (\n// // // // //         typeof outerRadius !== 'number' || outerRadius <= 0 || !Number.isFinite(outerRadius) ||\n// // // // //         typeof thickness !== 'number' || thickness <= 0 || !Number.isFinite(thickness) ||\n// // // // //         typeof holeBaseDiameter !== 'number' || holeBaseDiameter <= 0 || !Number.isFinite(holeBaseDiameter) ||\n// // // // //         typeof holeRatio !== 'number' || holeRatio <= 0 || !Number.isFinite(holeRatio) ||\n// // // // //         typeof noduleRadius !== 'number' || noduleRadius <= 0 || !Number.isFinite(noduleRadius)\n// // // // //       ) {\n// // // // //         console.log(\"--> Skipping CSG: invalid props.\");\n// // // // //         setCalculatedGeometry(null);\n// // // // //         return;\n// // // // //       }\n// // // // //       const detailLevel = 1;\n// // // // //       console.log(`Calculating CSG Geometry (Detail=${detailLevel}) for radius: ${outerRadius}`);\n// // // // //       let geometry: THREE.BufferGeometry | null = null;\n// // // // //       const tempGeoList: THREE.BufferGeometry[] = [];\n// // // // //       try {\n// // // // //         const { vertices: mathVertices, faceData: mathFaceData } = getDodecahedronData(outerRadius);\n// // // // //         const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, detailLevel);\n// // // // //         outerDodecGeo.computeBoundsTree();\n// // // // //         tempGeoList.push(outerDodecGeo);\n// // // // //         const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, detailLevel);\n// // // // //         innerDodecGeo.computeBoundsTree();\n// // // // //         tempGeoList.push(innerDodecGeo);\n// // // // //         let outerBrush = new Brush(outerDodecGeo);\n// // // // //         let innerBrush = new Brush(innerDodecGeo);\n// // // // //         innerBrush.updateMatrixWorld();\n// // // // //         let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n// // // // //         const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * holeRatio ** i);\n// // // // //         console.log(\"Hole Diameters:\", holeDiameters.map(d => d.toFixed(4)));\n// // // // //         const cylinderHeight = thickness * 3.1;\n// // // // //         const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16);\n// // // // //         cylinderGeo.rotateX(Math.PI / 2);\n// // // // //         cylinderGeo.computeBoundsTree();\n// // // // //         tempGeoList.push(cylinderGeo);\n// // // // //         const tempQuat = new THREE.Quaternion();\n// // // // //         let holesSubtracted = 0;\n// // // // //         mathFaceData.forEach((face, index) => {\n// // // // //           const holeRadius = holeDiameters[index] / 2;\n// // // // //           console.log(`Face ${index}: Radius=${holeRadius?.toFixed(4)}, Center=(${face.center.x.toFixed(2)},${face.center.y.toFixed(2)},${face.center.z.toFixed(2)}), Normal=(${face.normal.x.toFixed(2)},${face.normal.y.toFixed(2)},${face.normal.z.toFixed(2)})`);\n// // // // //           if (!holeRadius || holeRadius <= 0 || !Number.isFinite(holeRadius)) {\n// // // // //             console.warn(`--> Skipping Face ${index}`);\n// // // // //             return;\n// // // // //           }\n// // // // //           const holeBrush = new Brush(cylinderGeo);\n// // // // //           holeBrush.scale.set(holeRadius, holeRadius, 1);\n// // // // //           tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), face.normal);\n// // // // //           holeBrush.quaternion.copy(tempQuat);\n// // // // //           holeBrush.position.copy(face.center);\n// // // // //           holeBrush.updateMatrixWorld();\n// // // // //           try {\n// // // // //             shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION);\n// // // // //             holesSubtracted++;\n// // // // //             console.log(`--> Subtracted hole ${index}`);\n// // // // //           } catch (evalError) {\n// // // // //             console.error(`--> CSG subtraction FAILED for face ${index}:`, evalError);\n// // // // //           }\n// // // // //         });\n// // // // //         console.log(`Total holes subtracted: ${holesSubtracted}`);\n// // // // //         const noduleGeo = new THREE.SphereGeometry(noduleRadius, 6, 6);\n// // // // //         noduleGeo.computeBoundsTree();\n// // // // //         tempGeoList.push(noduleGeo);\n// // // // //         mathVertices.forEach(vertexPos => {\n// // // // //           const noduleBrush = new Brush(noduleGeo);\n// // // // //           noduleBrush.position.copy(vertexPos);\n// // // // //           noduleBrush.updateMatrixWorld();\n// // // // //           shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION);\n// // // // //         });\n// // // // //         geometry = shellBrush.geometry;\n// // // // //         geometry.computeVertexNormals();\n// // // // //         geometry.center();\n// // // // //         console.log(\"CSG Calculation Complete.\");\n// // // // //       } catch (error) {\n// // // // //         console.error(\"CSG Error:\", error);\n// // // // //         geometry = null;\n// // // // //       } finally {\n// // // // //         tempGeoList.forEach(g => g.dispose());\n// // // // //         console.log(`Disposed ${tempGeoList.length} temporary geometries.`);\n// // // // //       }\n// // // // //       setCalculatedGeometry(geometry);\n// // // // //       return () => {\n// // // // //         if (geometry && typeof geometry.dispose === 'function') {\n// // // // //           geometry.dispose();\n// // // // //           console.log(\"Disposed final CSG geometry on cleanup.\");\n// // // // //         }\n// // // // //       };\n// // // // //     }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]);\n\n// // // // //     const meshMaterial = useMemo(() => {\n// // // // //       let baseMaterial: THREE.Material;\n// // // // //       if (material instanceof THREE.Material) {\n// // // // //         baseMaterial = material.clone();\n// // // // //         baseMaterial.side = THREE.DoubleSide;\n// // // // //       } else {\n// // // // //         baseMaterial = new THREE.MeshPhongMaterial({\n// // // // //           color: 0xb87333,\n// // // // //           side: THREE.DoubleSide,\n// // // // //           specular: 0x444444,\n// // // // //           shininess: 40,\n// // // // //           name: \"DefaultPhongCopper\"\n// // // // //         });\n// // // // //       }\n// // // // //       if (\"wireframe\" in baseMaterial) {\n// // // // //         (baseMaterial as any).wireframe = wireframe;\n// // // // //       }\n// // // // //       baseMaterial.side = THREE.DoubleSide;\n// // // // //       return baseMaterial;\n// // // // //     }, [material, wireframe]);\n\n// // // // //     useEffect(() => {\n// // // // //       return () => {\n// // // // //         meshMaterial?.dispose();\n// // // // //       };\n// // // // //     }, [meshMaterial]);\n\n// // // // //     if (!calculatedGeometry) return null;\n// // // // //     return <mesh ref={ref} geometry={calculatedGeometry} material={meshMaterial} {...props} />;\n// // // // //   }\n// // // // // );\n\n// // // // // // --- Physics State Interface ---\n// // // // // // We now store a full angular velocity vector and a fieldAngle to drive the magnetic field.\n// // // // // interface PhysicsState {\n// // // // //   angularVelocity: THREE.Vector3;\n// // // // //   fieldAngle: number;\n// // // // //   currentTorque: THREE.Vector3;\n// // // // // }\n\n// // // // // // --- Main Simulation Component ---\n// // // // // const ResonatorSimulation: React.FC = () => {\n// // // // //   const groupRef = useRef<THREE.Group>(null!);\n// // // // //   const dodecahedronMeshRef = useRef<THREE.Mesh>(null!);\n// // // // //   const particlesRef = useRef<THREE.Points>(null!);\n// // // // //   const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // // // //   // Controls (note additional controls for spin-up and threshold feedback)\n// // // // //   const resonatorControls = useControls(\"Resonator Controls\", {\n// // // // //     baseFieldSpeed: { value: 1.0, min: 0, max: 5, step: 0.1 },\n// // // // //     fieldIntensity: { value: 1.0, min: 0.0, max: 5, step: 0.1 },\n// // // // //     k_drag: { label: \"Induction Strength\", value: 0.5, min: 0, max: 2, step: 0.05 },\n// // // // //     inertiaScale: { label: \"Inertia Scale\", value: 1.0, min: 0.1, max: 5, step: 0.1 },\n// // // // //     damping: { value: 0.1, min: 0, max: 1, step: 0.01 },\n// // // // //     // These parameters affect how strongly the field forces the shell to align.\n// // // // //     spinUpRate: { value: 0.5, min: 0, max: 2, step: 0.1 },\n// // // // //     velocityThreshold: { value: 1.5, min: 0, max: 10, step: 0.1 },\n// // // // //     thresholdFeedbackFactor: { value: 1.0, min: 0, max: 5, step: 0.1 }\n// // // // //   });\n\n// // // // //   const shellControls = useControls(\"Shell Geometry\", {\n// // // // //     outerRadius: 1.0,\n// // // // //     thickness: 0.05,\n// // // // //     holeBaseDiameter: 0.1,\n// // // // //     holeRatio: 1.2,\n// // // // //     noduleRadius: 0.1\n// // // // //   });\n\n// // // // //   const vizControls = useControls(\"Visualization\", {\n// // // // //     particleCount: { value: 1000, min: 100, max: 5000, step: 100 },\n// // // // //     particleSize: { value: 0.05, min: 0.01, max: 0.2, step: 0.01 },\n// // // // //     torusMajorRadius: { value: 1.5, min: 0.5, max: 5, step: 0.1 },\n// // // // //     torusMinorRadius: { value: 0.5, min: 0.1, max: 2, step: 0.05 },\n// // // // //     showParticles: true,\n// // // // //     wireframe: false\n// // // // //   });\n\n// // // // //   // Validate shell parameters\n// // // // //   const defaultShellParams = useMemo(() => ({\n// // // // //     outerRadius: 1.0,\n// // // // //     thickness: 0.05,\n// // // // //     holeBaseDiameter: 0.1,\n// // // // //     holeRatio: 1.2,\n// // // // //     noduleRadius: 0.1\n// // // // //   }), []);\n// // // // //   const finalShellParams = useMemo(() => ({\n// // // // //     outerRadius: (typeof shellControls.outerRadius === 'number' && Number.isFinite(shellControls.outerRadius))\n// // // // //       ? shellControls.outerRadius : defaultShellParams.outerRadius,\n// // // // //     thickness: (typeof shellControls.thickness === 'number' && Number.isFinite(shellControls.thickness))\n// // // // //       ? shellControls.thickness : defaultShellParams.thickness,\n// // // // //     holeBaseDiameter: (typeof shellControls.holeBaseDiameter === 'number' && Number.isFinite(shellControls.holeBaseDiameter))\n// // // // //       ? shellControls.holeBaseDiameter : defaultShellParams.holeBaseDiameter,\n// // // // //     holeRatio: (typeof shellControls.holeRatio === 'number' && Number.isFinite(shellControls.holeRatio))\n// // // // //       ? shellControls.holeRatio : defaultShellParams.holeRatio,\n// // // // //     noduleRadius: (typeof shellControls.noduleRadius === 'number' && Number.isFinite(shellControls.noduleRadius))\n// // // // //       ? shellControls.noduleRadius : defaultShellParams.noduleRadius\n// // // // //   }), [shellControls, defaultShellParams]);\n\n// // // // //   const effectiveInertia = useMemo(() => {\n// // // // //     return resonatorControls.inertiaScale *\n// // // // //       ((finalShellParams.outerRadius ** 5 - (finalShellParams.outerRadius - finalShellParams.thickness) ** 5) /\n// // // // //        finalShellParams.outerRadius ** 5);\n// // // // //   }, [resonatorControls.inertiaScale, finalShellParams.outerRadius, finalShellParams.thickness]);\n\n// // // // //   // --- New Physics State: full vector angular velocity and field angle ---\n// // // // //   const physicsState = useRef<PhysicsState>({\n// // // // //     angularVelocity: new THREE.Vector3(0, 0, 0),\n// // // // //     fieldAngle: 0,\n// // // // //     currentTorque: new THREE.Vector3(0, 0, 0)\n// // // // //   });\n\n// // // // //   // Particle Data (remains as before)\n// // // // //   const particleData = useMemo(() => {\n// // // // //     console.log(`Creating particle data for count: ${vizControls.particleCount}`);\n// // // // //     try {\n// // // // //       const data = [];\n// // // // //       const positions = new Float32Array(vizControls.particleCount * 3);\n// // // // //       for (let i = 0; i < vizControls.particleCount; i++) {\n// // // // //         const u = Math.random() * Math.PI * 2;\n// // // // //         const v = Math.random() * Math.PI * 2;\n// // // // //         const R = vizControls.torusMajorRadius;\n// // // // //         const r = vizControls.torusMinorRadius;\n// // // // //         const randR = R + (Math.random() - 0.5) * 0.2 * r;\n// // // // //         const randr = r * Math.sqrt(Math.random());\n// // // // //         positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u);\n// // // // //         positions[i * 3 + 1] = randr * Math.sin(v);\n// // // // //         positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u);\n// // // // //         data.push({ u, v, R, r: randr });\n// // // // //       }\n// // // // //       return { positions, data };\n// // // // //     } catch (error) {\n// // // // //       console.error(\"Error creating particle data:\", error);\n// // // // //       return { positions: new Float32Array(0), data: [] };\n// // // // //     }\n// // // // //   }, [vizControls.particleCount, vizControls.torusMajorRadius, vizControls.torusMinorRadius]);\n\n// // // // //   useEffect(() => {\n// // // // //     if (particleGeoRef.current && particleData?.positions) {\n// // // // //       const existingAttribute = particleGeoRef.current.getAttribute(\"position\") as THREE.BufferAttribute | undefined;\n// // // // //       if (!existingAttribute || existingAttribute.array.length !== particleData.positions.length) {\n// // // // //         particleGeoRef.current.setAttribute(\"position\", new THREE.BufferAttribute(particleData.positions, 3, false));\n// // // // //         console.log(`Particle position attribute CREATED/REPLACED (Count: ${particleData.positions.length / 3}).`);\n// // // // //       }\n// // // // //       if (particleGeoRef.current.getAttribute(\"color\")) {\n// // // // //         particleGeoRef.current.deleteAttribute(\"color\");\n// // // // //         console.log(\"Removed old particle color attribute.\");\n// // // // //       }\n// // // // //     } else {\n// // // // //       if (particleGeoRef.current?.getAttribute(\"position\")) {\n// // // // //         particleGeoRef.current.deleteAttribute(\"position\");\n// // // // //         console.log(\"Particle position attribute removed.\");\n// // // // //       }\n// // // // //     }\n// // // // //   }, [particleData]);\n\n// // // // //   // --- New 3D Vector Physics Update ---\n// // // // //   useFrame((state, delta) => {\n// // // // //     const ps = physicsState.current;\n\n// // // // //     // 1) Update the magnetic field's angle (spin-up)\n// // // // //     ps.fieldAngle += resonatorControls.spinUpRate * delta;\n// // // // //     // Magnetic field direction in XY plane:\n// // // // //     const magneticFieldDir = new THREE.Vector3(Math.cos(ps.fieldAngle), Math.sin(ps.fieldAngle), 0).normalize();\n// // // // //     const desiredAngularVel = magneticFieldDir.clone().multiplyScalar(resonatorControls.baseFieldSpeed);\n\n// // // // //     // 2) Compute the error between desired and current angular velocity (vector)\n// // // // //     const error = desiredAngularVel.clone().sub(ps.angularVelocity);\n\n// // // // //     // 3) Get effective drag factor based on current shell orientation\n// // // // //     // First, get the face data (using our dodecahedron math data)\n// // // // //     const { faceData } = getDodecahedronData(finalShellParams.outerRadius);\n// // // // //     const effectiveDragFactor = computeEffectiveDrag(groupRef.current.quaternion, magneticFieldDir, faceData);\n// // // // //     // Torque from inductive drag:\n// // // // //     const dragTorque = error.multiplyScalar(effectiveDragFactor * resonatorControls.k_drag * resonatorControls.fieldIntensity);\n\n// // // // //     // 4) Threshold feedback: if the angular speed exceeds threshold, subtract a torque in the opposite direction.\n// // // // //     const currentSpeed = ps.angularVelocity.length();\n// // // // //     let feedbackTorque = new THREE.Vector3(0, 0, 0);\n// // // // //     if (currentSpeed > resonatorControls.velocityThreshold) {\n// // // // //       const overage = currentSpeed - resonatorControls.velocityThreshold;\n// // // // //       feedbackTorque = ps.angularVelocity.clone().normalize().multiplyScalar(-resonatorControls.thresholdFeedbackFactor * overage);\n// // // // //     }\n\n// // // // //     // 5) Sum torques to get net torque (vector)\n// // // // //     const netTorque = dragTorque.add(feedbackTorque);\n// // // // //     ps.currentTorque.copy(netTorque);\n\n// // // // //     // 6) Compute angular acceleration (vector) = netTorque / inertia\n// // // // //     const angularAccel = netTorque.clone().divideScalar(effectiveInertia);\n// // // // //     // 7) Update angular velocity vector\n// // // // //     ps.angularVelocity.add(angularAccel.multiplyScalar(delta));\n// // // // //     // 8) Apply damping\n// // // // //     ps.angularVelocity.multiplyScalar(1 - resonatorControls.damping * delta);\n\n// // // // //     // 9) Integrate the angular velocity to update the shell's orientation (using quaternions)\n// // // // //     const deltaAngle = ps.angularVelocity.length() * delta;\n// // // // //     if (deltaAngle > 0) {\n// // // // //       const rotationAxis = ps.angularVelocity.clone().normalize();\n// // // // //       const deltaQuat = new THREE.Quaternion().setFromAxisAngle(rotationAxis, deltaAngle);\n// // // // //       groupRef.current.quaternion.multiply(deltaQuat);\n// // // // //     }\n\n// // // // //     // --- Optional: Update emissive intensity on the shell's material ---\n// // // // //     if (dodecahedronMeshRef.current) {\n// // // // //       const currentMaterial = dodecahedronMeshRef.current.material;\n// // // // //       if (currentMaterial instanceof THREE.MeshStandardMaterial || currentMaterial instanceof THREE.MeshPhysicalMaterial) {\n// // // // //         if (currentMaterial.emissive) {\n// // // // //           const maxTorqueEst = resonatorControls.k_drag * resonatorControls.fieldIntensity * (resonatorControls.baseFieldSpeed * 1.5 + 1);\n// // // // //           const emissionStrength = Math.min(netTorque.length() / (maxTorqueEst + 0.01), 1.0);\n// // // // //           currentMaterial.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5);\n// // // // //         }\n// // // // //       }\n// // // // //     }\n\n// // // // //     // --- Update Particle Swirl (as before) ---\n// // // // //     if (\n// // // // //       vizControls.showParticles &&\n// // // // //       particleGeoRef.current?.attributes.position &&\n// // // // //       particlesRef.current &&\n// // // // //       particleData?.data\n// // // // //     ) {\n// // // // //       const positions = particleGeoRef.current.attributes.position.array as Float32Array;\n// // // // //       // Use the desired field speed for particle swirl\n// // // // //       const speed = resonatorControls.baseFieldSpeed * resonatorControls.fieldIntensity;\n// // // // //       const pData = particleData.data;\n// // // // //       if (pData && pData.length * 3 === positions.length) {\n// // // // //         const pointsMat = particlesRef.current.material as THREE.PointsMaterial;\n// // // // //         if (pointsMat) pointsMat.size = vizControls.particleSize * (1 + resonatorControls.fieldIntensity * 0.5);\n// // // // //         for (let i = 0; i < pData.length; i++) {\n// // // // //           const data = pData[i];\n// // // // //           data.u += speed * delta;\n// // // // //           const R = vizControls.torusMajorRadius;\n// // // // //           const r = data.r;\n// // // // //           const u = data.u;\n// // // // //           const v = data.v;\n// // // // //           const bufferIndex = i * 3;\n// // // // //           positions[bufferIndex] = (R + r * Math.cos(v)) * Math.cos(u);\n// // // // //           positions[bufferIndex + 1] = r * Math.sin(v);\n// // // // //           positions[bufferIndex + 2] = (R + r * Math.cos(v)) * Math.sin(u);\n// // // // //         }\n// // // // //         particleGeoRef.current.attributes.position.needsUpdate = true;\n// // // // //       } else {\n// // // // //         console.warn(\"Mismatch in particle data/buffer length.\");\n// // // // //       }\n// // // // //     }\n// // // // //   });\n\n// // // // //   return (\n// // // // //     <group ref={groupRef}>\n// // // // //       <RomanDodecahedron\n// // // // //         ref={dodecahedronMeshRef}\n// // // // //         outerRadius={finalShellParams.outerRadius}\n// // // // //         thickness={finalShellParams.thickness}\n// // // // //         holeBaseDiameter={finalShellParams.holeBaseDiameter}\n// // // // //         holeRatio={finalShellParams.holeRatio}\n// // // // //         noduleRadius={finalShellParams.noduleRadius}\n// // // // //         wireframe={vizControls.wireframe}\n// // // // //         castShadow\n// // // // //         receiveShadow\n// // // // //         position={[0, 0, 0]}\n// // // // //         rotation={[0, 0, 0]}\n// // // // //       />\n// // // // //       <pointLight intensity={0.5} color={0xffddcc} distance={3} decay={1.5} position={[0, 0, 0]} name=\"InternalLight\" />\n// // // // //       {vizControls.showParticles && (\n// // // // //         <points ref={particlesRef} name=\"FieldParticles\">\n// // // // //           <bufferGeometry ref={particleGeoRef} />\n// // // // //           <pointsMaterial\n// // // // //             name=\"ParticleMaterial\"\n// // // // //             color={0x00ffff}\n// // // // //             size={vizControls.particleSize}\n// // // // //             transparent\n// // // // //             opacity={0.7}\n// // // // //             blending={THREE.AdditiveBlending}\n// // // // //             sizeAttenuation={false}\n// // // // //             map={null}\n// // // // //           />\n// // // // //         </points>\n// // // // //       )}\n// // // // //     </group>\n// // // // //   );\n// // // // // };\n\n// // // // // const TemporalResonatorScene: React.FC = () => {\n// // // // //   return (\n// // // // //     <>\n// // // // //       <Leva collapsed={false} titleBar={{ title: \"Controls\" }} />\n// // // // //       <Canvas\n// // // // //         style={{\n// // // // //           position: \"absolute\",\n// // // // //           top: 0,\n// // // // //           left: 0,\n// // // // //           width: \"100vw\",\n// // // // //           height: \"100vh\",\n// // // // //           background: \"#111122\",\n// // // // //           zIndex: 0\n// // // // //         }}\n// // // // //         camera={{ position: [3, 3, 5], fov: 75 }}\n// // // // //         gl={{ antialias: true }}\n// // // // //         shadows\n// // // // //       >\n// // // // //         <ambientLight intensity={0.4} />\n// // // // //         <hemisphereLight groundColor={0x404040} intensity={0.8} />\n// // // // //         <directionalLight\n// // // // //           position={[5, 10, 7.5]}\n// // // // //           intensity={1.2}\n// // // // //           castShadow\n// // // // //           shadow-mapSize-width={1024}\n// // // // //           shadow-mapSize-height={1024}\n// // // // //           shadow-camera-far={25}\n// // // // //           shadow-camera-left={-10}\n// // // // //           shadow-camera-right={10}\n// // // // //           shadow-camera-top={10}\n// // // // //           shadow-camera-bottom={-10}\n// // // // //         />\n// // // // //         <ErrorBoundary>\n// // // // //           <Suspense fallback={<LoadingPlaceholder />}>\n// // // // //             <ResonatorSimulation />\n// // // // //           </Suspense>\n// // // // //         </ErrorBoundary>\n// // // // //         <Controls />\n// // // // //       </Canvas>\n// // // // //     </>\n// // // // //   );\n// // // // // };\n\n// // // // // // Loading Placeholder Component\n// // // // // const LoadingPlaceholder: React.FC = () => {\n// // // // //   return (\n// // // // //     <mesh>\n// // // // //       <boxGeometry args={[0.1, 0.1, 0.1]} />\n// // // // //       <meshBasicMaterial color=\"orange\" wireframe attach=\"material\" />\n// // // // //     </mesh>\n// // // // //   );\n// // // // // };\n\n// // // // // export default TemporalResonatorScene;\n\n\n// // // // // // // === Full Code: TemporalResonatorScene_Upgraded.tsx ===\n\n// // // // // // import React, { useRef, useEffect, useMemo, Suspense, useState } from 'react';\n// // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // // import * as THREE from 'three';\n// // // // // // import ErrorBoundary from './errorBoundary'; // Adjust path if needed\n// // // // // // import { useControls, Leva } from 'leva'; // Keep leva\n// // // // // // import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\n// // // // // // import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n\n// // // // // // // --- BVH / CSG Setup ---\n// // // // // // try {\n// // // // // //     (THREE.BufferGeometry.prototype as any).computeBoundsTree = computeBoundsTree;\n// // // // // //     (THREE.BufferGeometry.prototype as any).disposeBoundsTree = disposeBoundsTree;\n// // // // // //     (THREE.Mesh.prototype as any).raycast = acceleratedRaycast;\n// // // // // // } catch (error) {\n// // // // // //     console.error(\"Error setting up BVH extensions:\", error);\n// // // // // // }\n\n// // // // // // const csgEvaluator = new Evaluator();\n// // // // // // csgEvaluator.useGroups = true; // Use groups for efficiency with multiple operations\n// // // // // // extend({ OrbitControls });\n\n// // // // // // // --- Constants ---\n// // // // // // const PHI = (1 + Math.sqrt(5)) / 2;\n// // // // // // const INV_PHI = 1 / PHI;\n\n// // // // // // // *** NEW/UPDATED ***\n// // // // // // // For face-based weighting, we define 12 drag coefficients (one per face).\n// // // // // // // You can adjust these values to reflect how big each face's hole is, etc.\n// // // // // // const FACE_DRAG_COEFFICIENTS = [\n// // // // // //   0.8, 1.0, 0.9, 1.1, 0.6, 1.2,\n// // // // // //   1.05, 0.75, 0.95, 1.3, 0.7, 1.15\n// // // // // // ];\n\n// // // // // // // Simple helper to map rotation angle -> face index -> drag coefficient\n// // // // // // function getDragCoefficientFromAngle(angle: number) {\n// // // // // //   // Normalize angle to [0..2Ï€]\n// // // // // //   const normalizedAngle = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);\n// // // // // //   // 12 faces around 360Â°, each face ~ 30Â°\n// // // // // //   const faceIndex = Math.floor((normalizedAngle / (2 * Math.PI)) * 12);\n// // // // // //   // Return the face-based drag\n// // // // // //   return FACE_DRAG_COEFFICIENTS[faceIndex] ?? 1.0;\n// // // // // // }\n\n// // // // // // // --- Helper: Get Dodecahedron Math Data ---\n// // // // // // function getDodecahedronData(radius: number): {\n// // // // // //   vertices: THREE.Vector3[];\n// // // // // //   faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[];\n// // // // // // } {\n// // // // // //   console.log(`--- Calculating Dodecahedron Data for radius: ${radius} ---`);\n// // // // // //   if (typeof radius !== 'number' || radius <= 0 || !Number.isFinite(radius)) {\n// // // // // //     console.error(\"!!! Invalid radius passed to getDodecahedronData:\", radius);\n// // // // // //     throw new Error(\"Invalid radius provided to getDodecahedronData\");\n// // // // // //   }\n\n// // // // // //   // Use a Map to ensure vertex uniqueness\n// // // // // //   const uniqueVerticesMap = new Map<string, THREE.Vector3>();\n// // // // // //   const coords = [\n// // // // // //     [1, 1, 1], [-1, 1, 1], [1, -1, 1], [-1, -1, 1],\n// // // // // //     [1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1],\n// // // // // //     [0, PHI, INV_PHI], [0, -PHI, INV_PHI], [0, PHI, -INV_PHI], [0, -PHI, -INV_PHI],\n// // // // // //     [INV_PHI, 0, PHI], [-INV_PHI, 0, PHI], [INV_PHI, 0, -PHI], [-INV_PHI, 0, -PHI],\n// // // // // //     [PHI, INV_PHI, 0], [-PHI, INV_PHI, 0], [PHI, -INV_PHI, 0], [-PHI, -INV_PHI, 0]\n// // // // // //   ];\n\n// // // // // //   // Scale factor\n// // // // // //   const distOriginToVertex = Math.sqrt(PHI * PHI + INV_PHI * INV_PHI);\n// // // // // //   const scale = radius / distOriginToVertex;\n// // // // // //   if (!Number.isFinite(scale) || scale === 0) {\n// // // // // //     throw new Error(\"Invalid scale factor\");\n// // // // // //   }\n\n// // // // // //   // Build unique vertices\n// // // // // //   coords.forEach(v => {\n// // // // // //     const x = v[0] * scale;\n// // // // // //     const y = v[1] * scale;\n// // // // // //     const z = v[2] * scale;\n// // // // // //     const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`;\n// // // // // //     if (!uniqueVerticesMap.has(key)) {\n// // // // // //       uniqueVerticesMap.set(key, new THREE.Vector3(x, y, z));\n// // // // // //     }\n// // // // // //   });\n// // // // // //   const vertices = Array.from(uniqueVerticesMap.values());\n\n// // // // // //   // Face data from dual icosahedron\n// // // // // //   const faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] = [];\n// // // // // //   const icoVerts = [\n// // // // // //     [0, 1, PHI], [0, -1, PHI], [0, 1, -PHI], [0, -1, -PHI],\n// // // // // //     [1, PHI, 0], [-1, PHI, 0], [1, -PHI, 0], [-1, -PHI, 0],\n// // // // // //     [PHI, 0, 1], [-PHI, 0, 1], [PHI, 0, -1], [-PHI, 0, -1]\n// // // // // //   ];\n// // // // // //   const faceCenterDist = radius * 1.53 / distOriginToVertex;\n// // // // // //   icoVerts.forEach(v => {\n// // // // // //     const normal = new THREE.Vector3(v[0], v[1], v[2]).normalize();\n// // // // // //     const center = normal.clone().multiplyScalar(faceCenterDist);\n// // // // // //     faceData.push({ center, normal });\n// // // // // //   });\n\n// // // // // //   if (vertices.length !== 20 || faceData.length !== 12) {\n// // // // // //     console.error(\"!!! Vertex/Face generation failed. Vertices:\", vertices, \"Faces:\", faceData);\n// // // // // //     throw new Error(`Incorrect math data count: ${vertices.length} vertices, ${faceData.length} faces`);\n// // // // // //   }\n// // // // // //   console.log(`--- Generated ${vertices.length} vertices, ${faceData.length} faces. ---`);\n// // // // // //   return { vertices, faceData };\n// // // // // // }\n\n// // // // // // // --- Controls Component ---\n// // // // // // const Controls: React.FC = () => {\n// // // // // //   const { camera, gl } = useThree();\n// // // // // //   const controlsRef = useRef<OrbitControls>(null);\n// // // // // //   useEffect(() => {\n// // // // // //     const controls = new OrbitControls(camera, gl.domElement);\n// // // // // //     controls.enableDamping = true;\n// // // // // //     controls.target.set(0, 0, 0);\n// // // // // //     (controlsRef as React.MutableRefObject<OrbitControls>).current = controls;\n// // // // // //     return () => {\n// // // // // //       controls.dispose();\n// // // // // //     };\n// // // // // //   }, [camera, gl]);\n\n// // // // // //   useFrame(() => {\n// // // // // //     controlsRef.current?.update();\n// // // // // //   });\n// // // // // //   return null;\n// // // // // // };\n\n// // // // // // // --- Roman Dodecahedron CSG Component ---\n// // // // // // interface RomanDodecahedronProps {\n// // // // // //   outerRadius: number;\n// // // // // //   thickness: number;\n// // // // // //   holeBaseDiameter: number;\n// // // // // //   holeRatio: number;\n// // // // // //   noduleRadius: number;\n// // // // // //   material?: THREE.Material;\n// // // // // //   wireframe?: boolean;\n// // // // // //   [key: string]: any;\n// // // // // // }\n\n// // // // // // const RomanDodecahedron = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>(\n// // // // // //   (\n// // // // // //     {\n// // // // // //       outerRadius,\n// // // // // //       thickness,\n// // // // // //       holeBaseDiameter,\n// // // // // //       holeRatio,\n// // // // // //       noduleRadius,\n// // // // // //       material,\n// // // // // //       wireframe = false,\n// // // // // //       ...props\n// // // // // //     },\n// // // // // //     ref\n// // // // // //   ) => {\n// // // // // //     const [calculatedGeometry, setCalculatedGeometry] = useState<THREE.BufferGeometry | null>(null);\n\n// // // // // //     // CSG calculation\n// // // // // //     useEffect(() => {\n// // // // // //       console.log(\n// // // // // //         `useEffect Check: outerRadius=${outerRadius} (${typeof outerRadius}), thickness=${thickness}, holeBaseDiameter=${holeBaseDiameter}, holeRatio=${holeRatio}, noduleRadius=${noduleRadius}`\n// // // // // //       );\n// // // // // //       if (\n// // // // // //         typeof outerRadius !== 'number' ||\n// // // // // //         outerRadius <= 0 ||\n// // // // // //         !Number.isFinite(outerRadius) ||\n// // // // // //         typeof thickness !== 'number' ||\n// // // // // //         thickness <= 0 ||\n// // // // // //         !Number.isFinite(thickness) ||\n// // // // // //         typeof holeBaseDiameter !== 'number' ||\n// // // // // //         holeBaseDiameter <= 0 ||\n// // // // // //         !Number.isFinite(holeBaseDiameter) ||\n// // // // // //         typeof holeRatio !== 'number' ||\n// // // // // //         holeRatio <= 0 ||\n// // // // // //         !Number.isFinite(holeRatio) ||\n// // // // // //         typeof noduleRadius !== 'number' ||\n// // // // // //         noduleRadius <= 0 ||\n// // // // // //         !Number.isFinite(noduleRadius)\n// // // // // //       ) {\n// // // // // //         console.log(`--> Skipping CSG calculation in useEffect: Invalid props detected.`);\n// // // // // //         setCalculatedGeometry(null);\n// // // // // //         return;\n// // // // // //       }\n\n// // // // // //       const detailLevel = 1;\n// // // // // //       console.log(`Calculating CSG Geometry (Detail=${detailLevel}) for radius: ${outerRadius}`);\n// // // // // //       let geometry: THREE.BufferGeometry | null = null;\n// // // // // //       const tempGeoList: THREE.BufferGeometry[] = [];\n\n// // // // // //       try {\n// // // // // //         // Get positions/normals\n// // // // // //         const { vertices: mathVertices, faceData: mathFaceData } = getDodecahedronData(outerRadius);\n\n// // // // // //         // Create base shell\n// // // // // //         const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, detailLevel);\n// // // // // //         outerDodecGeo.computeBoundsTree();\n// // // // // //         tempGeoList.push(outerDodecGeo);\n\n// // // // // //         const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, detailLevel);\n// // // // // //         innerDodecGeo.computeBoundsTree();\n// // // // // //         tempGeoList.push(innerDodecGeo);\n\n// // // // // //         let outerBrush = new Brush(outerDodecGeo);\n// // // // // //         let innerBrush = new Brush(innerDodecGeo);\n// // // // // //         innerBrush.updateMatrixWorld();\n\n// // // // // //         let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n\n// // // // // //         // Subtract holes\n// // // // // //         const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * holeRatio ** i);\n// // // // // //         console.log(\"Calculated Hole Diameters:\", holeDiameters.map(d => d.toFixed(4)));\n// // // // // //         const cylinderHeight = thickness * 3.1;\n// // // // // //         const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16);\n// // // // // //         cylinderGeo.rotateX(Math.PI / 2);\n// // // // // //         cylinderGeo.computeBoundsTree();\n// // // // // //         tempGeoList.push(cylinderGeo);\n\n// // // // // //         const tempQuat = new THREE.Quaternion();\n// // // // // //         let holesSubtracted = 0;\n\n// // // // // //         mathFaceData.forEach((face, index) => {\n// // // // // //           const holeRadius = holeDiameters[index] / 2;\n// // // // // //           console.log(\n// // // // // //             `  Processing Face ${index}: Radius=${holeRadius?.toFixed(\n// // // // // //               4\n// // // // // //             )}, Center=(${face.center.x.toFixed(2)},${face.center.y.toFixed(\n// // // // // //               2\n// // // // // //             )},${face.center.z.toFixed(2)}), Normal=(${face.normal.x.toFixed(\n// // // // // //               2\n// // // // // //             )},${face.normal.y.toFixed(2)},${face.normal.z.toFixed(2)})`\n// // // // // //           );\n// // // // // //           if (!holeRadius || holeRadius <= 0 || !Number.isFinite(holeRadius)) {\n// // // // // //             console.warn(`    --> Skipping Face ${index}: Invalid radius.`);\n// // // // // //             return;\n// // // // // //           }\n\n// // // // // //           const holeBrush = new Brush(cylinderGeo);\n// // // // // //           holeBrush.scale.set(holeRadius, holeRadius, 1);\n// // // // // //           tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), face.normal);\n// // // // // //           holeBrush.quaternion.copy(tempQuat);\n// // // // // //           holeBrush.position.copy(face.center);\n// // // // // //           holeBrush.updateMatrixWorld();\n\n// // // // // //           try {\n// // // // // //             shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION);\n// // // // // //             holesSubtracted++;\n// // // // // //             console.log(`    --> Subtracted hole ${index}.`);\n// // // // // //           } catch (evalError) {\n// // // // // //             console.error(`    --> CSG subtraction FAILED for face ${index}:`, evalError);\n// // // // // //           }\n// // // // // //         });\n// // // // // //         console.log(`Total holes subtracted successfully: ${holesSubtracted}`);\n\n// // // // // //         // Add nodules\n// // // // // //         const noduleGeo = new THREE.SphereGeometry(noduleRadius, 6, 6);\n// // // // // //         noduleGeo.computeBoundsTree();\n// // // // // //         tempGeoList.push(noduleGeo);\n\n// // // // // //         mathVertices.forEach(vertexPos => {\n// // // // // //           const noduleBrush = new Brush(noduleGeo);\n// // // // // //           noduleBrush.position.copy(vertexPos);\n// // // // // //           noduleBrush.updateMatrixWorld();\n// // // // // //           shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION);\n// // // // // //         });\n\n// // // // // //         // Finalize geometry\n// // // // // //         geometry = shellBrush.geometry;\n// // // // // //         geometry.computeVertexNormals();\n// // // // // //         geometry.center();\n// // // // // //         console.log(\"CSG Calculation Complete.\");\n// // // // // //       } catch (error) {\n// // // // // //         console.error(\"CSG Error in useEffect:\", error);\n// // // // // //         geometry = null;\n// // // // // //       } finally {\n// // // // // //         // Cleanup\n// // // // // //         tempGeoList.forEach(g => g.dispose());\n// // // // // //         console.log(`Disposed ${tempGeoList.length} temporary CSG geometries.`);\n// // // // // //       }\n\n// // // // // //       setCalculatedGeometry(geometry);\n\n// // // // // //       return () => {\n// // // // // //         if (geometry && typeof geometry.dispose === 'function') {\n// // // // // //           geometry.dispose();\n// // // // // //           console.log(\"Disposed final CSG geometry from useEffect cleanup.\");\n// // // // // //         }\n// // // // // //       };\n// // // // // //     }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]);\n\n// // // // // //     // Memoize material\n// // // // // //     const meshMaterial = useMemo(() => {\n// // // // // //       let baseMaterial: THREE.Material;\n// // // // // //       if (material instanceof THREE.Material) {\n// // // // // //         baseMaterial = material.clone();\n// // // // // //         baseMaterial.side = THREE.DoubleSide;\n// // // // // //       } else {\n// // // // // //         baseMaterial = new THREE.MeshPhongMaterial({\n// // // // // //           color: 0xb87333,\n// // // // // //           side: THREE.DoubleSide,\n// // // // // //           specular: 0x444444,\n// // // // // //           shininess: 40,\n// // // // // //           name: \"DefaultPhongCopper\"\n// // // // // //         });\n// // // // // //       }\n// // // // // //       if (\"wireframe\" in baseMaterial) {\n// // // // // //         (baseMaterial as any).wireframe = wireframe;\n// // // // // //       }\n// // // // // //       baseMaterial.side = THREE.DoubleSide;\n// // // // // //       return baseMaterial;\n// // // // // //     }, [material, wireframe]);\n\n// // // // // //     // Dispose material on unmount\n// // // // // //     useEffect(() => {\n// // // // // //       return () => {\n// // // // // //         meshMaterial?.dispose();\n// // // // // //       };\n// // // // // //     }, [meshMaterial]);\n\n// // // // // //     if (!calculatedGeometry) return null;\n\n// // // // // //     return (\n// // // // // //       <mesh ref={ref} geometry={calculatedGeometry} material={meshMaterial} {...props} />\n// // // // // //     );\n// // // // // //   }\n// // // // // // );\n\n// // // // // // // --- Physics State ---\n// // // // // // interface PhysicsState {\n// // // // // //   shell_angular_velocity_scalar: number;\n// // // // // //   field_velocity_scalar: number;          // *** NEW/UPDATED *** (the \"spin-up\" field speed)\n// // // // // //   current_torque_scalar: number;\n// // // // // // }\n\n// // // // // // // --- Main Simulation Component ---\n// // // // // // const ResonatorSimulation: React.FC = () => {\n// // // // // //   const groupRef = useRef<THREE.Group>(null!);\n// // // // // //   const dodecahedronMeshRef = useRef<THREE.Mesh>(null!);\n// // // // // //   const particlesRef = useRef<THREE.Points>(null!);\n// // // // // //   const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // // // // //   // *** NEW/UPDATED ***\n// // // // // //   // Added spinUpRate, velocityThreshold, thresholdFeedbackFactor\n// // // // // //   const resonatorControls = useControls(\"Resonator Controls\", {\n// // // // // //     baseFieldSpeed: { value: 1.0, min: 0, max: 5, step: 0.1 },\n// // // // // //     fieldIntensity: { value: 1.0, min: 0.0, max: 5, step: 0.1 },\n// // // // // //     k_drag: { label: \"Induction Strength\", value: 0.5, min: 0, max: 2, step: 0.05 },\n// // // // // //     inertiaScale: { label: \"Inertia Scale\", value: 1.0, min: 0.1, max: 5, step: 0.1 },\n// // // // // //     damping: { value: 0.1, min: 0, max: 1, step: 0.01 },\n// // // // // //     // We'll keep k_feedback if you still want a direct coupling,\n// // // // // //     // but the threshold-based feedback is separate.\n// // // // // //     k_feedback: { value: 0.0, min: -2, max: 2, step: 0.05 },\n\n// // // // // //     // *** NEW/UPDATED *** spin-up & threshold feedback\n// // // // // //     spinUpRate: { value: 0.5, min: 0, max: 2, step: 0.1 },\n// // // // // //     velocityThreshold: { value: 1.5, min: 0, max: 10, step: 0.1 },\n// // // // // //     thresholdFeedbackFactor: { value: 1.0, min: 0, max: 5, step: 0.1 }\n// // // // // //   });\n\n// // // // // //   const shellControls = useControls(\"Shell Geometry\", {\n// // // // // //     outerRadius: 1.0,\n// // // // // //     thickness: 0.05,\n// // // // // //     holeBaseDiameter: 0.1,\n// // // // // //     holeRatio: 1.2,\n// // // // // //     noduleRadius: 0.1\n// // // // // //   });\n\n// // // // // //   const vizControls = useControls(\"Visualization\", {\n// // // // // //     particleCount: { value: 1000, min: 100, max: 5000, step: 100 },\n// // // // // //     particleSize: { value: 0.05, min: 0.01, max: 0.2, step: 0.01 },\n// // // // // //     torusMajorRadius: { value: 1.5, min: 0.5, max: 5, step: 0.1 },\n// // // // // //     torusMinorRadius: { value: 0.5, min: 0.1, max: 2, step: 0.05 },\n// // // // // //     showParticles: true,\n// // // // // //     wireframe: false\n// // // // // //   });\n\n// // // // // //   // Validate shell params\n// // // // // //   const defaultShellParams = useMemo(\n// // // // // //     () => ({\n// // // // // //       outerRadius: 1.0,\n// // // // // //       thickness: 0.05,\n// // // // // //       holeBaseDiameter: 0.1,\n// // // // // //       holeRatio: 1.2,\n// // // // // //       noduleRadius: 0.1\n// // // // // //     }),\n// // // // // //     []\n// // // // // //   );\n// // // // // //   const finalShellParams = useMemo(() => {\n// // // // // //     return {\n// // // // // //       outerRadius:\n// // // // // //         typeof shellControls.outerRadius === \"number\" && Number.isFinite(shellControls.outerRadius)\n// // // // // //           ? shellControls.outerRadius\n// // // // // //           : defaultShellParams.outerRadius,\n// // // // // //       thickness:\n// // // // // //         typeof shellControls.thickness === \"number\" && Number.isFinite(shellControls.thickness)\n// // // // // //           ? shellControls.thickness\n// // // // // //           : defaultShellParams.thickness,\n// // // // // //       holeBaseDiameter:\n// // // // // //         typeof shellControls.holeBaseDiameter === \"number\" && Number.isFinite(shellControls.holeBaseDiameter)\n// // // // // //           ? shellControls.holeBaseDiameter\n// // // // // //           : defaultShellParams.holeBaseDiameter,\n// // // // // //       holeRatio:\n// // // // // //         typeof shellControls.holeRatio === \"number\" && Number.isFinite(shellControls.holeRatio)\n// // // // // //           ? shellControls.holeRatio\n// // // // // //           : defaultShellParams.holeRatio,\n// // // // // //       noduleRadius:\n// // // // // //         typeof shellControls.noduleRadius === \"number\" && Number.isFinite(shellControls.noduleRadius)\n// // // // // //           ? shellControls.noduleRadius\n// // // // // //           : defaultShellParams.noduleRadius\n// // // // // //     };\n// // // // // //   }, [shellControls, defaultShellParams]);\n\n// // // // // //   // Effective inertia\n// // // // // //   const effectiveInertia = useMemo(() => {\n// // // // // //     return (\n// // // // // //       resonatorControls.inertiaScale *\n// // // // // //       ((finalShellParams.outerRadius ** 5 -\n// // // // // //         (finalShellParams.outerRadius - finalShellParams.thickness) ** 5) /\n// // // // // //         finalShellParams.outerRadius ** 5)\n// // // // // //     );\n// // // // // //   }, [resonatorControls.inertiaScale, finalShellParams.outerRadius, finalShellParams.thickness]);\n\n// // // // // //   // *** NEW/UPDATED ***\n// // // // // //   // We store the field velocity separately to handle spin-up.\n// // // // // //   const physicsState = useRef<PhysicsState>({\n// // // // // //     shell_angular_velocity_scalar: 0.0,\n// // // // // //     field_velocity_scalar: 0.0, // Start from 0, will ramp up to baseFieldSpeed\n// // // // // //     current_torque_scalar: 0.0\n// // // // // //   });\n\n// // // // // //   // Particle data\n// // // // // //   const particleData = useMemo(() => {\n// // // // // //     console.log(`Creating particle data for count: ${vizControls.particleCount}`);\n// // // // // //     try {\n// // // // // //       const data = [];\n// // // // // //       const positions = new Float32Array(vizControls.particleCount * 3);\n// // // // // //       for (let i = 0; i < vizControls.particleCount; i++) {\n// // // // // //         const u = Math.random() * Math.PI * 2;\n// // // // // //         const v = Math.random() * Math.PI * 2;\n// // // // // //         const R = vizControls.torusMajorRadius;\n// // // // // //         const r = vizControls.torusMinorRadius;\n// // // // // //         const randR = R + (Math.random() - 0.5) * 0.2 * r;\n// // // // // //         const randr = r * Math.sqrt(Math.random());\n\n// // // // // //         positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u);\n// // // // // //         positions[i * 3 + 1] = randr * Math.sin(v);\n// // // // // //         positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u);\n\n// // // // // //         data.push({ u, v, R, r: randr });\n// // // // // //       }\n// // // // // //       return { positions, data };\n// // // // // //     } catch (error) {\n// // // // // //       console.error(\"Error creating particle data:\", error);\n// // // // // //       return { positions: new Float32Array(0), data: [] };\n// // // // // //     }\n// // // // // //   }, [vizControls.particleCount, vizControls.torusMajorRadius, vizControls.torusMinorRadius]);\n\n// // // // // //   // Manage particle buffer attribute\n// // // // // //   useEffect(() => {\n// // // // // //     if (particleGeoRef.current && particleData?.positions) {\n// // // // // //       const existingAttribute = particleGeoRef.current.getAttribute(\"position\") as THREE.BufferAttribute | undefined;\n// // // // // //       if (!existingAttribute || existingAttribute.array.length !== particleData.positions.length) {\n// // // // // //         particleGeoRef.current.setAttribute(\"position\", new THREE.BufferAttribute(particleData.positions, 3, false));\n// // // // // //         console.log(`Particle position attribute CREATED/REPLACED (Count: ${particleData.positions.length / 3}).`);\n// // // // // //       }\n// // // // // //       if (particleGeoRef.current.getAttribute(\"color\")) {\n// // // // // //         particleGeoRef.current.deleteAttribute(\"color\");\n// // // // // //         console.log(\"Removed old particle color attribute.\");\n// // // // // //       }\n// // // // // //     } else {\n// // // // // //       if (particleGeoRef.current?.getAttribute(\"position\")) {\n// // // // // //         particleGeoRef.current.deleteAttribute(\"position\");\n// // // // // //         console.log(\"Particle position attribute removed.\");\n// // // // // //       }\n// // // // // //     }\n// // // // // //   }, [particleData]);\n\n// // // // // //   // *** NEW/UPDATED ***: Spin-up + face-based weighting + threshold feedback\n// // // // // //   useFrame((state, delta) => {\n// // // // // //     const currentPhysics = physicsState.current;\n\n// // // // // //     // 1) Spin up the field velocity from 0 to baseFieldSpeed\n// // // // // //     const baseFieldSpeed = resonatorControls.baseFieldSpeed;\n// // // // // //     if (currentPhysics.field_velocity_scalar < baseFieldSpeed) {\n// // // // // //       currentPhysics.field_velocity_scalar += resonatorControls.spinUpRate * delta;\n// // // // // //       // Clamp so it doesn't exceed baseFieldSpeed\n// // // // // //       if (currentPhysics.field_velocity_scalar > baseFieldSpeed) {\n// // // // // //         currentPhysics.field_velocity_scalar = baseFieldSpeed;\n// // // // // //       }\n// // // // // //     }\n\n// // // // // //     // 2) Combine with linear feedback (k_feedback) if desired\n// // // // // //     const effectiveFieldVelocity =\n// // // // // //       currentPhysics.field_velocity_scalar + resonatorControls.k_feedback * currentPhysics.shell_angular_velocity_scalar;\n\n// // // // // //     // 3) Face-based drag weighting\n// // // // // //     // We'll read the current groupRef rotation.y to see which face is \"aligned\"\n// // // // // //     const orientationAngle = groupRef.current?.rotation.y ?? 0;\n// // // // // //     const faceDragFactor = getDragCoefficientFromAngle(orientationAngle);\n// // // // // //     // Local drag = faceDragFactor * user-chosen k_drag\n// // // // // //     const localDrag = faceDragFactor * resonatorControls.k_drag;\n\n// // // // // //     // 4) Compute relative speed & base torque from drag\n// // // // // //     const relativeSpeed = effectiveFieldVelocity - currentPhysics.shell_angular_velocity_scalar;\n// // // // // //     let dragTorque = localDrag * resonatorControls.fieldIntensity * relativeSpeed;\n\n// // // // // //     // 5) Threshold-based feedback torque\n// // // // // //     let feedbackTorque = 0;\n// // // // // //     const shellSpeed = Math.abs(currentPhysics.shell_angular_velocity_scalar);\n// // // // // //     if (shellSpeed > resonatorControls.velocityThreshold) {\n// // // // // //       const overage = shellSpeed - resonatorControls.velocityThreshold;\n// // // // // //       // Negative torque that grows the further above threshold we are\n// // // // // //       feedbackTorque =\n// // // // // //         -Math.sign(currentPhysics.shell_angular_velocity_scalar) *\n// // // // // //         resonatorControls.thresholdFeedbackFactor *\n// // // // // //         overage;\n// // // // // //     }\n\n// // // // // //     // 6) Total torque\n// // // // // //     const totalTorque = dragTorque + feedbackTorque;\n// // // // // //     currentPhysics.current_torque_scalar = totalTorque;\n\n// // // // // //     // 7) Update shell angular velocity\n// // // // // //     const angularAcceleration = effectiveInertia > 0 ? totalTorque / effectiveInertia : 0;\n// // // // // //     currentPhysics.shell_angular_velocity_scalar += angularAcceleration * delta;\n\n// // // // // //     // 8) Damping\n// // // // // //     currentPhysics.shell_angular_velocity_scalar *= 1 - resonatorControls.damping * delta;\n\n// // // // // //     // 9) Apply rotation\n// // // // // //     if (groupRef.current) {\n// // // // // //       groupRef.current.rotation.y += currentPhysics.shell_angular_velocity_scalar * delta;\n// // // // // //     }\n\n// // // // // //     // Emissive update (optional)\n// // // // // //     if (dodecahedronMeshRef.current) {\n// // // // // //       const currentMaterial = dodecahedronMeshRef.current.material;\n// // // // // //       if (currentMaterial instanceof THREE.MeshStandardMaterial || currentMaterial instanceof THREE.MeshPhysicalMaterial) {\n// // // // // //         if (currentMaterial.emissive) {\n// // // // // //           // Some heuristic for emission\n// // // // // //           const maxTorqueEst =\n// // // // // //             resonatorControls.k_drag *\n// // // // // //             resonatorControls.fieldIntensity *\n// // // // // //             (Math.abs(baseFieldSpeed) * 1.5 + 1);\n// // // // // //           const emissionStrength = Math.min(\n// // // // // //             Math.abs(currentPhysics.current_torque_scalar) / (maxTorqueEst + 0.01),\n// // // // // //             1.0\n// // // // // //           );\n// // // // // //           currentMaterial.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5);\n// // // // // //         }\n// // // // // //       }\n// // // // // //     }\n\n// // // // // //     // 10) Update particle swirl\n// // // // // //     if (\n// // // // // //       vizControls.showParticles &&\n// // // // // //       particleGeoRef.current?.attributes.position &&\n// // // // // //       particlesRef.current &&\n// // // // // //       particleData?.data\n// // // // // //     ) {\n// // // // // //       const positions = particleGeoRef.current.attributes.position.array as Float32Array;\n// // // // // //       const speed = effectiveFieldVelocity * resonatorControls.fieldIntensity;\n// // // // // //       const pData = particleData.data;\n\n// // // // // //       if (pData && pData.length * 3 === positions.length) {\n// // // // // //         const pointsMat = particlesRef.current.material as THREE.PointsMaterial;\n// // // // // //         if (pointsMat) {\n// // // // // //           pointsMat.size = vizControls.particleSize * (1 + resonatorControls.fieldIntensity * 0.5);\n// // // // // //         }\n\n// // // // // //         for (let i = 0; i < pData.length; i++) {\n// // // // // //           const data = pData[i];\n// // // // // //           data.u += speed * delta;\n// // // // // //           const R = vizControls.torusMajorRadius;\n// // // // // //           const r = data.r;\n// // // // // //           const u = data.u;\n// // // // // //           const v = data.v;\n// // // // // //           const bufferIndex = i * 3;\n\n// // // // // //           positions[bufferIndex] = (R + r * Math.cos(v)) * Math.cos(u);\n// // // // // //           positions[bufferIndex + 1] = r * Math.sin(v);\n// // // // // //           positions[bufferIndex + 2] = (R + r * Math.cos(v)) * Math.sin(u);\n// // // // // //         }\n// // // // // //         particleGeoRef.current.attributes.position.needsUpdate = true;\n// // // // // //       } else {\n// // // // // //         console.warn(\"Mismatch particle data/buffer length in useFrame.\");\n// // // // // //       }\n// // // // // //     }\n// // // // // //   });\n\n// // // // // //   return (\n// // // // // //     <group ref={groupRef}>\n// // // // // //       <RomanDodecahedron\n// // // // // //         ref={dodecahedronMeshRef}\n// // // // // //         outerRadius={finalShellParams.outerRadius}\n// // // // // //         thickness={finalShellParams.thickness}\n// // // // // //         holeBaseDiameter={finalShellParams.holeBaseDiameter}\n// // // // // //         holeRatio={finalShellParams.holeRatio}\n// // // // // //         noduleRadius={finalShellParams.noduleRadius}\n// // // // // //         wireframe={vizControls.wireframe}\n// // // // // //         castShadow\n// // // // // //         receiveShadow\n// // // // // //         position={[0, 0, 0]}\n// // // // // //         rotation={[0, 0, 0]}\n// // // // // //       />\n// // // // // //       <pointLight\n// // // // // //         intensity={0.5}\n// // // // // //         color={0xffddcc}\n// // // // // //         distance={3}\n// // // // // //         decay={1.5}\n// // // // // //         position={[0, 0, 0]}\n// // // // // //         name=\"InternalLight\"\n// // // // // //       />\n// // // // // //       {vizControls.showParticles && (\n// // // // // //         <points ref={particlesRef} name=\"FieldParticles\">\n// // // // // //           <bufferGeometry ref={particleGeoRef} />\n// // // // // //           <pointsMaterial\n// // // // // //             name=\"ParticleMaterial\"\n// // // // // //             color={0x00ffff}\n// // // // // //             size={vizControls.particleSize}\n// // // // // //             transparent\n// // // // // //             opacity={0.7}\n// // // // // //             blending={THREE.AdditiveBlending}\n// // // // // //             sizeAttenuation={false}\n// // // // // //             map={null}\n// // // // // //           />\n// // // // // //         </points>\n// // // // // //       )}\n// // // // // //     </group>\n// // // // // //   );\n// // // // // // };\n\n// // // // // // const TemporalResonatorScene: React.FC = () => {\n// // // // // //   return (\n// // // // // //     <>\n// // // // // //       <Leva collapsed={false} titleBar={{ title: \"Controls\" }} />\n// // // // // //       <Canvas\n// // // // // //         style={{\n// // // // // //           position: \"absolute\",\n// // // // // //           top: 0,\n// // // // // //           left: 0,\n// // // // // //           width: \"100vw\",\n// // // // // //           height: \"100vh\",\n// // // // // //           background: \"#111122\",\n// // // // // //           zIndex: 0\n// // // // // //         }}\n// // // // // //         camera={{ position: [3, 3, 5], fov: 75 }}\n// // // // // //         gl={{ antialias: true }}\n// // // // // //         shadows\n// // // // // //       >\n// // // // // //         <ambientLight intensity={0.4} />\n// // // // // //         <hemisphereLight groundColor={0x404040} intensity={0.8} />\n// // // // // //         <directionalLight\n// // // // // //           position={[5, 10, 7.5]}\n// // // // // //           intensity={1.2}\n// // // // // //           castShadow\n// // // // // //           shadow-mapSize-width={1024}\n// // // // // //           shadow-mapSize-height={1024}\n// // // // // //           shadow-camera-far={25}\n// // // // // //           shadow-camera-left={-10}\n// // // // // //           shadow-camera-right={10}\n// // // // // //           shadow-camera-top={10}\n// // // // // //           shadow-camera-bottom={-10}\n// // // // // //         />\n// // // // // //         <ErrorBoundary>\n// // // // // //           <Suspense fallback={<LoadingPlaceholder />}>\n// // // // // //             <ResonatorSimulation />\n// // // // // //           </Suspense>\n// // // // // //         </ErrorBoundary>\n// // // // // //         <Controls />\n// // // // // //         {/* <axesHelper args={[5]} /> */}\n// // // // // //       </Canvas>\n// // // // // //     </>\n// // // // // //   );\n// // // // // // };\n\n// // // // // // // Loading placeholder\n// // // // // // const LoadingPlaceholder: React.FC = () => {\n// // // // // //   return (\n// // // // // //     <mesh>\n// // // // // //       <boxGeometry args={[0.1, 0.1, 0.1]} />\n// // // // // //       <meshBasicMaterial color=\"orange\" wireframe attach=\"material\" />\n// // // // // //     </mesh>\n// // // // // //   );\n// // // // // // };\n\n// // // // // // export default TemporalResonatorScene;\n\n\n\n// // // // // // // // === Full Code: TemporalResonatorScene_V2_CSG_Fixes_17_SingleField_Complete_NoSkips.tsx ===\n\n// // // // // // // import React, { useRef, useEffect, useMemo, Suspense, useState } from 'react';\n// // // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // // // import * as THREE from 'three';\n// // // // // // // import ErrorBoundary from './errorBoundary'; // Adjust path if needed\n// // // // // // // import { useControls, Leva } from 'leva'; // Keep leva\n// // // // // // // import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\n// // // // // // // import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n\n// // // // // // // // --- BVH / CSG Setup ---\n// // // // // // // try {\n// // // // // // //     // Assign prototypes for BVH computation\n// // // // // // //     (THREE.BufferGeometry.prototype as any).computeBoundsTree = computeBoundsTree;\n// // // // // // //     (THREE.BufferGeometry.prototype as any).disposeBoundsTree = disposeBoundsTree;\n// // // // // // //     (THREE.Mesh.prototype as any).raycast = acceleratedRaycast;\n// // // // // // // } catch (error) {\n// // // // // // //     console.error(\"Error setting up BVH extensions:\", error);\n// // // // // // // }\n// // // // // // // const csgEvaluator = new Evaluator();\n// // // // // // // csgEvaluator.useGroups = true; // Use groups for efficiency with multiple operations\n// // // // // // // extend({ OrbitControls }); // Extend R3F for OrbitControls\n\n// // // // // // // // --- Constants ---\n// // // // // // // const PHI = (1 + Math.sqrt(5)) / 2;\n// // // // // // // const INV_PHI = 1 / PHI;\n\n// // // // // // // // --- Helper: Get Dodecahedron Math Data ---\n// // // // // // // function getDodecahedronData(radius: number): { vertices: THREE.Vector3[]; faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] } {\n// // // // // // //     console.log(`--- Calculating Dodecahedron Data for radius: ${radius} ---`);\n// // // // // // //     // Validate input radius\n// // // // // // //     if (typeof radius !== 'number' || radius <= 0 || !Number.isFinite(radius)) {\n// // // // // // //         console.error(\"!!! Invalid radius passed to getDodecahedronData:\", radius);\n// // // // // // //         throw new Error(\"Invalid radius provided to getDodecahedronData\");\n// // // // // // //     }\n\n// // // // // // //     // Use a Map to ensure vertex uniqueness based on precise coordinates\n// // // // // // //     const uniqueVerticesMap = new Map<string, THREE.Vector3>();\n// // // // // // //     // Define base coordinates for dodecahedron vertices\n// // // // // // //     const coords = [\n// // // // // // //         [1, 1, 1], [-1, 1, 1], [1, -1, 1], [-1, -1, 1], [1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1],\n// // // // // // //         [0, PHI, INV_PHI], [0, -PHI, INV_PHI], [0, PHI, -INV_PHI], [0, -PHI, -INV_PHI],\n// // // // // // //         [INV_PHI, 0, PHI], [-INV_PHI, 0, PHI], [INV_PHI, 0, -PHI], [-INV_PHI, 0, -PHI],\n// // // // // // //         [PHI, INV_PHI, 0], [-PHI, INV_PHI, 0], [PHI, -INV_PHI, 0], [-PHI, -INV_PHI, 0]\n// // // // // // //     ];\n// // // // // // //     // Calculate the scaling factor to match the desired radius\n// // // // // // //     const distOriginToVertex = Math.sqrt(PHI * PHI + INV_PHI * INV_PHI);\n// // // // // // //     const scale = radius / distOriginToVertex;\n// // // // // // //     if (!Number.isFinite(scale) || scale === 0) { throw new Error(\"Invalid scale factor\"); }\n\n// // // // // // //     // Populate the map with unique, scaled vertices\n// // // // // // //     coords.forEach(v => {\n// // // // // // //         const x = v[0] * scale; const y = v[1] * scale; const z = v[2] * scale;\n// // // // // // //         const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`; // Key for uniqueness\n// // // // // // //         if (!uniqueVerticesMap.has(key)) { uniqueVerticesMap.set(key, new THREE.Vector3(x, y, z)); }\n// // // // // // //     });\n// // // // // // //     const vertices = Array.from(uniqueVerticesMap.values()); // Get unique vertices\n\n// // // // // // //     // Calculate face centers and normals using the dual icosahedron's vertices\n// // // // // // //     const faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] = [];\n// // // // // // //     const icoVerts = [ [0, 1, PHI], [0, -1, PHI], [0, 1, -PHI], [0, -1, -PHI], [1, PHI, 0], [-1, PHI, 0], [1, -PHI, 0], [-1, -PHI, 0], [PHI, 0, 1], [-PHI, 0, 1], [PHI, 0, -1], [-PHI, 0, -1] ];\n// // // // // // //     // Estimate face center distance relative to the vertex distance (adjust factor if needed)\n// // // // // // //     const faceCenterDist = radius * 1.53 / distOriginToVertex;\n// // // // // // //     icoVerts.forEach(v => {\n// // // // // // //         const normal = new THREE.Vector3(v[0], v[1], v[2]).normalize();\n// // // // // // //         const center = normal.clone().multiplyScalar(faceCenterDist);\n// // // // // // //         faceData.push({ center, normal });\n// // // // // // //     });\n\n// // // // // // //     // Final validation of generated data counts\n// // // // // // //     if (vertices.length !== 20 || faceData.length !== 12) {\n// // // // // // //         console.error(\"!!! Vertex/Face generation failed. Vertices:\", vertices, \"Faces:\", faceData);\n// // // // // // //         throw new Error(`Incorrect math data count: ${vertices.length} vertices, ${faceData.length} faces`);\n// // // // // // //     }\n// // // // // // //     console.log(`--- Generated ${vertices.length} vertices, ${faceData.length} faces. ---`);\n// // // // // // //     return { vertices, faceData };\n// // // // // // // }\n\n// // // // // // // // --- Controls Component ---\n// // // // // // // const Controls: React.FC = () => {\n// // // // // // //      const { camera, gl } = useThree();\n// // // // // // //      const controlsRef = useRef<OrbitControls>(null);\n// // // // // // //      useEffect(() => {\n// // // // // // //          const controls = new OrbitControls(camera, gl.domElement);\n// // // // // // //          controls.enableDamping = true;\n// // // // // // //          controls.target.set(0, 0, 0); // Target the origin (where the group is)\n// // // // // // //          (controlsRef as React.MutableRefObject<OrbitControls>).current = controls;\n// // // // // // //          return () => { controls.dispose(); }; // Cleanup on unmount\n// // // // // // //      }, [camera, gl]);\n// // // // // // //      // Update controls in the animation loop for damping\n// // // // // // //      useFrame(() => { controlsRef.current?.update(); });\n// // // // // // //      return null;\n// // // // // // // };\n\n// // // // // // // // --- Roman Dodecahedron CSG Component ---\n// // // // // // // interface RomanDodecahedronProps {\n// // // // // // //     outerRadius: number; thickness: number; holeBaseDiameter: number;\n// // // // // // //     holeRatio: number; noduleRadius: number; material?: THREE.Material;\n// // // // // // //     wireframe?: boolean; [key: string]: any;\n// // // // // // // }\n// // // // // // // const RomanDodecahedron: React.FC<RomanDodecahedronProps> = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>(\n// // // // // // //     ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, wireframe = false, ...props }, ref) => {\n\n// // // // // // //     // State to hold the geometry calculated after mount/prop changes\n// // // // // // //     const [calculatedGeometry, setCalculatedGeometry] = useState<THREE.BufferGeometry | null>(null);\n\n// // // // // // //     // Effect to perform CSG calculation\n// // // // // // //     useEffect(() => {\n// // // // // // //         console.log(`useEffect Check: outerRadius=${outerRadius} (${typeof outerRadius}), thickness=${thickness}, holeBaseDiameter=${holeBaseDiameter}, holeRatio=${holeRatio}, noduleRadius=${noduleRadius}`);\n// // // // // // //         // Guard against invalid props (potentially from initial Leva state)\n// // // // // // //         if ( typeof outerRadius !== 'number' || outerRadius <= 0 || !Number.isFinite(outerRadius) || typeof thickness !== 'number' || thickness <= 0 || !Number.isFinite(thickness) || typeof holeBaseDiameter !== 'number' || holeBaseDiameter <= 0 || !Number.isFinite(holeBaseDiameter) || typeof holeRatio !== 'number' || holeRatio <= 0 || !Number.isFinite(holeRatio) || typeof noduleRadius !== 'number' || noduleRadius <= 0 || !Number.isFinite(noduleRadius) ) {\n// // // // // // //             console.log(`--> Skipping CSG calculation in useEffect: Invalid props detected.`);\n// // // // // // //             setCalculatedGeometry(null); // Ensure geometry is null if props invalid\n// // // // // // //             return; // Exit effect\n// // // // // // //         }\n\n// // // // // // //         const detailLevel = 1; // Keep detail level 1 for performance/simplicity\n// // // // // // //         console.log(`Calculating CSG Geometry (Detail=${detailLevel}) for radius: ${outerRadius}`);\n// // // // // // //         let geometry: THREE.BufferGeometry | null = null;\n// // // // // // //         let tempGeoList: THREE.BufferGeometry[] = []; // Track temp geos for disposal\n\n// // // // // // //         try {\n// // // // // // //             // Get mathematically correct positions/normals\n// // // // // // //             const { vertices: mathVertices, faceData: mathFaceData } = getDodecahedronData(outerRadius);\n\n// // // // // // //             // Create base shell\n// // // // // // //             const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, detailLevel); outerDodecGeo.computeBoundsTree(); tempGeoList.push(outerDodecGeo);\n// // // // // // //             const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, detailLevel); innerDodecGeo.computeBoundsTree(); tempGeoList.push(innerDodecGeo);\n// // // // // // //             let outerBrush = new Brush(outerDodecGeo); let innerBrush = new Brush(innerDodecGeo); innerBrush.updateMatrixWorld();\n// // // // // // //             let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n\n// // // // // // //             // Create and subtract holes\n// // // // // // //             const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * (holeRatio ** i));\n// // // // // // //             console.log(\"Calculated Hole Diameters:\", holeDiameters.map(d => d.toFixed(4))); // Log hole diameters\n// // // // // // //             const cylinderHeight = thickness * 3.1; // Ensure cylinder goes through shell\n// // // // // // //             const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16); cylinderGeo.rotateX(Math.PI / 2); cylinderGeo.computeBoundsTree(); tempGeoList.push(cylinderGeo);\n// // // // // // //             const tempQuat = new THREE.Quaternion();\n// // // // // // //             let holesSubtracted = 0; // Counter\n\n// // // // // // //             mathFaceData.forEach((face, index) => {\n// // // // // // //                 const holeRadius = holeDiameters[index] / 2;\n// // // // // // //                 console.log(`  Processing Face ${index}: Radius=${holeRadius?.toFixed(4)}, Center=(${face.center.x.toFixed(2)},${face.center.y.toFixed(2)},${face.center.z.toFixed(2)}), Normal=(${face.normal.x.toFixed(2)},${face.normal.y.toFixed(2)},${face.normal.z.toFixed(2)})`);\n// // // // // // //                 if (!holeRadius || holeRadius <= 0 || !Number.isFinite(holeRadius)) { console.warn(`    --> Skipping Face ${index}: Invalid radius.`); return; }\n\n// // // // // // //                 const holeBrush = new Brush(cylinderGeo);\n// // // // // // //                 holeBrush.scale.set(holeRadius, holeRadius, 1);\n// // // // // // //                 tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), face.normal);\n// // // // // // //                 holeBrush.quaternion.copy(tempQuat);\n// // // // // // //                 holeBrush.position.copy(face.center);\n// // // // // // //                 holeBrush.updateMatrixWorld();\n\n// // // // // // //                 try {\n// // // // // // //                     shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION); // Assign result back\n// // // // // // //                     holesSubtracted++;\n// // // // // // //                     console.log(`    --> Subtracted hole ${index}.`);\n// // // // // // //                 } catch (evalError) {\n// // // // // // //                      console.error(`    --> CSG subtraction FAILED for face ${index}:`, evalError);\n// // // // // // //                 }\n// // // // // // //             });\n// // // // // // //             console.log(`Total holes subtracted successfully (based on code execution): ${holesSubtracted}`);\n\n// // // // // // //             // Create and add nodules\n// // // // // // //             const noduleGeo = new THREE.SphereGeometry(noduleRadius, 6, 6); noduleGeo.computeBoundsTree(); tempGeoList.push(noduleGeo);\n// // // // // // //             mathVertices.forEach(vertexPos => {\n// // // // // // //                 const noduleBrush = new Brush(noduleGeo); noduleBrush.position.copy(vertexPos);\n// // // // // // //                 noduleBrush.updateMatrixWorld(); shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION);\n// // // // // // //             });\n\n// // // // // // //             // Finalize geometry\n// // // // // // //             geometry = shellBrush.geometry;\n// // // // // // //             geometry.computeVertexNormals(); // Crucial for lighting!\n// // // // // // //             geometry.center(); // Center the final composite shape\n// // // // // // //             console.log(\"CSG Calculation Complete.\");\n\n// // // // // // //         } catch (error) {\n// // // // // // //             console.error(\"CSG Error in useEffect:\", error);\n// // // // // // //             geometry = null; // Ensure null on error\n// // // // // // //         } finally {\n// // // // // // //             // Clean up intermediate geometries used for CSG brushes\n// // // // // // //             tempGeoList.forEach(g => g.dispose());\n// // // // // // //             console.log(`Disposed ${tempGeoList.length} temporary CSG geometries.`);\n// // // // // // //         }\n\n// // // // // // //         // Update state with the calculated geometry (or null)\n// // // // // // //         setCalculatedGeometry(geometry);\n\n// // // // // // //         // Effect cleanup function: Dispose the *final* geometry when effect re-runs or unmounts\n// // // // // // //         return () => {\n// // // // // // //             if (geometry && typeof geometry.dispose === 'function') {\n// // // // // // //                 geometry.dispose();\n// // // // // // //                 console.log(\"Disposed final CSG geometry from useEffect cleanup.\");\n// // // // // // //             }\n// // // // // // //         };\n// // // // // // //     }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]); // Dependencies\n\n// // // // // // //     // Memoize the material based on props, using Phong default\n// // // // // // //     const meshMaterial = useMemo(() => {\n// // // // // // //         let baseMaterial: THREE.Material;\n// // // // // // //         if (material instanceof THREE.Material) {\n// // // // // // //              baseMaterial = material.clone(); baseMaterial.side = THREE.DoubleSide;\n// // // // // // //         } else {\n// // // // // // //             baseMaterial = new THREE.MeshPhongMaterial({ color: 0xB87333, side: THREE.DoubleSide, specular: 0x444444, shininess: 40, name: \"DefaultPhongCopper\" });\n// // // // // // //         }\n// // // // // // //         // Use type guard for wireframe property\n// // // // // // //         if ('wireframe' in baseMaterial) {\n// // // // // // //             (baseMaterial as any).wireframe = wireframe;\n// // // // // // //         }\n// // // // // // //         baseMaterial.side = THREE.DoubleSide; // Ensure double side\n// // // // // // //         return baseMaterial;\n// // // // // // //     }, [material, wireframe]);\n\n// // // // // // //     // Effect to dispose the memoized material\n// // // // // // //     useEffect(() => { return () => { meshMaterial?.dispose(); } }, [meshMaterial]);\n\n// // // // // // //     // Don't render if geometry calculation failed or hasn't completed\n// // // // // // //     if (!calculatedGeometry) { return null; }\n\n// // // // // // //     // Render the mesh using calculated geometry and memoized material\n// // // // // // //     return <mesh ref={ref} geometry={calculatedGeometry} material={meshMaterial} {...props} />;\n// // // // // // // });\n\n// // // // // // // // --- Physics State Interface (Reverted) ---\n// // // // // // // interface PhysicsState {\n// // // // // // //     shell_angular_velocity_scalar: number;\n// // // // // // //     effective_field_velocity_scalar: number;\n// // // // // // //     current_torque_scalar: number;\n// // // // // // // }\n\n// // // // // // // // --- Main Simulation Component ---\n// // // // // // // const ResonatorSimulation: React.FC = () => {\n// // // // // // //     // Refs for scene objects\n// // // // // // //     const groupRef = useRef<THREE.Group>(null!);\n// // // // // // //     const dodecahedronMeshRef = useRef<THREE.Mesh>(null!);\n// // // // // // //     const particlesRef = useRef<THREE.Points>(null!);\n// // // // // // //     const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // // // // // //     // Leva controls setup - Reverted to single field controls\n// // // // // // //     const resonatorControls = useControls('Resonator Controls', {\n// // // // // // //         baseFieldSpeed: { value: 1.0, min: -5, max: 5, step: 0.1 }, // Single speed\n// // // // // // //         fieldIntensity: { value: 1.0, min: 0.0, max: 5, step: 0.1 }, // Single intensity\n// // // // // // //         k_drag: { label: 'Induction Strength', value: 0.5, min: 0, max: 2, step: 0.05 },\n// // // // // // //         inertiaScale: { label: 'Inertia Scale', value: 1.0, min: 0.1, max: 5, step: 0.1 },\n// // // // // // //         damping: { value: 0.1, min: 0, max: 1, step: 0.01 },\n// // // // // // //         k_feedback: { value: -0.2, min: -2, max: 2, step: 0.05 },\n// // // // // // //     });\n// // // // // // //     const shellControls = useControls('Shell Geometry', { outerRadius: 1.0, thickness: 0.05, holeBaseDiameter: 0.1, holeRatio: 1.2, noduleRadius: 0.1 });\n// // // // // // //     const vizControls = useControls('Visualization', {\n// // // // // // //         particleCount: { value: 1000, min: 100, max: 5000, step: 100 },\n// // // // // // //         particleSize: { value: 0.05, min: 0.01, max: 0.2, step: 0.01 },\n// // // // // // //         torusMajorRadius: { value: 1.5, min: 0.5, max: 5, step: 0.1 }, // Single torus radius\n// // // // // // //         torusMinorRadius: { value: 0.5, min: 0.1, max: 2, step: 0.05 }, // Single torus radius\n// // // // // // //         showParticles: true,\n// // // // // // //         wireframe: false\n// // // // // // //     });\n\n// // // // // // //     // Ensure shell parameters are valid numbers, falling back to defaults\n// // // // // // //     const defaultShellParams = useMemo(() => ({ outerRadius: 1.0, thickness: 0.05, holeBaseDiameter: 0.1, holeRatio: 1.2, noduleRadius: 0.1 }), []);\n// // // // // // //     const finalShellParams = useMemo(() => ({\n// // // // // // //         outerRadius: (typeof shellControls.outerRadius === 'number' && Number.isFinite(shellControls.outerRadius)) ? shellControls.outerRadius : defaultShellParams.outerRadius,\n// // // // // // //         thickness: (typeof shellControls.thickness === 'number' && Number.isFinite(shellControls.thickness)) ? shellControls.thickness : defaultShellParams.thickness,\n// // // // // // //         holeBaseDiameter: (typeof shellControls.holeBaseDiameter === 'number' && Number.isFinite(shellControls.holeBaseDiameter)) ? shellControls.holeBaseDiameter : defaultShellParams.holeBaseDiameter,\n// // // // // // //         holeRatio: (typeof shellControls.holeRatio === 'number' && Number.isFinite(shellControls.holeRatio)) ? shellControls.holeRatio : defaultShellParams.holeRatio,\n// // // // // // //         noduleRadius: (typeof shellControls.noduleRadius === 'number' && Number.isFinite(shellControls.noduleRadius)) ? shellControls.noduleRadius : defaultShellParams.noduleRadius,\n// // // // // // //     }), [shellControls, defaultShellParams]);\n\n// // // // // // //     // Calculate effective inertia\n// // // // // // //     const effectiveInertia = useMemo(() => resonatorControls.inertiaScale * (finalShellParams.outerRadius ** 5 - (finalShellParams.outerRadius - finalShellParams.thickness) ** 5) / finalShellParams.outerRadius ** 5, [resonatorControls.inertiaScale, finalShellParams.outerRadius, finalShellParams.thickness]);\n\n// // // // // // //     // Initialize physics state using a ref\n// // // // // // //     const physicsState = useRef<PhysicsState>({\n// // // // // // //          shell_angular_velocity_scalar: 0.0, // Starts at rest\n// // // // // // //          effective_field_velocity_scalar: resonatorControls.baseFieldSpeed || 0,\n// // // // // // //          current_torque_scalar: 0.0,\n// // // // // // //     });\n\n// // // // // // //     // Memoize particle data creation (single field version)\n// // // // // // //     const particleData = useMemo<{ positions: Float32Array; data: any[] }>(() => {\n// // // // // // //         console.log(`Creating particle data for count: ${vizControls.particleCount}`);\n// // // // // // //         try {\n// // // // // // //              const data = []; const positions = new Float32Array(vizControls.particleCount * 3);\n// // // // // // //              for (let i = 0; i < vizControls.particleCount; i++) {\n// // // // // // //                  const u = Math.random() * Math.PI * 2; const v = Math.random() * Math.PI * 2;\n// // // // // // //                  const R = vizControls.torusMajorRadius; const r = vizControls.torusMinorRadius;\n// // // // // // //                  const randR = R + (Math.random() - 0.5) * 0.2 * r;\n// // // // // // //                  const randr = r * Math.sqrt(Math.random());\n// // // // // // //                  positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u);\n// // // // // // //                  positions[i * 3 + 1] = randr * Math.sin(v);\n// // // // // // //                  positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u);\n// // // // // // //                  data.push({ u, v, R, r: randr }); // Only need position data\n// // // // // // //             }\n// // // // // // //              return { positions, data };\n// // // // // // //         } catch (error) { console.error(\"Error creating particle data:\", error); return { positions: new Float32Array(0), data: [] }; }\n// // // // // // //      }, [vizControls.particleCount, vizControls.torusMajorRadius, vizControls.torusMinorRadius]);\n\n// // // // // // //     // Effect to manage the particle buffer attribute (position only)\n// // // // // // //      useEffect(() => {\n// // // // // // //          if (particleGeoRef.current && particleData?.positions) {\n// // // // // // //              const existingAttribute = particleGeoRef.current.getAttribute('position') as THREE.BufferAttribute | undefined;\n// // // // // // //              if (!existingAttribute || existingAttribute.array.length !== particleData.positions.length) {\n// // // // // // //                  particleGeoRef.current.setAttribute('position', new THREE.BufferAttribute(particleData.positions, 3, false));\n// // // // // // //                  console.log(`Particle position attribute CREATED/REPLACED (Count: ${particleData.positions.length / 3}).`);\n// // // // // // //              }\n// // // // // // //              if (particleGeoRef.current.getAttribute('color')) { // Clean up color if it exists\n// // // // // // //                   particleGeoRef.current.deleteAttribute('color');\n// // // // // // //                   console.log(\"Removed old particle color attribute.\");\n// // // // // // //              }\n// // // // // // //          } else { if (particleGeoRef.current?.getAttribute('position')) { particleGeoRef.current.deleteAttribute('position'); console.log(\"Particle position attribute removed.\"); } }\n// // // // // // //      }, [particleData]);\n\n// // // // // // //     // Main animation loop\n// // // // // // //     useFrame((state, delta) => {\n// // // // // // //         const currentPhysics = physicsState.current;\n\n// // // // // // //         // --- Single Field Physics Calculations ---\n// // // // // // //         currentPhysics.effective_field_velocity_scalar = resonatorControls.baseFieldSpeed + resonatorControls.k_feedback * currentPhysics.shell_angular_velocity_scalar;\n// // // // // // //         const relative_speed = currentPhysics.effective_field_velocity_scalar - currentPhysics.shell_angular_velocity_scalar;\n// // // // // // //         currentPhysics.current_torque_scalar = resonatorControls.k_drag * resonatorControls.fieldIntensity * relative_speed;\n// // // // // // //         const angular_acceleration = effectiveInertia > 0 ? (currentPhysics.current_torque_scalar / effectiveInertia) : 0;\n// // // // // // //         currentPhysics.shell_angular_velocity_scalar += angular_acceleration * delta;\n// // // // // // //         currentPhysics.shell_angular_velocity_scalar *= (1 - resonatorControls.damping * delta);\n\n// // // // // // //         // Rotate the Group\n// // // // // // //         if (groupRef.current) {\n// // // // // // //              // console.log(\"Ang Vel:\", currentPhysics.shell_angular_velocity_scalar.toFixed(3));\n// // // // // // //              groupRef.current.rotation.y += currentPhysics.shell_angular_velocity_scalar * delta;\n// // // // // // //         }\n\n// // // // // // //         // Update Emissive (Conditional - only for Standard/Physical Materials)\n// // // // // // //         if (dodecahedronMeshRef.current) {\n// // // // // // //              const currentMaterial = dodecahedronMeshRef.current.material;\n// // // // // // //              if (currentMaterial instanceof THREE.MeshStandardMaterial || currentMaterial instanceof THREE.MeshPhysicalMaterial) {\n// // // // // // //                  if (currentMaterial.emissive) {\n// // // // // // //                       const maxTorqueEst = resonatorControls.k_drag * resonatorControls.fieldIntensity * (Math.abs(resonatorControls.baseFieldSpeed) * 1.5 + 1);\n// // // // // // //                       const emissionStrength = Math.min(Math.abs(currentPhysics.current_torque_scalar) / (maxTorqueEst + 0.01), 1.0);\n// // // // // // //                       currentMaterial.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5);\n// // // // // // //                  }\n// // // // // // //              }\n// // // // // // //         }\n\n// // // // // // //         // --- Single Field Particle Update ---\n// // // // // // //         if (vizControls.showParticles && particleGeoRef.current?.attributes.position && particlesRef.current && particleData?.data) {\n// // // // // // //             const positions = particleGeoRef.current.attributes.position.array as Float32Array;\n// // // // // // //             const speed = currentPhysics.effective_field_velocity_scalar * resonatorControls.fieldIntensity;\n// // // // // // //             const pData = particleData.data; // Use optional chaining fixed earlier\n\n// // // // // // //             if (pData && pData.length * 3 === positions.length) {\n// // // // // // //                 const pointsMat = particlesRef.current.material as THREE.PointsMaterial;\n// // // // // // //                 if (pointsMat) { pointsMat.size = vizControls.particleSize * (1 + resonatorControls.fieldIntensity * 0.5); }\n\n// // // // // // //                 for (let i = 0; i < pData.length; i++) {\n// // // // // // //                     const data = pData[i];\n// // // // // // //                     data.u += speed * delta; // Use the single calculated speed\n// // // // // // //                     const R = vizControls.torusMajorRadius; // Use global radius\n// // // // // // //                     const r = data.r; const u = data.u; const v = data.v;\n// // // // // // //                     const bufferIndex = i * 3;\n// // // // // // //                     positions[bufferIndex]     = (R + r * Math.cos(v)) * Math.cos(u);\n// // // // // // //                     positions[bufferIndex + 1] = r * Math.sin(v);\n// // // // // // //                     positions[bufferIndex + 2] = (R + r * Math.cos(v)) * Math.sin(u);\n// // // // // // //                 }\n// // // // // // //                 particleGeoRef.current.attributes.position.needsUpdate = true;\n// // // // // // //             } else { console.warn(\"Mismatch particle data/buffer length in useFrame.\"); }\n// // // // // // //         }\n// // // // // // //     });\n\n// // // // // // //     return (\n// // // // // // //         <group ref={groupRef}>\n// // // // // // //             <RomanDodecahedron\n// // // // // // //                 ref={dodecahedronMeshRef}\n// // // // // // //                 outerRadius={finalShellParams.outerRadius}\n// // // // // // //                 thickness={finalShellParams.thickness}\n// // // // // // //                 holeBaseDiameter={finalShellParams.holeBaseDiameter}\n// // // // // // //                 holeRatio={finalShellParams.holeRatio}\n// // // // // // //                 noduleRadius={finalShellParams.noduleRadius}\n// // // // // // //                 // Let component use its Phong default\n// // // // // // //                 wireframe={vizControls.wireframe}\n// // // // // // //                 castShadow receiveShadow\n// // // // // // //                 position={[0,0,0]} rotation={[0,0,0]}\n// // // // // // //             />\n// // // // // // //             <pointLight intensity={0.5} color={0xffddcc} distance={3} decay={1.5} position={[0, 0, 0]} name=\"InternalLight\" />\n// // // // // // //             {vizControls.showParticles && (\n// // // // // // //                  <points ref={particlesRef} name=\"FieldParticles\">\n// // // // // // //                      <bufferGeometry ref={particleGeoRef} />\n// // // // // // //                      {/* Reverted PointsMaterial (single color) */}\n// // // // // // //                      <pointsMaterial\n// // // // // // //                          name=\"ParticleMaterial\" color={0x00ffff}\n// // // // // // //                          size={vizControls.particleSize} transparent opacity={0.7}\n// // // // // // //                          blending={THREE.AdditiveBlending}\n// // // // // // //                          sizeAttenuation={false}\n// // // // // // //                          map={null}\n// // // // // // //                      />\n// // // // // // //                  </points>\n// // // // // // //             )}\n// // // // // // //         </group>\n// // // // // // //     );\n// // // // // // // };\n\n// // // // // // // // --- Scene Component ---\n// // // // // // // const TemporalResonatorScene: React.FC = () => {\n// // // // // // //      return (\n// // // // // // //         <>\n// // // // // // //             <Leva collapsed={false} titleBar={{ title: 'Controls' }} />\n// // // // // // //             <Canvas\n// // // // // // //                  style={{ position: 'absolute', top: 0, left: 0, width: '100vw', height: '100vh', background: '#111122', zIndex: 0 }}\n// // // // // // //                  camera={{ position: [3, 3, 5], fov: 75 }}\n// // // // // // //                  gl={{ antialias: true }} shadows\n// // // // // // //             >\n// // // // // // //                  {/* Lighting Setup */}\n// // // // // // //                  <ambientLight intensity={0.4} />\n// // // // // // //                  <hemisphereLight groundColor={0x404040} intensity={0.8} />\n// // // // // // //                  <directionalLight\n// // // // // // //                      position={[5, 10, 7.5]} intensity={1.2} castShadow\n// // // // // // //                      shadow-mapSize-width={1024} shadow-mapSize-height={1024}\n// // // // // // //                      shadow-camera-far={25} shadow-camera-left={-10} shadow-camera-right={10}\n// // // // // // //                      shadow-camera-top={10} shadow-camera-bottom={-10}\n// // // // // // //                  />\n// // // // // // //                  <ErrorBoundary>\n// // // // // // //                      <Suspense fallback={<LoadingPlaceholder />}>\n// // // // // // //                           <ResonatorSimulation />\n// // // // // // //                      </Suspense>\n// // // // // // //                  </ErrorBoundary>\n// // // // // // //                  <Controls />\n// // // // // // //                  {/* <axesHelper args={[5]} /> */}\n// // // // // // //             </Canvas>\n// // // // // // //         </>\n// // // // // // //      );\n// // // // // // //  };\n// // // // // // // // --- Loading Placeholder Component ---\n// // // // // // // const LoadingPlaceholder: React.FC = () => {\n// // // // // // //     return (\n// // // // // // //         <mesh>\n// // // // // // //             <boxGeometry args={[0.1, 0.1, 0.1]} />\n// // // // // // //             <meshBasicMaterial color=\"orange\" wireframe attach=\"material\" />\n// // // // // // //         </mesh>\n// // // // // // //     );\n// // // // // // // };\n\n// // // // // // // export default TemporalResonatorScene;\n\n// // // // // // // // // === Full Code: TemporalResonatorScene_V2_CSG_Fixes_13_Detail.tsx ===\n\n// // // // // // // // import React, { useRef, useEffect, useMemo, Suspense, useState } from 'react';\n// // // // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // // // // import * as THREE from 'three';\n// // // // // // // // import ErrorBoundary from './errorBoundary'; // Adjust path if needed\n// // // // // // // // import { useControls, Leva } from 'leva';\n// // // // // // // // import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\n// // // // // // // // import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n\n// // // // // // // // // --- BVH / CSG Setup ---\n// // // // // // // // try {\n// // // // // // // //     // Assign prototypes for BVH computation\n// // // // // // // //     (THREE.BufferGeometry.prototype as any).computeBoundsTree = computeBoundsTree;\n// // // // // // // //     (THREE.BufferGeometry.prototype as any).disposeBoundsTree = disposeBoundsTree;\n// // // // // // // //     (THREE.Mesh.prototype as any).raycast = acceleratedRaycast;\n// // // // // // // // } catch (error) {\n// // // // // // // //     console.error(\"Error setting up BVH extensions:\", error);\n// // // // // // // // }\n// // // // // // // // const csgEvaluator = new Evaluator();\n// // // // // // // // csgEvaluator.useGroups = true; // Use groups for efficiency with multiple operations\n// // // // // // // // extend({ OrbitControls }); // Extend R3F for OrbitControls\n\n// // // // // // // // // --- Constants ---\n// // // // // // // // const PHI = (1 + Math.sqrt(5)) / 2;\n// // // // // // // // const INV_PHI = 1 / PHI;\n\n// // // // // // // // // --- Helper: Get Dodecahedron Math Data ---\n// // // // // // // // function getDodecahedronData(radius: number): { vertices: THREE.Vector3[]; faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] } {\n// // // // // // // //     console.log(`--- Calculating Dodecahedron Data for radius: ${radius} ---`);\n// // // // // // // //     // Validate input radius\n// // // // // // // //     if (typeof radius !== 'number' || radius <= 0 || !Number.isFinite(radius)) {\n// // // // // // // //         console.error(\"!!! Invalid radius passed to getDodecahedronData:\", radius);\n// // // // // // // //         throw new Error(\"Invalid radius provided to getDodecahedronData\");\n// // // // // // // //     }\n\n// // // // // // // //     // Use a Map to ensure vertex uniqueness based on precise coordinates\n// // // // // // // //     const uniqueVerticesMap = new Map<string, THREE.Vector3>();\n// // // // // // // //     // Define base coordinates for dodecahedron vertices\n// // // // // // // //     const coords = [\n// // // // // // // //         [1, 1, 1], [-1, 1, 1], [1, -1, 1], [-1, -1, 1], [1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1],\n// // // // // // // //         [0, PHI, INV_PHI], [0, -PHI, INV_PHI], [0, PHI, -INV_PHI], [0, -PHI, -INV_PHI],\n// // // // // // // //         [INV_PHI, 0, PHI], [-INV_PHI, 0, PHI], [INV_PHI, 0, -PHI], [-INV_PHI, 0, -PHI],\n// // // // // // // //         [PHI, INV_PHI, 0], [-PHI, INV_PHI, 0], [PHI, -INV_PHI, 0], [-PHI, -INV_PHI, 0]\n// // // // // // // //     ];\n// // // // // // // //     // Calculate the scaling factor to match the desired radius\n// // // // // // // //     const distOriginToVertex = Math.sqrt(PHI * PHI + INV_PHI * INV_PHI);\n// // // // // // // //     const scale = radius / distOriginToVertex;\n// // // // // // // //     if (!Number.isFinite(scale) || scale === 0) { throw new Error(\"Invalid scale factor\"); }\n\n// // // // // // // //     // Populate the map with unique, scaled vertices\n// // // // // // // //     coords.forEach(v => {\n// // // // // // // //         const x = v[0] * scale; const y = v[1] * scale; const z = v[2] * scale;\n// // // // // // // //         const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`; // Key for uniqueness\n// // // // // // // //         if (!uniqueVerticesMap.has(key)) { uniqueVerticesMap.set(key, new THREE.Vector3(x, y, z)); }\n// // // // // // // //     });\n// // // // // // // //     const vertices = Array.from(uniqueVerticesMap.values()); // Get unique vertices\n\n// // // // // // // //     // Calculate face centers and normals using the dual icosahedron's vertices\n// // // // // // // //     const faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] = [];\n// // // // // // // //     const icoVerts = [ [0, 1, PHI], [0, -1, PHI], [0, 1, -PHI], [0, -1, -PHI], [1, PHI, 0], [-1, PHI, 0], [1, -PHI, 0], [-1, -PHI, 0], [PHI, 0, 1], [-PHI, 0, 1], [PHI, 0, -1], [-PHI, 0, -1] ];\n// // // // // // // //     // Estimate face center distance relative to the vertex distance (adjust factor if needed)\n// // // // // // // //     const faceCenterDist = radius * 1.53 / distOriginToVertex;\n// // // // // // // //     icoVerts.forEach(v => {\n// // // // // // // //         const normal = new THREE.Vector3(v[0], v[1], v[2]).normalize();\n// // // // // // // //         const center = normal.clone().multiplyScalar(faceCenterDist);\n// // // // // // // //         faceData.push({ center, normal });\n// // // // // // // //     });\n\n// // // // // // // //     // Final validation of generated data counts\n// // // // // // // //     if (vertices.length !== 20 || faceData.length !== 12) {\n// // // // // // // //         console.error(\"!!! Vertex/Face generation failed. Vertices:\", vertices, \"Faces:\", faceData);\n// // // // // // // //         throw new Error(`Incorrect math data count: ${vertices.length} vertices, ${faceData.length} faces`);\n// // // // // // // //     }\n// // // // // // // //     console.log(`--- Generated ${vertices.length} vertices, ${faceData.length} faces. ---`);\n// // // // // // // //     return { vertices, faceData };\n// // // // // // // // }\n\n// // // // // // // // // --- Controls Component ---\n// // // // // // // // const Controls: React.FC = () => {\n// // // // // // // //      const { camera, gl } = useThree();\n// // // // // // // //      const controlsRef = useRef<OrbitControls>(null);\n// // // // // // // //      useEffect(() => {\n// // // // // // // //          const controls = new OrbitControls(camera, gl.domElement);\n// // // // // // // //          controls.enableDamping = true;\n// // // // // // // //          controls.target.set(0, 0, 0); // Target the origin (where the group is)\n// // // // // // // //          (controlsRef as React.MutableRefObject<OrbitControls>).current = controls;\n// // // // // // // //          return () => { controls.dispose(); }; // Cleanup on unmount\n// // // // // // // //      }, [camera, gl]);\n// // // // // // // //      // Update controls in the animation loop for damping\n// // // // // // // //      useFrame(() => { controlsRef.current?.update(); });\n// // // // // // // //      return null;\n// // // // // // // // };\n\n// // // // // // // // // --- Roman Dodecahedron CSG Component ---\n// // // // // // // // interface RomanDodecahedronProps {\n// // // // // // // //     outerRadius: number; thickness: number; holeBaseDiameter: number;\n// // // // // // // //     holeRatio: number; noduleRadius: number; material?: THREE.Material;\n// // // // // // // //     wireframe?: boolean; [key: string]: any;\n// // // // // // // // }\n// // // // // // // // const RomanDodecahedron: React.FC<RomanDodecahedronProps> = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>(\n// // // // // // // //     ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, wireframe = false, ...props }, ref) => {\n\n// // // // // // // //     // State to hold the geometry calculated after mount/prop changes\n// // // // // // // //     const [calculatedGeometry, setCalculatedGeometry] = useState<THREE.BufferGeometry | null>(null);\n\n// // // // // // // //     // Effect to perform CSG calculation\n// // // // // // // //     useEffect(() => {\n// // // // // // // //         console.log(`useEffect Check: outerRadius=${outerRadius} (${typeof outerRadius}), thickness=${thickness}, ...`);\n// // // // // // // //         // Guard against invalid props (potentially from initial Leva state)\n// // // // // // // //         if ( typeof outerRadius !== 'number' || outerRadius <= 0 || !Number.isFinite(outerRadius) || typeof thickness !== 'number' || thickness <= 0 || !Number.isFinite(thickness) || typeof holeBaseDiameter !== 'number' || holeBaseDiameter <= 0 || !Number.isFinite(holeBaseDiameter) || typeof holeRatio !== 'number' || holeRatio <= 0 || !Number.isFinite(holeRatio) || typeof noduleRadius !== 'number' || noduleRadius <= 0 || !Number.isFinite(noduleRadius) ) {\n// // // // // // // //             console.log(`--> Skipping CSG calculation in useEffect: Invalid props detected.`);\n// // // // // // // //             setCalculatedGeometry(null); // Ensure geometry is null if props invalid\n// // // // // // // //             return; // Exit effect\n// // // // // // // //         }\n\n// // // // // // // //         // --- **** Increased Detail Level **** ---\n// // // // // // // //         const detailLevel = 2; // Increased from 1\n// // // // // // // //         console.log(`Calculating CSG Geometry (Detail=${detailLevel}) for radius: ${outerRadius}`);\n// // // // // // // //         // --- **** **** **** **** **** **** **** ---\n\n// // // // // // // //         let geometry: THREE.BufferGeometry | null = null;\n// // // // // // // //         let tempGeoList: THREE.BufferGeometry[] = []; // Track temp geos for disposal\n\n// // // // // // // //         try {\n// // // // // // // //             // Get mathematically correct positions/normals\n// // // // // // // //             const { vertices: mathVertices, faceData: mathFaceData } = getDodecahedronData(outerRadius);\n\n// // // // // // // //             // Create base shell using higher detail\n// // // // // // // //             const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, detailLevel); outerDodecGeo.computeBoundsTree(); tempGeoList.push(outerDodecGeo);\n// // // // // // // //             const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, detailLevel); innerDodecGeo.computeBoundsTree(); tempGeoList.push(innerDodecGeo);\n// // // // // // // //             let outerBrush = new Brush(outerDodecGeo); let innerBrush = new Brush(innerDodecGeo); innerBrush.updateMatrixWorld();\n// // // // // // // //             let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n\n// // // // // // // //             // Create and subtract holes\n// // // // // // // //             const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * (holeRatio ** i));\n// // // // // // // //             const cylinderHeight = thickness * 3.1; // Ensure cylinder goes through shell\n// // // // // // // //             // Cylinder detail doesn't need to match base detail\n// // // // // // // //             const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16); cylinderGeo.rotateX(Math.PI / 2); cylinderGeo.computeBoundsTree(); tempGeoList.push(cylinderGeo);\n// // // // // // // //             const tempQuat = new THREE.Quaternion();\n// // // // // // // //             mathFaceData.forEach((face, index) => {\n// // // // // // // //                 const holeRadius = holeDiameters[index] / 2; if (!holeRadius || holeRadius <= 0) return;\n// // // // // // // //                 const holeBrush = new Brush(cylinderGeo); holeBrush.scale.set(holeRadius, holeRadius, 1);\n// // // // // // // //                 tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), face.normal); holeBrush.quaternion.copy(tempQuat);\n// // // // // // // //                 holeBrush.position.copy(face.center); holeBrush.updateMatrixWorld();\n// // // // // // // //                 shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION);\n// // // // // // // //             });\n\n// // // // // // // //             // Create and add nodules (keep low detail)\n// // // // // // // //             const noduleGeo = new THREE.SphereGeometry(noduleRadius, 6, 6); noduleGeo.computeBoundsTree(); tempGeoList.push(noduleGeo);\n// // // // // // // //             mathVertices.forEach(vertexPos => {\n// // // // // // // //                 const noduleBrush = new Brush(noduleGeo); noduleBrush.position.copy(vertexPos);\n// // // // // // // //                 noduleBrush.updateMatrixWorld(); shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION);\n// // // // // // // //             });\n\n// // // // // // // //             // Finalize geometry\n// // // // // // // //             geometry = shellBrush.geometry;\n// // // // // // // //             geometry.computeVertexNormals(); // Crucial for lighting!\n// // // // // // // //             geometry.center(); // Center the final composite shape\n// // // // // // // //             console.log(\"CSG Calculation Complete.\");\n\n// // // // // // // //         } catch (error) {\n// // // // // // // //             console.error(\"CSG Error in useEffect:\", error);\n// // // // // // // //             geometry = null; // Ensure null on error\n// // // // // // // //         } finally {\n// // // // // // // //             // Clean up intermediate geometries used for CSG brushes\n// // // // // // // //             tempGeoList.forEach(g => g.dispose());\n// // // // // // // //             console.log(`Disposed ${tempGeoList.length} temporary CSG geometries.`);\n// // // // // // // //         }\n\n// // // // // // // //         // Update state with the calculated geometry (or null)\n// // // // // // // //         setCalculatedGeometry(geometry);\n\n// // // // // // // //         // Effect cleanup function: Dispose the *final* geometry when effect re-runs or unmounts\n// // // // // // // //         return () => {\n// // // // // // // //             if (geometry && typeof geometry.dispose === 'function') {\n// // // // // // // //                 geometry.dispose();\n// // // // // // // //                 console.log(\"Disposed final CSG geometry from useEffect cleanup.\");\n// // // // // // // //             }\n// // // // // // // //         };\n// // // // // // // //     }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]); // Dependencies\n\n// // // // // // // //     // Memoize the material based on props, using Phong default\n// // // // // // // //     const meshMaterial = useMemo(() => {\n// // // // // // // //         let baseMaterial: THREE.Material;\n// // // // // // // //         if (material instanceof THREE.Material) {\n// // // // // // // //              baseMaterial = material.clone(); baseMaterial.side = THREE.DoubleSide;\n// // // // // // // //         } else {\n// // // // // // // //             baseMaterial = new THREE.MeshPhongMaterial({ color: 0xB87333, side: THREE.DoubleSide, specular: 0x444444, shininess: 40, name: \"DefaultPhongCopper\" });\n// // // // // // // //         }\n// // // // // // // //         if ('wireframe' in baseMaterial) { (baseMaterial as any).wireframe = wireframe; }\n// // // // // // // //         baseMaterial.side = THREE.DoubleSide; // Ensure double side\n// // // // // // // //         return baseMaterial;\n// // // // // // // //     }, [material, wireframe]);\n\n// // // // // // // //     // Effect to dispose the memoized material\n// // // // // // // //     useEffect(() => { return () => { meshMaterial?.dispose(); } }, [meshMaterial]);\n\n// // // // // // // //     // Don't render if geometry calculation failed or hasn't completed\n// // // // // // // //     if (!calculatedGeometry) { return null; }\n\n// // // // // // // //     // Render the mesh using calculated geometry and memoized material\n// // // // // // // //     return <mesh ref={ref} geometry={calculatedGeometry} material={meshMaterial} {...props} />;\n// // // // // // // // });\n\n// // // // // // // // // --- Physics State Interface ---\n// // // // // // // // interface PhysicsState {\n// // // // // // // //     shell_angular_velocity_scalar: number;\n// // // // // // // //     effective_field_velocity_scalar: number;\n// // // // // // // //     current_torque_scalar: number;\n// // // // // // // // }\n\n// // // // // // // // // --- Main Simulation Component ---\n// // // // // // // // const ResonatorSimulation: React.FC = () => {\n// // // // // // // //     // Refs for scene objects\n// // // // // // // //     const groupRef = useRef<THREE.Group>(null!);\n// // // // // // // //     const dodecahedronMeshRef = useRef<THREE.Mesh>(null!);\n// // // // // // // //     const particlesRef = useRef<THREE.Points>(null!);\n// // // // // // // //     const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // // // // // // //     // Leva controls setup\n// // // // // // // //     const resonatorControls = useControls('Resonator Controls', { baseFieldSpeed: 1.0, fieldIntensity: 1.0, k_drag: 0.5, inertiaScale: 1.0, damping: 0.1, k_feedback: -0.2 });\n// // // // // // // //     const shellControls = useControls('Shell Geometry', { outerRadius: 1.0, thickness: 0.05, holeBaseDiameter: 0.1, holeRatio: 1.2, noduleRadius: 0.1 });\n// // // // // // // //     const vizControls = useControls('Visualization', { particleCount: 1000, particleSize: 0.05, torusMajorRadius: 1.5, torusMinorRadius: 0.5, showParticles: true, wireframe: false });\n\n// // // // // // // //     // Ensure shell parameters are valid numbers, falling back to defaults\n// // // // // // // //     const defaultShellParams = useMemo(() => ({ outerRadius: 1.0, thickness: 0.05, holeBaseDiameter: 0.1, holeRatio: 1.2, noduleRadius: 0.1 }), []);\n// // // // // // // //     const finalShellParams = useMemo(() => ({\n// // // // // // // //         outerRadius: (typeof shellControls.outerRadius === 'number' && Number.isFinite(shellControls.outerRadius)) ? shellControls.outerRadius : defaultShellParams.outerRadius,\n// // // // // // // //         thickness: (typeof shellControls.thickness === 'number' && Number.isFinite(shellControls.thickness)) ? shellControls.thickness : defaultShellParams.thickness,\n// // // // // // // //         holeBaseDiameter: (typeof shellControls.holeBaseDiameter === 'number' && Number.isFinite(shellControls.holeBaseDiameter)) ? shellControls.holeBaseDiameter : defaultShellParams.holeBaseDiameter,\n// // // // // // // //         holeRatio: (typeof shellControls.holeRatio === 'number' && Number.isFinite(shellControls.holeRatio)) ? shellControls.holeRatio : defaultShellParams.holeRatio,\n// // // // // // // //         noduleRadius: (typeof shellControls.noduleRadius === 'number' && Number.isFinite(shellControls.noduleRadius)) ? shellControls.noduleRadius : defaultShellParams.noduleRadius,\n// // // // // // // //     }), [shellControls, defaultShellParams]);\n\n// // // // // // // //     // Calculate effective inertia\n// // // // // // // //     const effectiveInertia = useMemo(() => resonatorControls.inertiaScale * (finalShellParams.outerRadius ** 5 - (finalShellParams.outerRadius - finalShellParams.thickness) ** 5) / finalShellParams.outerRadius ** 5, [resonatorControls.inertiaScale, finalShellParams.outerRadius, finalShellParams.thickness]);\n\n// // // // // // // //     // Initialize physics state using a ref\n// // // // // // // //     const physicsState = useRef<PhysicsState>({\n// // // // // // // //          shell_angular_velocity_scalar: 0.0,\n// // // // // // // //          effective_field_velocity_scalar: resonatorControls.baseFieldSpeed || 0, // Use Leva value or 0\n// // // // // // // //          current_torque_scalar: 0.0,\n// // // // // // // //     });\n\n// // // // // // // //     // Memoize particle data creation\n// // // // // // // //     const particleData = useMemo<{ positions: Float32Array; data: any[] }>(() => {\n// // // // // // // //         console.log(`Creating particle data for count: ${vizControls.particleCount}`);\n// // // // // // // //         try {\n// // // // // // // //              const data = []; const positions = new Float32Array(vizControls.particleCount * 3);\n// // // // // // // //              for (let i = 0; i < vizControls.particleCount; i++) {\n// // // // // // // //                  const u = Math.random() * Math.PI * 2; const v = Math.random() * Math.PI * 2; const R = vizControls.torusMajorRadius; const r = vizControls.torusMinorRadius; const randR = R + (Math.random() - 0.5) * 0.2; const randr = r * Math.sqrt(Math.random());\n// // // // // // // //                  positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u); positions[i * 3 + 1] = randr * Math.sin(v); positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u);\n// // // // // // // //                  data.push({ u, v, R, r: randr, fieldIndex: 0 }); }\n// // // // // // // //              return { positions, data };\n// // // // // // // //         } catch (error) { console.error(\"Error creating particle data:\", error); return { positions: new Float32Array(0), data: [] }; }\n// // // // // // // //      }, [vizControls.particleCount, vizControls.torusMajorRadius, vizControls.torusMinorRadius]);\n\n// // // // // // // //     // Effect to manage the particle buffer attribute\n// // // // // // // //      useEffect(() => {\n// // // // // // // //          if (particleGeoRef.current && particleData?.positions) {\n// // // // // // // //              const existingAttribute = particleGeoRef.current.getAttribute('position') as THREE.BufferAttribute | undefined;\n// // // // // // // //              if (!existingAttribute || existingAttribute.array.length !== particleData.positions.length) {\n// // // // // // // //                  particleGeoRef.current.setAttribute('position', new THREE.BufferAttribute(particleData.positions, 3, false));\n// // // // // // // //                  console.log(`Particle buffer attribute CREATED/REPLACED (Count: ${particleData.positions.length / 3}).`);\n// // // // // // // //              }\n// // // // // // // //          } else { if (particleGeoRef.current?.getAttribute('position')) { particleGeoRef.current.deleteAttribute('position'); console.log(\"Particle buffer attribute removed.\"); } }\n// // // // // // // //      }, [particleData]);\n\n// // // // // // // //     // Main animation loop\n// // // // // // // //     useFrame((state, delta) => {\n// // // // // // // //         const currentPhysics = physicsState.current;\n\n// // // // // // // //         // V1 Physics Calculations (Scalar Y-axis rotation)\n// // // // // // // //         const relative_speed = currentPhysics.effective_field_velocity_scalar - currentPhysics.shell_angular_velocity_scalar;\n// // // // // // // //         currentPhysics.current_torque_scalar = resonatorControls.k_drag * resonatorControls.fieldIntensity * relative_speed;\n// // // // // // // //         const angular_acceleration = effectiveInertia > 0 ? (currentPhysics.current_torque_scalar / effectiveInertia) : 0;\n// // // // // // // //         currentPhysics.shell_angular_velocity_scalar += angular_acceleration * delta;\n// // // // // // // //         currentPhysics.shell_angular_velocity_scalar *= (1 - resonatorControls.damping * delta); // Apply damping\n// // // // // // // //         currentPhysics.effective_field_velocity_scalar = resonatorControls.baseFieldSpeed + resonatorControls.k_feedback * currentPhysics.shell_angular_velocity_scalar; // Feedback\n\n// // // // // // // //         // Rotate the Group containing the dodecahedron\n// // // // // // // //         if (groupRef.current) {\n// // // // // // // //              // console.log(\"Ang Vel:\", currentPhysics.shell_angular_velocity_scalar.toFixed(3)); // DEBUG Rotation\n// // // // // // // //              groupRef.current.rotation.y += currentPhysics.shell_angular_velocity_scalar * delta;\n// // // // // // // //         }\n\n// // // // // // // //         // Update Emissive (Only if using Standard/Physical material - Phong doesn't have it)\n// // // // // // // //         // If we stick with Phong, this block won't execute.\n// // // // // // // //         if (dodecahedronMeshRef.current) {\n// // // // // // // //              const currentMaterial = dodecahedronMeshRef.current.material;\n// // // // // // // //              if (currentMaterial instanceof THREE.MeshStandardMaterial || currentMaterial instanceof THREE.MeshPhysicalMaterial) {\n// // // // // // // //                  if (currentMaterial.emissive) { /* ... set emissive ... */ }\n// // // // // // // //              }\n// // // // // // // //         }\n\n// // // // // // // //         // Particle Field Update\n// // // // // // // //         if (vizControls.showParticles && particleGeoRef.current?.attributes.position && particlesRef.current && particleData?.data) {\n// // // // // // // //             const positions = particleGeoRef.current.attributes.position.array as Float32Array;\n// // // // // // // //             const speed = currentPhysics.effective_field_velocity_scalar * resonatorControls.fieldIntensity; // Use speed\n// // // // // // // //             const pData = particleData.data;\n\n// // // // // // // //             if (pData.length * 3 === positions.length) { // Check array lengths match\n// // // // // // // //                 const pointsMat = particlesRef.current.material as THREE.PointsMaterial;\n// // // // // // // //                 if (pointsMat) { pointsMat.size = vizControls.particleSize * (1 + resonatorControls.fieldIntensity * 0.5); }\n\n// // // // // // // //                 for (let i = 0; i < pData.length; i++) {\n// // // // // // // //                     const data = pData[i];\n// // // // // // // //                     data.u += speed * delta; // Update angle using speed\n// // // // // // // //                     const R = data.R; const r = data.r; const u = data.u; const v = data.v;\n// // // // // // // //                     positions[i * 3]     = (R + r * Math.cos(v)) * Math.cos(u);\n// // // // // // // //                     positions[i * 3 + 1] = r * Math.sin(v);\n// // // // // // // //                     positions[i * 3 + 2] = (R + r * Math.cos(v)) * Math.sin(u);\n// // // // // // // //                 }\n// // // // // // // //                 // Mark buffer attribute for update\n// // // // // // // //                 particleGeoRef.current.attributes.position.needsUpdate = true;\n// // // // // // // //             } else { console.warn(\"Mismatch between particle data length and buffer length in useFrame.\"); }\n// // // // // // // //         }\n// // // // // // // //     });\n\n// // // // // // // //     return (\n// // // // // // // //         // Group centers the object and handles rotation\n// // // // // // // //         <group ref={groupRef}>\n// // // // // // // //             <RomanDodecahedron\n// // // // // // // //                 ref={dodecahedronMeshRef} // Ref to the mesh itself\n// // // // // // // //                 outerRadius={finalShellParams.outerRadius}\n// // // // // // // //                 thickness={finalShellParams.thickness}\n// // // // // // // //                 holeBaseDiameter={finalShellParams.holeBaseDiameter}\n// // // // // // // //                 holeRatio={finalShellParams.holeRatio}\n// // // // // // // //                 noduleRadius={finalShellParams.noduleRadius}\n// // // // // // // //                 // No material prop passed, will use internal default (Phong)\n// // // // // // // //                 wireframe={vizControls.wireframe} // Control wireframe via Leva\n// // // // // // // //                 castShadow receiveShadow\n// // // // // // // //                 // Mesh position/rotation is relative to the group (should be 0)\n// // // // // // // //                 position={[0,0,0]}\n// // // // // // // //                 rotation={[0,0,0]}\n// // // // // // // //             />\n// // // // // // // //             {/* Point light inside the group to illuminate interior */}\n// // // // // // // //             <pointLight intensity={0.5} color={0xffddcc} distance={3} decay={1.5} position={[0, 0, 0]} name=\"InternalLight\" />\n\n// // // // // // // //             {/* Particles are siblings of the group, not children */}\n// // // // // // // //             {vizControls.showParticles && (\n// // // // // // // //                  <points ref={particlesRef} name=\"FieldParticles\">\n// // // // // // // //                      <bufferGeometry ref={particleGeoRef} />\n// // // // // // // //                      <pointsMaterial\n// // // // // // // //                          name=\"ParticleMaterial\" color={0x00ffff}\n// // // // // // // //                          size={vizControls.particleSize} transparent opacity={0.7}\n// // // // // // // //                          blending={THREE.AdditiveBlending}\n// // // // // // // //                          sizeAttenuation={false} // Keep false for consistent size\n// // // // // // // //                          map={null}\n// // // // // // // //                      />\n// // // // // // // //                  </points>\n// // // // // // // //             )}\n// // // // // // // //         </group>\n// // // // // // // //     );\n// // // // // // // // };\n\n// // // // // // // // // --- Scene Component ---\n// // // // // // // // const TemporalResonatorScene: React.FC = () => {\n// // // // // // // //      return (\n// // // // // // // //         <>\n// // // // // // // //             {/* Leva GUI Panel */}\n// // // // // // // //             <Leva collapsed={false} titleBar={{ title: 'Controls' }} />\n// // // // // // // //             {/* Main Canvas */}\n// // // // // // // //             <Canvas\n// // // // // // // //                  style={{ position: 'absolute', top: 0, left: 0, width: '100vw', height: '100vh', background: '#111122', zIndex: 0 }}\n// // // // // // // //                  camera={{ position: [3, 3, 5], fov: 75 }}\n// // // // // // // //                  gl={{ antialias: true }} shadows // Enable shadows\n// // // // // // // //             >\n// // // // // // // //                  {/* Lighting Setup */}\n// // // // // // // //                  <ambientLight intensity={0.4} />\n// // // // // // // //                  <hemisphereLight groundColor={0x404040} intensity={0.8} />\n// // // // // // // //                  <directionalLight\n// // // // // // // //                      position={[5, 10, 7.5]} intensity={1.2} castShadow\n// // // // // // // //                      shadow-mapSize-width={1024} shadow-mapSize-height={1024}\n// // // // // // // //                      shadow-camera-far={25} shadow-camera-left={-10} shadow-camera-right={10}\n// // // // // // // //                      shadow-camera-top={10} shadow-camera-bottom={-10}\n// // // // // // // //                  />\n// // // // // // // //                  {/* Error Boundary and Suspense for loading */}\n// // // // // // // //                  <ErrorBoundary>\n// // // // // // // //                      <Suspense fallback={<LoadingPlaceholder />}>\n// // // // // // // //                           <ResonatorSimulation />\n// // // // // // // //                      </Suspense>\n// // // // // // // //                  </ErrorBoundary>\n// // // // // // // //                  {/* Camera Controls */}\n// // // // // // // //                  <Controls />\n// // // // // // // //                  {/* Optional Debug Helpers */}\n// // // // // // // //                  {/* <axesHelper args={[5]} /> */}\n// // // // // // // //                  {/* <gridHelper args={[10, 10]} /> */}\n// // // // // // // //             </Canvas>\n// // // // // // // //         </>\n// // // // // // // //      );\n// // // // // // // //  };\n\n// // // // // // // // // --- Loading Placeholder Component ---\n// // // // // // // // const LoadingPlaceholder: React.FC = () => {\n// // // // // // // //     // Simple visual indicator while CSG calculates\n// // // // // // // //     return (\n// // // // // // // //         <mesh>\n// // // // // // // //             <boxGeometry args={[0.1, 0.1, 0.1]} />\n// // // // // // // //             <meshBasicMaterial color=\"orange\" wireframe attach=\"material\" />\n// // // // // // // //         </mesh>\n// // // // // // // //     );\n// // // // // // // // };\n\n// // // // // // // // export default TemporalResonatorScene;\n\n// // // // // // // // // === Full Code: TemporalResonatorScene_V2_CSG_Fixes_12_Complete.tsx ===\n\n// // // // // // // // import React, { useRef, useEffect, useMemo, Suspense, useState } from 'react';\n// // // // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // // // // import * as THREE from 'three';\n// // // // // // // // import ErrorBoundary from './errorBoundary'; // Adjust path if needed\n// // // // // // // // import { useControls, Leva } from 'leva';\n// // // // // // // // import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\n// // // // // // // // import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n\n// // // // // // // // // --- BVH / CSG Setup ---\n// // // // // // // // try {\n// // // // // // // //     // Assign prototypes for BVH computation\n// // // // // // // //     (THREE.BufferGeometry.prototype as any).computeBoundsTree = computeBoundsTree;\n// // // // // // // //     (THREE.BufferGeometry.prototype as any).disposeBoundsTree = disposeBoundsTree;\n// // // // // // // //     (THREE.Mesh.prototype as any).raycast = acceleratedRaycast;\n// // // // // // // // } catch (error) {\n// // // // // // // //     console.error(\"Error setting up BVH extensions:\", error);\n// // // // // // // // }\n// // // // // // // // const csgEvaluator = new Evaluator();\n// // // // // // // // csgEvaluator.useGroups = true; // Use groups for efficiency with multiple operations\n// // // // // // // // extend({ OrbitControls }); // Extend R3F for OrbitControls\n\n// // // // // // // // // --- Constants ---\n// // // // // // // // const PHI = (1 + Math.sqrt(5)) / 2;\n// // // // // // // // const INV_PHI = 1 / PHI;\n\n// // // // // // // // // --- Helper: Get Dodecahedron Math Data ---\n// // // // // // // // function getDodecahedronData(radius: number): { vertices: THREE.Vector3[]; faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] } {\n// // // // // // // //     console.log(`--- Calculating Dodecahedron Data for radius: ${radius} ---`);\n// // // // // // // //     // Validate input radius\n// // // // // // // //     if (typeof radius !== 'number' || radius <= 0 || !Number.isFinite(radius)) {\n// // // // // // // //         console.error(\"!!! Invalid radius passed to getDodecahedronData:\", radius);\n// // // // // // // //         throw new Error(\"Invalid radius provided to getDodecahedronData\");\n// // // // // // // //     }\n\n// // // // // // // //     // Use a Map to ensure vertex uniqueness based on precise coordinates\n// // // // // // // //     const uniqueVerticesMap = new Map<string, THREE.Vector3>();\n// // // // // // // //     // Define base coordinates for dodecahedron vertices\n// // // // // // // //     const coords = [\n// // // // // // // //         [1, 1, 1], [-1, 1, 1], [1, -1, 1], [-1, -1, 1], [1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1],\n// // // // // // // //         [0, PHI, INV_PHI], [0, -PHI, INV_PHI], [0, PHI, -INV_PHI], [0, -PHI, -INV_PHI],\n// // // // // // // //         [INV_PHI, 0, PHI], [-INV_PHI, 0, PHI], [INV_PHI, 0, -PHI], [-INV_PHI, 0, -PHI],\n// // // // // // // //         [PHI, INV_PHI, 0], [-PHI, INV_PHI, 0], [PHI, -INV_PHI, 0], [-PHI, -INV_PHI, 0]\n// // // // // // // //     ];\n// // // // // // // //     // Calculate the scaling factor to match the desired radius\n// // // // // // // //     const distOriginToVertex = Math.sqrt(PHI * PHI + INV_PHI * INV_PHI);\n// // // // // // // //     const scale = radius / distOriginToVertex;\n// // // // // // // //     if (!Number.isFinite(scale) || scale === 0) { throw new Error(\"Invalid scale factor\"); }\n\n// // // // // // // //     // Populate the map with unique, scaled vertices\n// // // // // // // //     coords.forEach(v => {\n// // // // // // // //         const x = v[0] * scale; const y = v[1] * scale; const z = v[2] * scale;\n// // // // // // // //         const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`; // Key for uniqueness\n// // // // // // // //         if (!uniqueVerticesMap.has(key)) { uniqueVerticesMap.set(key, new THREE.Vector3(x, y, z)); }\n// // // // // // // //     });\n// // // // // // // //     const vertices = Array.from(uniqueVerticesMap.values()); // Get unique vertices\n\n// // // // // // // //     // Calculate face centers and normals using the dual icosahedron's vertices\n// // // // // // // //     const faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] = [];\n// // // // // // // //     const icoVerts = [ [0, 1, PHI], [0, -1, PHI], [0, 1, -PHI], [0, -1, -PHI], [1, PHI, 0], [-1, PHI, 0], [1, -PHI, 0], [-1, -PHI, 0], [PHI, 0, 1], [-PHI, 0, 1], [PHI, 0, -1], [-PHI, 0, -1] ];\n// // // // // // // //     // Estimate face center distance relative to the vertex distance (adjust factor if needed)\n// // // // // // // //     const faceCenterDist = radius * 1.53 / distOriginToVertex;\n// // // // // // // //     icoVerts.forEach(v => {\n// // // // // // // //         const normal = new THREE.Vector3(v[0], v[1], v[2]).normalize();\n// // // // // // // //         const center = normal.clone().multiplyScalar(faceCenterDist);\n// // // // // // // //         faceData.push({ center, normal });\n// // // // // // // //     });\n\n// // // // // // // //     // Final validation of generated data counts\n// // // // // // // //     if (vertices.length !== 20 || faceData.length !== 12) {\n// // // // // // // //         console.error(\"!!! Vertex/Face generation failed. Vertices:\", vertices, \"Faces:\", faceData);\n// // // // // // // //         throw new Error(`Incorrect math data count: ${vertices.length} vertices, ${faceData.length} faces`);\n// // // // // // // //     }\n// // // // // // // //     console.log(`--- Generated ${vertices.length} vertices, ${faceData.length} faces. ---`);\n// // // // // // // //     return { vertices, faceData };\n// // // // // // // // }\n\n// // // // // // // // // --- Controls Component ---\n// // // // // // // // const Controls: React.FC = () => {\n// // // // // // // //      const { camera, gl } = useThree();\n// // // // // // // //      const controlsRef = useRef<OrbitControls>(null);\n// // // // // // // //      useEffect(() => {\n// // // // // // // //          const controls = new OrbitControls(camera, gl.domElement);\n// // // // // // // //          controls.enableDamping = true;\n// // // // // // // //          controls.target.set(0, 0, 0); // Target the origin (where the group is)\n// // // // // // // //          (controlsRef as React.MutableRefObject<OrbitControls>).current = controls;\n// // // // // // // //          return () => { controls.dispose(); }; // Cleanup on unmount\n// // // // // // // //      }, [camera, gl]);\n// // // // // // // //      // Update controls in the animation loop for damping\n// // // // // // // //      useFrame(() => { controlsRef.current?.update(); });\n// // // // // // // //      return null;\n// // // // // // // // };\n\n// // // // // // // // // --- Roman Dodecahedron CSG Component ---\n// // // // // // // // interface RomanDodecahedronProps {\n// // // // // // // //     outerRadius: number; thickness: number; holeBaseDiameter: number;\n// // // // // // // //     holeRatio: number; noduleRadius: number; material?: THREE.Material;\n// // // // // // // //     wireframe?: boolean; [key: string]: any;\n// // // // // // // // }\n// // // // // // // // const RomanDodecahedron: React.FC<RomanDodecahedronProps> = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>(\n// // // // // // // //     ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, wireframe = false, ...props }, ref) => {\n\n// // // // // // // //     // State to hold the geometry calculated after mount/prop changes\n// // // // // // // //     const [calculatedGeometry, setCalculatedGeometry] = useState<THREE.BufferGeometry | null>(null);\n\n// // // // // // // //     // Effect to perform CSG calculation\n// // // // // // // //     useEffect(() => {\n// // // // // // // //         console.log(`useEffect Check: outerRadius=${outerRadius}, thickness=${thickness}, ...`);\n// // // // // // // //         // Guard against invalid props (potentially from initial Leva state)\n// // // // // // // //         if ( typeof outerRadius !== 'number' || outerRadius <= 0 || !Number.isFinite(outerRadius) || typeof thickness !== 'number' || thickness <= 0 || !Number.isFinite(thickness) || typeof holeBaseDiameter !== 'number' || holeBaseDiameter <= 0 || !Number.isFinite(holeBaseDiameter) || typeof holeRatio !== 'number' || holeRatio <= 0 || !Number.isFinite(holeRatio) || typeof noduleRadius !== 'number' || noduleRadius <= 0 || !Number.isFinite(noduleRadius) ) {\n// // // // // // // //             console.log(`--> Skipping CSG calculation in useEffect: Invalid props detected.`);\n// // // // // // // //             setCalculatedGeometry(null); // Ensure geometry is null if props invalid\n// // // // // // // //             return; // Exit effect\n// // // // // // // //         }\n\n// // // // // // // //         console.log(`Calculating CSG Geometry in useEffect for outerRadius: ${outerRadius}`);\n// // // // // // // //         let geometry: THREE.BufferGeometry | null = null;\n// // // // // // // //         const detailLevel = 1; // Keep low detail for base shapes for performance\n// // // // // // // //         let tempGeoList: THREE.BufferGeometry[] = []; // Track temp geos for disposal\n\n// // // // // // // //         try {\n// // // // // // // //             // Get mathematically correct positions/normals\n// // // // // // // //             const { vertices: mathVertices, faceData: mathFaceData } = getDodecahedronData(outerRadius);\n\n// // // // // // // //             // Create base shell\n// // // // // // // //             const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, detailLevel); outerDodecGeo.computeBoundsTree(); tempGeoList.push(outerDodecGeo);\n// // // // // // // //             const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, detailLevel); innerDodecGeo.computeBoundsTree(); tempGeoList.push(innerDodecGeo);\n// // // // // // // //             let outerBrush = new Brush(outerDodecGeo); let innerBrush = new Brush(innerDodecGeo); innerBrush.updateMatrixWorld();\n// // // // // // // //             let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n\n// // // // // // // //             // Create and subtract holes\n// // // // // // // //             const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * (holeRatio ** i));\n// // // // // // // //             const cylinderHeight = thickness * 3.1; // Ensure cylinder goes through shell\n// // // // // // // //             const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16); cylinderGeo.rotateX(Math.PI / 2); cylinderGeo.computeBoundsTree(); tempGeoList.push(cylinderGeo);\n// // // // // // // //             const tempQuat = new THREE.Quaternion();\n// // // // // // // //             mathFaceData.forEach((face, index) => {\n// // // // // // // //                 const holeRadius = holeDiameters[index] / 2; if (!holeRadius || holeRadius <= 0) return;\n// // // // // // // //                 const holeBrush = new Brush(cylinderGeo); holeBrush.scale.set(holeRadius, holeRadius, 1);\n// // // // // // // //                 tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), face.normal); holeBrush.quaternion.copy(tempQuat);\n// // // // // // // //                 holeBrush.position.copy(face.center); holeBrush.updateMatrixWorld();\n// // // // // // // //                 shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION);\n// // // // // // // //             });\n\n// // // // // // // //             // Create and add nodules\n// // // // // // // //             const noduleGeo = new THREE.SphereGeometry(noduleRadius, 6, 6); noduleGeo.computeBoundsTree(); tempGeoList.push(noduleGeo);\n// // // // // // // //             mathVertices.forEach(vertexPos => {\n// // // // // // // //                 const noduleBrush = new Brush(noduleGeo); noduleBrush.position.copy(vertexPos);\n// // // // // // // //                 noduleBrush.updateMatrixWorld(); shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION);\n// // // // // // // //             });\n\n// // // // // // // //             // Finalize geometry\n// // // // // // // //             geometry = shellBrush.geometry;\n// // // // // // // //             geometry.computeVertexNormals(); // Crucial for lighting!\n// // // // // // // //             geometry.center(); // Center the final composite shape\n// // // // // // // //             console.log(\"CSG Calculation Complete.\");\n\n// // // // // // // //         } catch (error) {\n// // // // // // // //             console.error(\"CSG Error in useEffect:\", error);\n// // // // // // // //             geometry = null; // Ensure null on error\n// // // // // // // //         } finally {\n// // // // // // // //             // Clean up intermediate geometries used for CSG brushes\n// // // // // // // //             tempGeoList.forEach(g => g.dispose());\n// // // // // // // //             console.log(`Disposed ${tempGeoList.length} temporary CSG geometries.`);\n// // // // // // // //         }\n\n// // // // // // // //         // Update state with the calculated geometry (or null)\n// // // // // // // //         setCalculatedGeometry(geometry);\n\n// // // // // // // //         // Effect cleanup function: Dispose the *final* geometry when effect re-runs or unmounts\n// // // // // // // //         return () => {\n// // // // // // // //             if (geometry && typeof geometry.dispose === 'function') {\n// // // // // // // //                 geometry.dispose();\n// // // // // // // //                 console.log(\"Disposed final CSG geometry from useEffect cleanup.\");\n// // // // // // // //             }\n// // // // // // // //         };\n// // // // // // // //     }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]); // Dependencies\n\n// // // // // // // //     // Memoize the material based on props\n// // // // // // // //     const meshMaterial = useMemo(() => {\n// // // // // // // //         let baseMaterial: THREE.Material;\n\n// // // // // // // //         // --- DIAGNOSTIC: Uncomment next line to use NormalMaterial ---\n// // // // // // // //         // return new THREE.MeshNormalMaterial({ name:\"NormalMat\", side: THREE.DoubleSide, wireframe: wireframe });\n\n// // // // // // // //         // Use provided material or default to Phong for smoother shading\n// // // // // // // //         if (material instanceof THREE.Material) {\n// // // // // // // //              baseMaterial = material.clone(); // Clone if possible\n// // // // // // // //              baseMaterial.side = THREE.DoubleSide;\n// // // // // // // //              console.log(\"Using provided material clone.\");\n// // // // // // // //         } else {\n// // // // // // // //             console.log(\"Creating default MeshPhongMaterial.\");\n// // // // // // // //             baseMaterial = new THREE.MeshPhongMaterial({\n// // // // // // // //                 color: 0xB87333, side: THREE.DoubleSide, specular: 0x444444, shininess: 40, name: \"DefaultPhongCopper\"\n// // // // // // // //              });\n// // // // // // // //         }\n\n// // // // // // // //         // Apply wireframe if property exists (using type guard)\n// // // // // // // //         if ('wireframe' in baseMaterial) {\n// // // // // // // //             (baseMaterial as any).wireframe = wireframe;\n// // // // // // // //         }\n// // // // // // // //         // Ensure DoubleSide is set\n// // // // // // // //         baseMaterial.side = THREE.DoubleSide;\n\n// // // // // // // //         return baseMaterial;\n// // // // // // // //     }, [material, wireframe]); // Recreate if base material or wireframe changes\n\n// // // // // // // //     // Effect to dispose the memoized material\n// // // // // // // //     useEffect(() => { return () => { meshMaterial?.dispose(); } }, [meshMaterial]);\n\n// // // // // // // //     // Don't render if geometry calculation failed or hasn't completed\n// // // // // // // //     if (!calculatedGeometry) { return null; }\n\n// // // // // // // //     // Render the mesh using calculated geometry and memoized material\n// // // // // // // //     return <mesh ref={ref} geometry={calculatedGeometry} material={meshMaterial} {...props} />;\n// // // // // // // // });\n\n// // // // // // // // // --- Physics State Interface ---\n// // // // // // // // interface PhysicsState {\n// // // // // // // //     shell_angular_velocity_scalar: number;\n// // // // // // // //     effective_field_velocity_scalar: number;\n// // // // // // // //     current_torque_scalar: number;\n// // // // // // // // }\n\n// // // // // // // // // --- Main Simulation Component ---\n// // // // // // // // const ResonatorSimulation: React.FC = () => {\n// // // // // // // //     // Refs for scene objects\n// // // // // // // //     const groupRef = useRef<THREE.Group>(null!); // Group to handle rotation/centering\n// // // // // // // //     const dodecahedronMeshRef = useRef<THREE.Mesh>(null!); // Ref to the actual CSG mesh\n// // // // // // // //     const particlesRef = useRef<THREE.Points>(null!);\n// // // // // // // //     const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // // // // // // //     // Leva controls setup\n// // // // // // // //     const resonatorControls = useControls('Resonator Controls', { baseFieldSpeed: 1.0, fieldIntensity: 1.0, k_drag: 0.5, inertiaScale: 1.0, damping: 0.1, k_feedback: -0.2 });\n// // // // // // // //     const shellControls = useControls('Shell Geometry', { outerRadius: 1.0, thickness: 0.05, holeBaseDiameter: 0.1, holeRatio: 1.2, noduleRadius: 0.1 });\n// // // // // // // //     const vizControls = useControls('Visualization', { particleCount: 1000, particleSize: 0.05, torusMajorRadius: 1.5, torusMinorRadius: 0.5, showParticles: true, wireframe: false });\n\n// // // // // // // //     // Ensure shell parameters are valid numbers, falling back to defaults\n// // // // // // // //     const defaultShellParams = useMemo(() => ({ outerRadius: 1.0, thickness: 0.05, holeBaseDiameter: 0.1, holeRatio: 1.2, noduleRadius: 0.1 }), []);\n// // // // // // // //     const finalShellParams = useMemo(() => ({\n// // // // // // // //         outerRadius: (typeof shellControls.outerRadius === 'number' && Number.isFinite(shellControls.outerRadius)) ? shellControls.outerRadius : defaultShellParams.outerRadius,\n// // // // // // // //         thickness: (typeof shellControls.thickness === 'number' && Number.isFinite(shellControls.thickness)) ? shellControls.thickness : defaultShellParams.thickness,\n// // // // // // // //         holeBaseDiameter: (typeof shellControls.holeBaseDiameter === 'number' && Number.isFinite(shellControls.holeBaseDiameter)) ? shellControls.holeBaseDiameter : defaultShellParams.holeBaseDiameter,\n// // // // // // // //         holeRatio: (typeof shellControls.holeRatio === 'number' && Number.isFinite(shellControls.holeRatio)) ? shellControls.holeRatio : defaultShellParams.holeRatio,\n// // // // // // // //         noduleRadius: (typeof shellControls.noduleRadius === 'number' && Number.isFinite(shellControls.noduleRadius)) ? shellControls.noduleRadius : defaultShellParams.noduleRadius,\n// // // // // // // //     }), [shellControls, defaultShellParams]);\n\n// // // // // // // //     // Calculate effective inertia\n// // // // // // // //     const effectiveInertia = useMemo(() => resonatorControls.inertiaScale * (finalShellParams.outerRadius ** 5 - (finalShellParams.outerRadius - finalShellParams.thickness) ** 5) / finalShellParams.outerRadius ** 5, [resonatorControls.inertiaScale, finalShellParams.outerRadius, finalShellParams.thickness]);\n\n// // // // // // // //     // Initialize physics state using a ref\n// // // // // // // //     const physicsState = useRef<PhysicsState>({\n// // // // // // // //          shell_angular_velocity_scalar: 0.0,\n// // // // // // // //          effective_field_velocity_scalar: resonatorControls.baseFieldSpeed || 0, // Use Leva value or 0\n// // // // // // // //          current_torque_scalar: 0.0,\n// // // // // // // //     });\n\n// // // // // // // //     // Memoize particle data creation\n// // // // // // // //     const particleData = useMemo<{ positions: Float32Array; data: any[] }>(() => {\n// // // // // // // //         console.log(`Creating particle data for count: ${vizControls.particleCount}`);\n// // // // // // // //         try {\n// // // // // // // //              const data = []; const positions = new Float32Array(vizControls.particleCount * 3);\n// // // // // // // //              for (let i = 0; i < vizControls.particleCount; i++) { /* ... populate particles ... */\n// // // // // // // //                  const u = Math.random() * Math.PI * 2; const v = Math.random() * Math.PI * 2; const R = vizControls.torusMajorRadius; const r = vizControls.torusMinorRadius; const randR = R + (Math.random() - 0.5) * 0.2; const randr = r * Math.sqrt(Math.random());\n// // // // // // // //                  positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u); positions[i * 3 + 1] = randr * Math.sin(v); positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u);\n// // // // // // // //                  data.push({ u, v, R, r: randr, fieldIndex: 0 }); }\n// // // // // // // //              return { positions, data };\n// // // // // // // //         } catch (error) { console.error(\"Error creating particle data:\", error); return { positions: new Float32Array(0), data: [] }; }\n// // // // // // // //      }, [vizControls.particleCount, vizControls.torusMajorRadius, vizControls.torusMinorRadius]);\n\n// // // // // // // //     // Effect to manage the particle buffer attribute\n// // // // // // // //      useEffect(() => {\n// // // // // // // //          if (particleGeoRef.current && particleData?.positions) {\n// // // // // // // //              const existingAttribute = particleGeoRef.current.getAttribute('position') as THREE.BufferAttribute | undefined;\n// // // // // // // //              if (!existingAttribute || existingAttribute.array.length !== particleData.positions.length) {\n// // // // // // // //                  particleGeoRef.current.setAttribute('position', new THREE.BufferAttribute(particleData.positions, 3, false));\n// // // // // // // //                  console.log(`Particle buffer attribute CREATED/REPLACED (Count: ${particleData.positions.length / 3}).`);\n// // // // // // // //              }\n// // // // // // // //          } else { if (particleGeoRef.current?.getAttribute('position')) { particleGeoRef.current.deleteAttribute('position'); console.log(\"Particle buffer attribute removed.\"); } }\n// // // // // // // //      }, [particleData]);\n\n// // // // // // // //     // Main animation loop\n// // // // // // // //     useFrame((state, delta) => {\n// // // // // // // //         const currentPhysics = physicsState.current;\n\n// // // // // // // //         // V1 Physics Calculations (Scalar Y-axis rotation)\n// // // // // // // //         const relative_speed = currentPhysics.effective_field_velocity_scalar - currentPhysics.shell_angular_velocity_scalar;\n// // // // // // // //         currentPhysics.current_torque_scalar = resonatorControls.k_drag * resonatorControls.fieldIntensity * relative_speed;\n// // // // // // // //         const angular_acceleration = effectiveInertia > 0 ? (currentPhysics.current_torque_scalar / effectiveInertia) : 0;\n// // // // // // // //         currentPhysics.shell_angular_velocity_scalar += angular_acceleration * delta;\n// // // // // // // //         currentPhysics.shell_angular_velocity_scalar *= (1 - resonatorControls.damping * delta); // Apply damping\n// // // // // // // //         currentPhysics.effective_field_velocity_scalar = resonatorControls.baseFieldSpeed + resonatorControls.k_feedback * currentPhysics.shell_angular_velocity_scalar; // Feedback\n\n// // // // // // // //         // Rotate the Group containing the dodecahedron\n// // // // // // // //         if (groupRef.current) {\n// // // // // // // //              // console.log(\"Ang Vel:\", currentPhysics.shell_angular_velocity_scalar.toFixed(3)); // DEBUG Rotation\n// // // // // // // //              groupRef.current.rotation.y += currentPhysics.shell_angular_velocity_scalar * delta;\n// // // // // // // //         }\n\n// // // // // // // //         // Update Emissive (Only if using Standard/Physical material)\n// // // // // // // //         if (dodecahedronMeshRef.current) {\n// // // // // // // //              const currentMaterial = dodecahedronMeshRef.current.material;\n// // // // // // // //              if (currentMaterial instanceof THREE.MeshStandardMaterial || currentMaterial instanceof THREE.MeshPhysicalMaterial) {\n// // // // // // // //                  if (currentMaterial.emissive) {\n// // // // // // // //                      const maxTorqueEst = resonatorControls.k_drag * resonatorControls.fieldIntensity * (Math.abs(resonatorControls.baseFieldSpeed) * 1.5 + 1);\n// // // // // // // //                      const emissionStrength = Math.min(Math.abs(currentPhysics.current_torque_scalar) / (maxTorqueEst + 0.01), 1.0);\n// // // // // // // //                      currentMaterial.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5);\n// // // // // // // //                  }\n// // // // // // // //              }\n// // // // // // // //         }\n\n// // // // // // // //         // Particle Field Update\n// // // // // // // //         if (vizControls.showParticles && particleGeoRef.current?.attributes.position && particlesRef.current && particleData?.data) {\n// // // // // // // //             const positions = particleGeoRef.current.attributes.position.array as Float32Array;\n// // // // // // // //             const speed = currentPhysics.effective_field_velocity_scalar * resonatorControls.fieldIntensity; // Use speed\n// // // // // // // //             const pData = particleData.data;\n\n// // // // // // // //             if (pData.length * 3 === positions.length) { // Check array lengths match\n// // // // // // // //                 const pointsMat = particlesRef.current.material as THREE.PointsMaterial;\n// // // // // // // //                 if (pointsMat) { pointsMat.size = vizControls.particleSize * (1 + resonatorControls.fieldIntensity * 0.5); }\n\n// // // // // // // //                 for (let i = 0; i < pData.length; i++) {\n// // // // // // // //                     const data = pData[i];\n// // // // // // // //                     data.u += speed * delta; // Update angle using speed\n// // // // // // // //                     const R = data.R; const r = data.r; const u = data.u; const v = data.v;\n// // // // // // // //                     positions[i * 3]     = (R + r * Math.cos(v)) * Math.cos(u);\n// // // // // // // //                     positions[i * 3 + 1] = r * Math.sin(v);\n// // // // // // // //                     positions[i * 3 + 2] = (R + r * Math.cos(v)) * Math.sin(u);\n// // // // // // // //                 }\n// // // // // // // //                 // Mark buffer attribute for update\n// // // // // // // //                 particleGeoRef.current.attributes.position.needsUpdate = true;\n// // // // // // // //             } else { console.warn(\"Mismatch between particle data length and buffer length in useFrame.\"); }\n// // // // // // // //         }\n// // // // // // // //     });\n\n// // // // // // // //     // No need to memoize copperMaterial here, RomanDodecahedron handles its default/passed material\n\n// // // // // // // //     return (\n// // // // // // // //         // Group centers the object and handles rotation\n// // // // // // // //         <group ref={groupRef}>\n// // // // // // // //             <RomanDodecahedron\n// // // // // // // //                 ref={dodecahedronMeshRef} // Ref to the mesh itself\n// // // // // // // //                 outerRadius={finalShellParams.outerRadius}\n// // // // // // // //                 thickness={finalShellParams.thickness}\n// // // // // // // //                 holeBaseDiameter={finalShellParams.holeBaseDiameter}\n// // // // // // // //                 holeRatio={finalShellParams.holeRatio}\n// // // // // // // //                 noduleRadius={finalShellParams.noduleRadius}\n// // // // // // // //                 // No material prop passed, will use internal default (Phong)\n// // // // // // // //                 wireframe={vizControls.wireframe} // Control wireframe via Leva\n// // // // // // // //                 castShadow receiveShadow\n// // // // // // // //                 // Mesh position/rotation is relative to the group (should be 0)\n// // // // // // // //                 position={[0,0,0]}\n// // // // // // // //                 rotation={[0,0,0]}\n// // // // // // // //             />\n// // // // // // // //             {/* Point light inside the group to illuminate interior */}\n// // // // // // // //             <pointLight intensity={0.5} color={0xffddcc} distance={3} decay={1.5} position={[0, 0, 0]} name=\"InternalLight\" />\n\n// // // // // // // //             {/* Particles are siblings of the group, not children */}\n// // // // // // // //             {vizControls.showParticles && (\n// // // // // // // //                  <points ref={particlesRef} name=\"FieldParticles\">\n// // // // // // // //                      <bufferGeometry ref={particleGeoRef} />\n// // // // // // // //                      <pointsMaterial\n// // // // // // // //                          name=\"ParticleMaterial\" color={0x00ffff}\n// // // // // // // //                          size={vizControls.particleSize} transparent opacity={0.7}\n// // // // // // // //                          blending={THREE.AdditiveBlending}\n// // // // // // // //                          sizeAttenuation={false} // Keep false for consistent size\n// // // // // // // //                          map={null}\n// // // // // // // //                      />\n// // // // // // // //                  </points>\n// // // // // // // //             )}\n// // // // // // // //         </group>\n// // // // // // // //     );\n// // // // // // // // };\n\n// // // // // // // // // --- Scene Component ---\n// // // // // // // // const TemporalResonatorScene: React.FC = () => {\n// // // // // // // //      return (\n// // // // // // // //         <>\n// // // // // // // //             {/* Leva GUI Panel */}\n// // // // // // // //             <Leva collapsed={false} titleBar={{ title: 'Controls' }} />\n// // // // // // // //             {/* Main Canvas */}\n// // // // // // // //             <Canvas\n// // // // // // // //                  style={{ position: 'absolute', top: 0, left: 0, width: '100vw', height: '100vh', background: '#111122', zIndex: 0 }}\n// // // // // // // //                  camera={{ position: [3, 3, 5], fov: 75 }}\n// // // // // // // //                  gl={{ antialias: true }} shadows // Enable shadows\n// // // // // // // //             >\n// // // // // // // //                  {/* Lighting Setup */}\n// // // // // // // //                  <ambientLight intensity={0.4} />\n// // // // // // // //                  <hemisphereLight groundColor={0x404040} intensity={0.8} />\n// // // // // // // //                  <directionalLight\n// // // // // // // //                      position={[5, 10, 7.5]} intensity={1.2} castShadow\n// // // // // // // //                      shadow-mapSize-width={1024} shadow-mapSize-height={1024}\n// // // // // // // //                      shadow-camera-far={25} shadow-camera-left={-10} shadow-camera-right={10}\n// // // // // // // //                      shadow-camera-top={10} shadow-camera-bottom={-10}\n// // // // // // // //                  />\n// // // // // // // //                  {/* Error Boundary and Suspense for loading */}\n// // // // // // // //                  <ErrorBoundary>\n// // // // // // // //                      <Suspense fallback={<LoadingPlaceholder />}>\n// // // // // // // //                           <ResonatorSimulation />\n// // // // // // // //                      </Suspense>\n// // // // // // // //                  </ErrorBoundary>\n// // // // // // // //                  {/* Camera Controls */}\n// // // // // // // //                  <Controls />\n// // // // // // // //                  {/* Optional Debug Helpers */}\n// // // // // // // //                  {/* <axesHelper args={[5]} /> */}\n// // // // // // // //                  {/* <gridHelper args={[10, 10]} /> */}\n// // // // // // // //             </Canvas>\n// // // // // // // //         </>\n// // // // // // // //      );\n// // // // // // // //  };\n\n// // // // // // // // // --- Loading Placeholder Component ---\n// // // // // // // // const LoadingPlaceholder: React.FC = () => {\n// // // // // // // //     // Simple visual indicator while CSG calculates\n// // // // // // // //     return (\n// // // // // // // //         <mesh>\n// // // // // // // //             <boxGeometry args={[0.1, 0.1, 0.1]} />\n// // // // // // // //             <meshBasicMaterial color=\"orange\" wireframe attach=\"material\" />\n// // // // // // // //         </mesh>\n// // // // // // // //     );\n// // // // // // // // };\n\n// // // // // // // // export default TemporalResonatorScene;\n\n// // // // // // // // // // === Full Code: TemporalResonatorScene_V2_CSG_Fixes_11.tsx ===\n\n// // // // // // // // // import React, { useRef, useEffect, useMemo, Suspense, useState } from 'react';\n// // // // // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // // // // // import * as THREE from 'three';\n// // // // // // // // // import ErrorBoundary from './errorBoundary'; // Adjust path if needed\n// // // // // // // // // import { useControls, Leva } from 'leva';\n// // // // // // // // // import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\n// // // // // // // // // import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n\n// // // // // // // // // // --- BVH / CSG Setup ---\n// // // // // // // // // try {\n// // // // // // // // //     THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\n// // // // // // // // //     THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\n// // // // // // // // //     THREE.Mesh.prototype.raycast = acceleratedRaycast;\n// // // // // // // // // } catch (error) { console.error(\"Error setting up BVH extensions:\", error); }\n// // // // // // // // // const csgEvaluator = new Evaluator();\n// // // // // // // // // csgEvaluator.useGroups = true;\n// // // // // // // // // extend({ OrbitControls });\n\n// // // // // // // // // // --- Constants ---\n// // // // // // // // // const PHI = (1 + Math.sqrt(5)) / 2;\n// // // // // // // // // const INV_PHI = 1 / PHI;\n\n// // // // // // // // // // --- Helper: Get Dodecahedron Math Data ---\n// // // // // // // // // function getDodecahedronData(radius: number): { vertices: THREE.Vector3[]; faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] } {\n// // // // // // // // //     // --- Unchanged from previous working version ---\n// // // // // // // // //     console.log(`--- Calculating Dodecahedron Data for radius: ${radius} ---`);\n// // // // // // // // //     if (typeof radius !== 'number' || radius <= 0 || !Number.isFinite(radius)) { throw new Error(\"Invalid radius\"); }\n// // // // // // // // //     const uniqueVerticesMap = new Map<string, THREE.Vector3>();\n// // // // // // // // //     const coords = [ [1, 1, 1], [-1, 1, 1], [1, -1, 1], [-1, -1, 1], [1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1], [0, PHI, INV_PHI], [0, -PHI, INV_PHI], [0, PHI, -INV_PHI], [0, -PHI, -INV_PHI], [INV_PHI, 0, PHI], [-INV_PHI, 0, PHI], [INV_PHI, 0, -PHI], [-INV_PHI, 0, -PHI], [PHI, INV_PHI, 0], [-PHI, INV_PHI, 0], [PHI, -INV_PHI, 0], [-PHI, -INV_PHI, 0] ];\n// // // // // // // // //     const distOriginToVertex = Math.sqrt(PHI * PHI + INV_PHI * INV_PHI);\n// // // // // // // // //     const scale = radius / distOriginToVertex;\n// // // // // // // // //     if (!Number.isFinite(scale) || scale === 0) { throw new Error(\"Invalid scale factor\"); }\n// // // // // // // // //     coords.forEach(v => { const x = v[0] * scale; const y = v[1] * scale; const z = v[2] * scale; const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`; if (!uniqueVerticesMap.has(key)) { uniqueVerticesMap.set(key, new THREE.Vector3(x, y, z)); } });\n// // // // // // // // //     const vertices = Array.from(uniqueVerticesMap.values());\n// // // // // // // // //     const faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] = [];\n// // // // // // // // //     const icoVerts = [ [0, 1, PHI], [0, -1, PHI], [0, 1, -PHI], [0, -1, -PHI], [1, PHI, 0], [-1, PHI, 0], [1, -PHI, 0], [-1, -PHI, 0], [PHI, 0, 1], [-PHI, 0, 1], [PHI, 0, -1], [-PHI, 0, -1] ];\n// // // // // // // // //     const faceCenterDist = radius * 1.53 / distOriginToVertex;\n// // // // // // // // //     icoVerts.forEach(v => { const normal = new THREE.Vector3(v[0], v[1], v[2]).normalize(); const center = normal.clone().multiplyScalar(faceCenterDist); faceData.push({ center, normal }); });\n// // // // // // // // //     if (vertices.length !== 20 || faceData.length !== 12) { console.error(\"!!! Vertex/Face generation failed. Vertices:\", vertices, \"Faces:\", faceData); throw new Error(`Incorrect math data count: ${vertices.length} vertices, ${faceData.length} faces`); }\n// // // // // // // // //     console.log(`--- Generated ${vertices.length} vertices, ${faceData.length} faces. ---`);\n// // // // // // // // //     return { vertices, faceData };\n// // // // // // // // // }\n\n// // // // // // // // // // --- Controls Component ---\n// // // // // // // // // const Controls: React.FC = () => {\n// // // // // // // // //      const { camera, gl } = useThree(); const controlsRef = useRef<OrbitControls>(null);\n// // // // // // // // //      useEffect(() => {\n// // // // // // // // //          const controls = new OrbitControls(camera, gl.domElement);\n// // // // // // // // //          controls.enableDamping = true;\n// // // // // // // // //          // Target the origin [0,0,0] which is where our group will be\n// // // // // // // // //          controls.target.set(0, 0, 0);\n// // // // // // // // //          (controlsRef as React.MutableRefObject<OrbitControls>).current = controls;\n// // // // // // // // //          return () => { controls.dispose(); };\n// // // // // // // // //      }, [camera, gl]);\n// // // // // // // // //      useFrame(() => { controlsRef.current?.update(); });\n// // // // // // // // //      return null;\n// // // // // // // // // };\n\n// // // // // // // // // // --- Roman Dodecahedron CSG Component ---\n// // // // // // // // // interface RomanDodecahedronProps { outerRadius: number; thickness: number; holeBaseDiameter: number; holeRatio: number; noduleRadius: number; material?: THREE.Material; wireframe?: boolean; [key: string]: any; }\n// // // // // // // // // const RomanDodecahedron: React.FC<RomanDodecahedronProps> = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>(\n// // // // // // // // //     ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, wireframe = false, ...props }, ref) => {\n// // // // // // // // //     const [calculatedGeometry, setCalculatedGeometry] = useState<THREE.BufferGeometry | null>(null);\n\n// // // // // // // // //     useEffect(() => {\n// // // // // // // // //         console.log(`useEffect Check: outerRadius=${outerRadius} (${typeof outerRadius}), thickness=${thickness}, ...`);\n// // // // // // // // //         if ( typeof outerRadius !== 'number' || /* ... guards ... */ typeof noduleRadius !== 'number' || noduleRadius <= 0 || !Number.isFinite(noduleRadius) ) {\n// // // // // // // // //             console.log(`--> Skipping CSG calculation: Invalid props.`); setCalculatedGeometry(null); return;\n// // // // // // // // //         }\n// // // // // // // // //         console.log(`Calculating CSG Geometry for radius: ${outerRadius}`);\n// // // // // // // // //         let geometry: THREE.BufferGeometry | null = null; const detailLevel = 1; let tempGeoList: THREE.BufferGeometry[] = [];\n// // // // // // // // //         try {\n// // // // // // // // //             const { vertices: mathVertices, faceData: mathFaceData } = getDodecahedronData(outerRadius);\n// // // // // // // // //             const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, detailLevel); outerDodecGeo.computeBoundsTree(); tempGeoList.push(outerDodecGeo);\n// // // // // // // // //             const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, detailLevel); innerDodecGeo.computeBoundsTree(); tempGeoList.push(innerDodecGeo);\n// // // // // // // // //             let outerBrush = new Brush(outerDodecGeo); let innerBrush = new Brush(innerDodecGeo); innerBrush.updateMatrixWorld();\n// // // // // // // // //             let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n// // // // // // // // //             const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * (holeRatio ** i));\n// // // // // // // // //             const cylinderHeight = thickness * 3.1; // Slightly more than 3x thickness\n// // // // // // // // //             const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16); cylinderGeo.rotateX(Math.PI / 2); cylinderGeo.computeBoundsTree(); tempGeoList.push(cylinderGeo);\n// // // // // // // // //             const tempQuat = new THREE.Quaternion();\n// // // // // // // // //             mathFaceData.forEach((face, index) => { const holeRadius = holeDiameters[index] / 2; if (!holeRadius || holeRadius <= 0) return; const holeBrush = new Brush(cylinderGeo); holeBrush.scale.set(holeRadius, holeRadius, 1); tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), face.normal); holeBrush.quaternion.copy(tempQuat); holeBrush.position.copy(face.center); holeBrush.updateMatrixWorld(); shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION); });\n// // // // // // // // //             const noduleGeo = new THREE.SphereGeometry(noduleRadius, 6, 6); noduleGeo.computeBoundsTree(); tempGeoList.push(noduleGeo);\n// // // // // // // // //             mathVertices.forEach(vertexPos => { const noduleBrush = new Brush(noduleGeo); noduleBrush.position.copy(vertexPos); noduleBrush.updateMatrixWorld(); shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION); });\n// // // // // // // // //             geometry = shellBrush.geometry;\n// // // // // // // // //             geometry.computeVertexNormals(); // Compute normals AFTER all CSG ops\n// // // // // // // // //             geometry.center(); // Center AFTER all CSG ops\n// // // // // // // // //             console.log(\"CSG Calculation Complete.\");\n// // // // // // // // //         } catch (error) { console.error(\"CSG Error in useEffect:\", error); geometry = null; }\n// // // // // // // // //         finally { tempGeoList.forEach(g => g.dispose()); console.log(`Disposed ${tempGeoList.length} temporary CSG geometries.`); }\n// // // // // // // // //         setCalculatedGeometry(geometry);\n// // // // // // // // //         return () => { if (geometry && typeof geometry.dispose === 'function') { geometry.dispose(); console.log(\"Disposed final CSG geometry from useEffect cleanup.\"); } };\n// // // // // // // // //     }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]);\n\n// // // // // // // // //     const meshMaterial = useMemo(() => {\n// // // // // // // // //         let baseMaterial: THREE.Material;\n// // // // // // // // //         // --- DIAGNOSTIC: Uncomment next line to use NormalMaterial ---\n// // // // // // // // //         // return new THREE.MeshNormalMaterial({ side: THREE.DoubleSide, wireframe: wireframe });\n\n// // // // // // // // //         // Default/Copper material logic\n// // // // // // // // //         if (material instanceof THREE.Material) {\n// // // // // // // // //             baseMaterial = material.clone();\n// // // // // // // // //         } else {\n// // // // // // // // //             // Default copper material if none provided\n// // // // // // // // //             baseMaterial = new THREE.MeshStandardMaterial({ color: 0xB87333, side: THREE.DoubleSide, name: \"DefaultCopper\" });\n// // // // // // // // //         }\n\n// // // // // // // // //         if ('wireframe' in baseMaterial) {\n// // // // // // // // //             (baseMaterial as any).wireframe = wireframe;\n// // // // // // // // //         }\n// // // // // // // // //         if (baseMaterial instanceof THREE.MeshStandardMaterial) {\n// // // // // // // // //              baseMaterial.metalness = wireframe ? 0.1 : 0.8;\n// // // // // // // // //              baseMaterial.roughness = wireframe ? 0.8 : 0.3;\n// // // // // // // // //              // Ensure double side is set\n// // // // // // // // //              baseMaterial.side = THREE.DoubleSide;\n// // // // // // // // //         } else if (baseMaterial instanceof THREE.MeshPhysicalMaterial) {\n// // // // // // // // //             // Add similar adjustments if using physical material\n// // // // // // // // //             baseMaterial.side = THREE.DoubleSide;\n// // // // // // // // //         } else {\n// // // // // // // // //              // For other materials like Basic, Lambert - ensure side is set if needed\n// // // // // // // // //              baseMaterial.side = THREE.DoubleSide;\n// // // // // // // // //         }\n\n// // // // // // // // //         return baseMaterial;\n// // // // // // // // //     }, [material, wireframe]);\n\n// // // // // // // // //     useEffect(() => { return () => { meshMaterial?.dispose(); } }, [meshMaterial]);\n\n// // // // // // // // //     if (!calculatedGeometry) { return null; }\n// // // // // // // // //     // Use ref on the mesh, group rotation will handle overall transform\n// // // // // // // // //     return <mesh ref={ref} geometry={calculatedGeometry} material={meshMaterial} {...props} />;\n// // // // // // // // // });\n\n// // // // // // // // // // --- Physics State Interface ---\n// // // // // // // // // interface PhysicsState { shell_angular_velocity_scalar: number; effective_field_velocity_scalar: number; current_torque_scalar: number; }\n\n// // // // // // // // // // --- Main Simulation Component ---\n// // // // // // // // // const ResonatorSimulation: React.FC = () => {\n// // // // // // // // //     // --- FIX: Group Ref for Rotation ---\n// // // // // // // // //     const groupRef = useRef<THREE.Group>(null!); // Use Group type\n// // // // // // // // //     const dodecahedronMeshRef = useRef<THREE.Mesh>(null!); // Keep ref for mesh if needed later\n// // // // // // // // //     const particlesRef = useRef<THREE.Points>(null!);\n// // // // // // // // //     const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // // // // // // // //     // Leva controls\n// // // // // // // // //     const resonatorControls = useControls('Resonator Controls', { baseFieldSpeed: 1.0, fieldIntensity: 1.0, k_drag: 0.5, inertiaScale: 1.0, damping: 0.1, k_feedback: -0.2 });\n// // // // // // // // //     const shellControls = useControls('Shell Geometry', { outerRadius: 1.0, thickness: 0.05, holeBaseDiameter: 0.1, holeRatio: 1.2, noduleRadius: 0.1 });\n// // // // // // // // //     const vizControls = useControls('Visualization', { particleCount: 1000, particleSize: 0.05, torusMajorRadius: 1.5, torusMinorRadius: 0.5, showParticles: true, wireframe: false });\n\n// // // // // // // // //     // Combine controls with defaults\n// // // // // // // // //     const defaultShellParams = useMemo(() => ({ outerRadius: 1.0, thickness: 0.05, holeBaseDiameter: 0.1, holeRatio: 1.2, noduleRadius: 0.1 }), []);\n// // // // // // // // //     const finalShellParams = useMemo(() => ({ /* ... merge logic ... */ outerRadius: shellControls.outerRadius ?? defaultShellParams.outerRadius, thickness: shellControls.thickness ?? defaultShellParams.thickness, holeBaseDiameter: shellControls.holeBaseDiameter ?? defaultShellParams.holeBaseDiameter, holeRatio: shellControls.holeRatio ?? defaultShellParams.holeRatio, noduleRadius: shellControls.noduleRadius ?? defaultShellParams.noduleRadius }), [shellControls, defaultShellParams]);\n\n// // // // // // // // //     // Inertia calculation\n// // // // // // // // //     const effectiveInertia = useMemo(() => resonatorControls.inertiaScale * (finalShellParams.outerRadius ** 5 - (finalShellParams.outerRadius - finalShellParams.thickness) ** 5) / finalShellParams.outerRadius ** 5, [resonatorControls.inertiaScale, finalShellParams.outerRadius, finalShellParams.thickness]);\n// // // // // // // // //     // Physics state\n// // // // // // // // //     const physicsState = useRef<PhysicsState>({ shell_angular_velocity_scalar: 0.0, effective_field_velocity_scalar: resonatorControls.baseFieldSpeed || 0, current_torque_scalar: 0.0 });\n// // // // // // // // //     // Particle data\n// // // // // // // // //     const particleData = useMemo<{ positions: Float32Array; data: any[] }>(() => {\n// // // // // // // // //         // ... create particle data ...\n// // // // // // // // //         // Example placeholder: replace with the actual creation logic:\n// // // // // // // // //         const positions = new Float32Array(vizControls.particleCount * 3);\n// // // // // // // // //         const data: any[] = [];\n// // // // // // // // //         // Populate positions and data as needed.\n// // // // // // // // //         return { positions, data };\n// // // // // // // // //     }, [vizControls.particleCount, vizControls.torusMajorRadius, vizControls.torusMinorRadius]);\n// // // // // // // // //     // Particle buffer effect\n// // // // // // // // //     useEffect(() => { /* ... particle buffer update effect ... */ }, [particleData]);\n\n// // // // // // // // //     // Animation loop\n// // // // // // // // //     useFrame((state, delta) => {\n// // // // // // // // //         const currentPhysics = physicsState.current;\n// // // // // // // // //         // V1 Physics Calculations\n// // // // // // // // //         const relative_speed = currentPhysics.effective_field_velocity_scalar - currentPhysics.shell_angular_velocity_scalar;\n// // // // // // // // //         currentPhysics.current_torque_scalar = resonatorControls.k_drag * resonatorControls.fieldIntensity * relative_speed;\n// // // // // // // // //         const angular_acceleration = effectiveInertia > 0 ? (currentPhysics.current_torque_scalar / effectiveInertia) : 0; // Avoid divide by zero\n// // // // // // // // //         currentPhysics.shell_angular_velocity_scalar += angular_acceleration * delta;\n// // // // // // // // //         currentPhysics.shell_angular_velocity_scalar *= (1 - resonatorControls.damping * delta);\n// // // // // // // // //         currentPhysics.effective_field_velocity_scalar = resonatorControls.baseFieldSpeed + resonatorControls.k_feedback * currentPhysics.shell_angular_velocity_scalar;\n\n// // // // // // // // //         // --- FIX: Rotate the Group ---\n// // // // // // // // //         if (groupRef.current) {\n// // // // // // // // //              // console.log(\"Ang Vel:\", currentPhysics.shell_angular_velocity_scalar); // DEBUG Rotation\n// // // // // // // // //              groupRef.current.rotation.y += currentPhysics.shell_angular_velocity_scalar * delta;\n// // // // // // // // //         }\n\n// // // // // // // // //         // Emissive effect (applied to mesh material directly)\n// // // // // // // // //         if (dodecahedronMeshRef.current) { // Use the mesh ref here\n// // // // // // // // //              const material = dodecahedronMeshRef.current.material as THREE.MeshStandardMaterial;\n// // // // // // // // //              if (material?.emissive) {\n// // // // // // // // //                  const maxTorqueEst = resonatorControls.k_drag * resonatorControls.fieldIntensity * (Math.abs(resonatorControls.baseFieldSpeed) * 1.5 + 1);\n// // // // // // // // //                  const emissionStrength = Math.min(Math.abs(currentPhysics.current_torque_scalar) / (maxTorqueEst + 0.01), 1.0);\n// // // // // // // // //                  material.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5);\n// // // // // // // // //              }\n// // // // // // // // //         }\n\n// // // // // // // // //         // Particle Field Update\n// // // // // // // // //         if (vizControls.showParticles && /* ... other checks ... */ particleGeoRef.current?.attributes.position) {\n// // // // // // // // //             /* ... particle position updates ... */\n// // // // // // // // //             const positions = particleGeoRef.current.attributes.position.array as Float32Array;\n// // // // // // // // //             const speed = currentPhysics.effective_field_velocity_scalar * resonatorControls.fieldIntensity;\n// // // // // // // // //             const pData = particleData?.data; // Check particleData exists\n// // // // // // // // //             if (pData && pData.length * 3 === positions.length) {\n// // // // // // // // //                 // Update material properties (can be done less frequently if performance matters)\n// // // // // // // // //                 const pointsMat = particlesRef.current?.material as THREE.PointsMaterial;\n// // // // // // // // //                 if(pointsMat) {\n// // // // // // // // //                     pointsMat.size = vizControls.particleSize * (1 + resonatorControls.fieldIntensity * 0.5);\n// // // // // // // // //                     // pointsMat.needsUpdate = true; // Usually not needed for size/color uniform changes\n// // // // // // // // //                 }\n// // // // // // // // //                 for (let i = 0; i < pData.length; i++) { /* ... update particle positions ... */ }\n// // // // // // // // //                 particleGeoRef.current.attributes.position.needsUpdate = true;\n// // // // // // // // //             }\n// // // // // // // // //         }\n// // // // // // // // //     });\n\n// // // // // // // // //     // Memoized Copper Material\n// // // // // // // // //     const copperMaterial = useMemo(() => new THREE.MeshStandardMaterial({ name: 'Copper CSG Material', color: 0xB87333, metalness: 0.8, roughness: 0.3, emissive: 0x000000, emissiveIntensity: 1.0, side: THREE.DoubleSide }), []);\n\n// // // // // // // // //     return (\n// // // // // // // // //         // --- FIX: Wrap Dodecahedron in a Group ---\n// // // // // // // // //         <group ref={groupRef}>\n// // // // // // // // //             <RomanDodecahedron\n// // // // // // // // //                 ref={dodecahedronMeshRef} // Pass mesh ref here\n// // // // // // // // //                 outerRadius={finalShellParams.outerRadius}\n// // // // // // // // //                 thickness={finalShellParams.thickness}\n// // // // // // // // //                 holeBaseDiameter={finalShellParams.holeBaseDiameter}\n// // // // // // // // //                 holeRatio={finalShellParams.holeRatio}\n// // // // // // // // //                 noduleRadius={finalShellParams.noduleRadius}\n// // // // // // // // //                 material={copperMaterial}\n// // // // // // // // //                 wireframe={vizControls.wireframe}\n// // // // // // // // //                 castShadow receiveShadow\n// // // // // // // // //                 // Position/rotation of the mesh itself should be zero, group handles it\n// // // // // // // // //                 position={[0,0,0]}\n// // // // // // // // //                 rotation={[0,0,0]}\n// // // // // // // // //             />\n// // // // // // // // //             {/* --- FIX: Add PointLight inside the group --- */}\n// // // // // // // // //             <pointLight intensity={0.4} color={0xffaa88} distance={3} decay={1.5} position={[0, 0, 0]} />\n// // // // // // // // //             {/* Particles remain children of the main simulation component, not the group */}\n// // // // // // // // //             {vizControls.showParticles && (\n// // // // // // // // //                  <points ref={particlesRef} name=\"FieldParticles\">\n// // // // // // // // //                      <bufferGeometry ref={particleGeoRef} />\n// // // // // // // // //                      <pointsMaterial name=\"ParticleMaterial\" color={0x00ffff} size={vizControls.particleSize} transparent opacity={0.7} blending={THREE.AdditiveBlending} sizeAttenuation={false} map={null} />\n// // // // // // // // //                  </points>\n// // // // // // // // //             )}\n// // // // // // // // //         </group> // End group\n// // // // // // // // //     );\n// // // // // // // // // };\n\n// // // // // // // // // // --- Scene Component ---\n// // // // // // // // // const TemporalResonatorScene: React.FC = () => {\n// // // // // // // // //      return ( /* ... Canvas, Leva, Lights etc ... */\n// // // // // // // // //         <>\n// // // // // // // // //             <Leva collapsed={false} titleBar={{ title: 'Controls' }} />\n// // // // // // // // //             <Canvas style={{ /*...*/ }} camera={{ position: [3, 3, 5], fov: 75 }} gl={{ antialias: true }} shadows >\n// // // // // // // // //                  <ambientLight intensity={0.4} /> {/* Slightly less ambient */}\n// // // // // // // // //                  <hemisphereLight groundColor={0x404040} intensity={0.8} /> {/* Slightly less hemi */}\n// // // // // // // // //                  <directionalLight position={[5, 10, 7.5]} intensity={1.2} castShadow /*...*/ />\n// // // // // // // // //                  <ErrorBoundary> <Suspense fallback={<LoadingPlaceholder />}> <ResonatorSimulation /> </Suspense> </ErrorBoundary>\n// // // // // // // // //                  <Controls />\n// // // // // // // // //                  <axesHelper args={[5]} />\n// // // // // // // // //             </Canvas>\n// // // // // // // // //         </>\n// // // // // // // // //      );\n// // // // // // // // //  };\n// // // // // // // // // // --- Loading Placeholder ---\n// // // // // // // // // const LoadingPlaceholder: React.FC = () => { return <div>Loading...</div>; };\n// // // // // // // // // export default TemporalResonatorScene;\n\n\n// // // // // // // // // // // === Full Code: TemporalResonatorScene_V2_CSG_Fixes_10.tsx ===\n\n// // // // // // // // // // import React, { useRef, useEffect, useMemo, Suspense, useState } from 'react';\n// // // // // // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // // // // // // import * as THREE from 'three';\n// // // // // // // // // // import ErrorBoundary from './errorBoundary'; // Adjust path if needed\n// // // // // // // // // // import { useControls, Leva } from 'leva';\n// // // // // // // // // // import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\n// // // // // // // // // // import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n\n// // // // // // // // // // // --- BVH / CSG Setup ---\n// // // // // // // // // // try {\n// // // // // // // // // //     THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\n// // // // // // // // // //     THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\n// // // // // // // // // //     THREE.Mesh.prototype.raycast = acceleratedRaycast;\n// // // // // // // // // // } catch (error) { console.error(\"Error setting up BVH extensions:\", error); }\n// // // // // // // // // // const csgEvaluator = new Evaluator();\n// // // // // // // // // // csgEvaluator.useGroups = true;\n// // // // // // // // // // extend({ OrbitControls });\n\n// // // // // // // // // // // --- Constants ---\n// // // // // // // // // // const PHI = (1 + Math.sqrt(5)) / 2;\n// // // // // // // // // // const INV_PHI = 1 / PHI;\n\n// // // // // // // // // // // --- Helper: Get Dodecahedron Math Data ---\n// // // // // // // // // // function getDodecahedronData(radius: number): { vertices: THREE.Vector3[]; faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] } {\n// // // // // // // // // //     console.log(`--- Calculating Dodecahedron Data for radius: ${radius} ---`);\n// // // // // // // // // //     if (typeof radius !== 'number' || radius <= 0 || !Number.isFinite(radius)) {\n// // // // // // // // // //         throw new Error(\"Invalid radius provided to getDodecahedronData\");\n// // // // // // // // // //     }\n// // // // // // // // // //     const uniqueVerticesMap = new Map<string, THREE.Vector3>();\n// // // // // // // // // //     const coords = [ [1, 1, 1], [-1, 1, 1], [1, -1, 1], [-1, -1, 1], [1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1], [0, PHI, INV_PHI], [0, -PHI, INV_PHI], [0, PHI, -INV_PHI], [0, -PHI, -INV_PHI], [INV_PHI, 0, PHI], [-INV_PHI, 0, PHI], [INV_PHI, 0, -PHI], [-INV_PHI, 0, -PHI], [PHI, INV_PHI, 0], [-PHI, INV_PHI, 0], [PHI, -INV_PHI, 0], [-PHI, -INV_PHI, 0] ];\n// // // // // // // // // //     const distOriginToVertex = Math.sqrt(PHI * PHI + INV_PHI * INV_PHI);\n// // // // // // // // // //     const scale = radius / distOriginToVertex;\n// // // // // // // // // //     if (!Number.isFinite(scale) || scale === 0) { throw new Error(\"Invalid scale factor\"); }\n// // // // // // // // // //     coords.forEach(v => { const x = v[0] * scale; const y = v[1] * scale; const z = v[2] * scale; const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`; if (!uniqueVerticesMap.has(key)) { uniqueVerticesMap.set(key, new THREE.Vector3(x, y, z)); } });\n// // // // // // // // // //     const vertices = Array.from(uniqueVerticesMap.values());\n// // // // // // // // // //     const faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] = [];\n// // // // // // // // // //     const icoVerts = [ [0, 1, PHI], [0, -1, PHI], [0, 1, -PHI], [0, -1, -PHI], [1, PHI, 0], [-1, PHI, 0], [1, -PHI, 0], [-1, -PHI, 0], [PHI, 0, 1], [-PHI, 0, 1], [PHI, 0, -1], [-PHI, 0, -1] ];\n// // // // // // // // // //     const faceCenterDist = radius * 1.53 / distOriginToVertex;\n// // // // // // // // // //     icoVerts.forEach(v => { const normal = new THREE.Vector3(v[0], v[1], v[2]).normalize(); const center = normal.clone().multiplyScalar(faceCenterDist); faceData.push({ center, normal }); });\n// // // // // // // // // //     if (vertices.length !== 20 || faceData.length !== 12) { console.error(\"!!! Vertex/Face generation failed. Vertices:\", vertices, \"Faces:\", faceData); throw new Error(`Incorrect math data count: ${vertices.length} vertices, ${faceData.length} faces`); }\n// // // // // // // // // //     console.log(`--- Generated ${vertices.length} vertices, ${faceData.length} faces. ---`);\n// // // // // // // // // //     return { vertices, faceData };\n// // // // // // // // // // }\n\n// // // // // // // // // // // --- Controls Component ---\n// // // // // // // // // // const Controls: React.FC = () => {\n// // // // // // // // // //      const { camera, gl } = useThree(); const controlsRef = useRef<OrbitControls>(null);\n// // // // // // // // // //      useEffect(() => { const controls = new OrbitControls(camera, gl.domElement); controls.enableDamping = true; (controlsRef as any).current = controls; return () => { controls.dispose(); }; }, [camera, gl]);\n// // // // // // // // // //      useFrame(() => { controlsRef.current?.update(); }); return null;\n// // // // // // // // // // };\n\n// // // // // // // // // // // --- Roman Dodecahedron CSG Component ---\n// // // // // // // // // // interface RomanDodecahedronProps { outerRadius: number; thickness: number; holeBaseDiameter: number; holeRatio: number; noduleRadius: number; material?: THREE.Material; wireframe?: boolean; [key: string]: any; } // Added wireframe prop\n// // // // // // // // // // const RomanDodecahedron: React.FC<RomanDodecahedronProps> = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>(\n// // // // // // // // // //     ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, wireframe = false, ...props }, ref) => { // Default wireframe to false\n// // // // // // // // // //     const [calculatedGeometry, setCalculatedGeometry] = useState<THREE.BufferGeometry | null>(null);\n\n// // // // // // // // // //     useEffect(() => {\n// // // // // // // // // //         console.log(`useEffect Check: outerRadius=${outerRadius} (${typeof outerRadius}), thickness=${thickness}, ...`);\n// // // // // // // // // //         if ( typeof outerRadius !== 'number' || outerRadius <= 0 || !Number.isFinite(outerRadius) || typeof thickness !== 'number' || thickness <= 0 || !Number.isFinite(thickness) || typeof holeBaseDiameter !== 'number' || holeBaseDiameter <= 0 || !Number.isFinite(holeBaseDiameter) || typeof holeRatio !== 'number' || holeRatio <= 0 || !Number.isFinite(holeRatio) || typeof noduleRadius !== 'number' || noduleRadius <= 0 || !Number.isFinite(noduleRadius) ) {\n// // // // // // // // // //             console.log(`--> Skipping CSG calculation in useEffect: Invalid props detected.`); setCalculatedGeometry(null); return;\n// // // // // // // // // //         }\n// // // // // // // // // //         console.log(`Calculating CSG Geometry in useEffect for outerRadius: ${outerRadius}`);\n// // // // // // // // // //         let geometry: THREE.BufferGeometry | null = null; const detailLevel = 1; let tempGeoList: THREE.BufferGeometry[] = [];\n// // // // // // // // // //         try {\n// // // // // // // // // //             const { vertices: mathVertices, faceData: mathFaceData } = getDodecahedronData(outerRadius);\n// // // // // // // // // //             const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, detailLevel); outerDodecGeo.computeBoundsTree(); tempGeoList.push(outerDodecGeo);\n// // // // // // // // // //             const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, detailLevel); innerDodecGeo.computeBoundsTree(); tempGeoList.push(innerDodecGeo);\n// // // // // // // // // //             let outerBrush = new Brush(outerDodecGeo); let innerBrush = new Brush(innerDodecGeo); innerBrush.updateMatrixWorld();\n// // // // // // // // // //             let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n// // // // // // // // // //             const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * (holeRatio ** i));\n// // // // // // // // // //             const cylinderHeight = thickness * 3; const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16); cylinderGeo.rotateX(Math.PI / 2); cylinderGeo.computeBoundsTree(); tempGeoList.push(cylinderGeo);\n// // // // // // // // // //             const tempQuat = new THREE.Quaternion();\n// // // // // // // // // //             mathFaceData.forEach((face, index) => { const holeRadius = holeDiameters[index] / 2; if (!holeRadius || holeRadius <= 0) return; const holeBrush = new Brush(cylinderGeo); holeBrush.scale.set(holeRadius, holeRadius, 1); tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), face.normal); holeBrush.quaternion.copy(tempQuat); holeBrush.position.copy(face.center); holeBrush.updateMatrixWorld(); shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION); });\n// // // // // // // // // //             const noduleGeo = new THREE.SphereGeometry(noduleRadius, 6, 6); noduleGeo.computeBoundsTree(); tempGeoList.push(noduleGeo);\n// // // // // // // // // //             mathVertices.forEach(vertexPos => { const noduleBrush = new Brush(noduleGeo); noduleBrush.position.copy(vertexPos); noduleBrush.updateMatrixWorld(); shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION); });\n// // // // // // // // // //             geometry = shellBrush.geometry; geometry.computeVertexNormals(); geometry.center();\n// // // // // // // // // //             console.log(\"CSG Calculation Complete.\");\n// // // // // // // // // //         } catch (error) { console.error(\"CSG Error in useEffect:\", error); geometry = null; }\n// // // // // // // // // //         finally { tempGeoList.forEach(g => g.dispose()); console.log(`Disposed ${tempGeoList.length} temporary CSG geometries.`); }\n// // // // // // // // // //         setCalculatedGeometry(geometry);\n// // // // // // // // // //         return () => { if (geometry && typeof geometry.dispose === 'function') { geometry.dispose(); console.log(\"Disposed final CSG geometry from useEffect cleanup.\"); } };\n// // // // // // // // // //     }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]);\n\n// // // // // // // // // //     // Memoize the material instance based on wireframe prop\n// // // // // // // // // //     const meshMaterial = useMemo(() => {\n// // // // // // // // // //         const baseMaterial = material instanceof THREE.Material ? material.clone() : new THREE.MeshStandardMaterial({ color: 0xB87333, side: THREE.DoubleSide });\n// // // // // // // // // //         // Modify the cloned or default material if it is a MeshStandardMaterial\n// // // // // // // // // //         if (baseMaterial instanceof THREE.MeshStandardMaterial) {\n// // // // // // // // // //              baseMaterial.wireframe = wireframe; // Set wireframe based on prop\n// // // // // // // // // //              baseMaterial.metalness = wireframe ? 0.1 : 0.8; // Reduce metalness in wireframe\n// // // // // // // // // //              baseMaterial.roughness = wireframe ? 0.8 : 0.3; // Increase roughness\n// // // // // // // // // //         }\n// // // // // // // // // //         return baseMaterial;\n// // // // // // // // // //     }, [material, wireframe]); // Recreate material if base material or wireframe changes\n\n// // // // // // // // // //     useEffect(() => {\n// // // // // // // // // //          // Cleanup for memoized material\n// // // // // // // // // //          return () => { meshMaterial?.dispose(); }\n// // // // // // // // // //     }, [meshMaterial]);\n\n// // // // // // // // // //     if (!calculatedGeometry) { return null; }\n// // // // // // // // // //     return <mesh ref={ref} geometry={calculatedGeometry} material={meshMaterial} {...props} />;\n// // // // // // // // // // });\n\n// // // // // // // // // // // --- Physics State Interface ---\n// // // // // // // // // // interface PhysicsState { shell_angular_velocity_scalar: number; effective_field_velocity_scalar: number; current_torque_scalar: number; }\n\n// // // // // // // // // // // --- Main Simulation Component ---\n// // // // // // // // // // const ResonatorSimulation: React.FC = () => {\n// // // // // // // // // //     const dodecahedronRef = useRef<THREE.Mesh>(null!);\n// // // // // // // // // //     const particlesRef = useRef<THREE.Points>(null!);\n// // // // // // // // // //     const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // // // // // // // // //     // Leva controls definition\n// // // // // // // // // //     const resonatorControls = useControls('Resonator Controls', { /* ... */ });\n// // // // // // // // // //     const shellControls = useControls('Shell Geometry', { /* ... */ });\n// // // // // // // // // //     const vizControls = useControls('Visualization', {\n// // // // // // // // // //         particleCount: { value: 1000, min: 100, max: 5000, step: 100 },\n// // // // // // // // // //         particleSize: { value: 0.05, min: 0.01, max: 0.2, step: 0.01 },\n// // // // // // // // // //         torusMajorRadius: { value: 1.5, min: 0.5, max: 5, step: 0.1 },\n// // // // // // // // // //         torusMinorRadius: { value: 0.5, min: 0.1, max: 2, step: 0.05 },\n// // // // // // // // // //         showParticles: true,\n// // // // // // // // // //         wireframe: false, // Add wireframe toggle\n// // // // // // // // // //     });\n\n// // // // // // // // // //     // Combine leva controls with defaults\n// // // // // // // // // //     const defaultShellParams = useMemo(() => ({ outerRadius: 1.0, thickness: 0.05, holeBaseDiameter: 0.1, holeRatio: 1.2, noduleRadius: 0.1 }), []);\n// // // // // // // // // //     const finalShellParams = useMemo(() => ({\n// // // // // // // // // //         outerRadius: (typeof (shellControls as any).outerRadius === 'number' && Number.isFinite((shellControls as any).outerRadius)) ? (shellControls as any).outerRadius : defaultShellParams.outerRadius,\n// // // // // // // // // //         thickness: (typeof (shellControls as any).thickness === 'number' && Number.isFinite((shellControls as any).thickness)) ? (shellControls as any).thickness : defaultShellParams.thickness,\n// // // // // // // // // //         holeBaseDiameter: (typeof (shellControls as any).holeBaseDiameter === 'number' && Number.isFinite((shellControls as any).holeBaseDiameter)) ? (shellControls as any).holeBaseDiameter : defaultShellParams.holeBaseDiameter,\n// // // // // // // // // //         holeRatio: (typeof (shellControls as any).holeRatio === 'number' && Number.isFinite((shellControls as any).holeRatio)) ? (shellControls as any).holeRatio : defaultShellParams.holeRatio,\n// // // // // // // // // //         noduleRadius: (typeof (shellControls as any).noduleRadius === 'number' && Number.isFinite((shellControls as any).noduleRadius)) ? (shellControls as any).noduleRadius : defaultShellParams.noduleRadius,\n// // // // // // // // // //     }), [shellControls, defaultShellParams]);\n\n// // // // // // // // // //     // Inertia calculation (cast resonatorControls to any to avoid unknown type error)\n// // // // // // // // // //     const effectiveInertia = useMemo(() => (resonatorControls as any).inertiaScale * (finalShellParams.outerRadius ** 5 - (finalShellParams.outerRadius - finalShellParams.thickness) ** 5) / finalShellParams.outerRadius ** 5, [(resonatorControls as any).inertiaScale, finalShellParams.outerRadius, finalShellParams.thickness]);\n// // // // // // // // // //     // Physics state (cast resonatorControls to any)\n// // // // // // // // // //     const physicsState = useRef<PhysicsState>({ shell_angular_velocity_scalar: 0.0, effective_field_velocity_scalar: (resonatorControls as any).baseFieldSpeed || 0, current_torque_scalar: 0.0 });\n// // // // // // // // // //     // Particle data (unused variables; remove these if you do not plan to use them to avoid warnings)\n// // // // // // // // // //     const particleData = useMemo(() => { /* ... create particle data ... */ }, [vizControls.particleCount, vizControls.torusMajorRadius, vizControls.torusMinorRadius]);\n// // // // // // // // // //     // Particle buffer effect\n// // // // // // // // // //     useEffect(() => { /* ... particle buffer update effect ... */ }, [particleData]);\n// // // // // // // // // //     // Animation loop\n// // // // // // // // // //     useFrame((state, delta) => { /* ... V1 physics + Visual updates ... */ });\n// // // // // // // // // //     // Copper Material\n// // // // // // // // // //     const copperMaterial = useMemo(() => new THREE.MeshStandardMaterial({ name: 'Copper CSG Material', color: 0xB87333, metalness: 0.8, roughness: 0.3, emissive: 0x000000, emissiveIntensity: 1.0, side: THREE.DoubleSide }), []);\n\n// // // // // // // // // //     return (\n// // // // // // // // // //         <>\n// // // // // // // // // //             <RomanDodecahedron\n// // // // // // // // // //                 ref={dodecahedronRef}\n// // // // // // // // // //                 outerRadius={finalShellParams.outerRadius}\n// // // // // // // // // //                 thickness={finalShellParams.thickness}\n// // // // // // // // // //                 holeBaseDiameter={finalShellParams.holeBaseDiameter}\n// // // // // // // // // //                 holeRatio={finalShellParams.holeRatio}\n// // // // // // // // // //                 noduleRadius={finalShellParams.noduleRadius}\n// // // // // // // // // //                 material={copperMaterial} // Pass the base copper material\n// // // // // // // // // //                 wireframe={vizControls.wireframe} // Control wireframe via leva\n// // // // // // // // // //                 castShadow receiveShadow\n// // // // // // // // // //             />\n// // // // // // // // // //             {vizControls.showParticles && (\n// // // // // // // // // //                  <points ref={particlesRef} name=\"FieldParticles\">\n// // // // // // // // // //                      <bufferGeometry ref={particleGeoRef} />\n// // // // // // // // // //                      <pointsMaterial\n// // // // // // // // // //                          name=\"ParticleMaterial\" color={0x00ffff} size={vizControls.particleSize}\n// // // // // // // // // //                          transparent opacity={0.7} blending={THREE.AdditiveBlending}\n// // // // // // // // // //                          sizeAttenuation={false} // <-- Set to false\n// // // // // // // // // //                          map={null}\n// // // // // // // // // //                      />\n// // // // // // // // // //                  </points>\n// // // // // // // // // //             )}\n// // // // // // // // // //         </>\n// // // // // // // // // //     );\n// // // // // // // // // // };\n\n// // // // // // // // // // // --- Scene Component ---\n// // // // // // // // // // const TemporalResonatorScene: React.FC = () => { /* ... */\n// // // // // // // // // //      return (\n// // // // // // // // // //          <>\n// // // // // // // // // //              <Leva collapsed={false} titleBar={{ title: 'Controls' }} />\n// // // // // // // // // //              <Canvas style={{ /*...*/ }} camera={{ /*...*/ }} gl={{ antialias: true }} shadows >\n// // // // // // // // // //                  {/* Lights */}\n// // // // // // // // // //                  <ambientLight intensity={0.5} />\n// // // // // // // // // //                  <hemisphereLight groundColor={0x404040} intensity={1.0} />\n// // // // // // // // // //                  <directionalLight position={[5, 10, 7.5]} intensity={1.5} castShadow /*...*/ />\n// // // // // // // // // //                  <ErrorBoundary>\n// // // // // // // // // //                      <Suspense fallback={<LoadingPlaceholder />}>\n// // // // // // // // // //                           <ResonatorSimulation />\n// // // // // // // // // //                      </Suspense>\n// // // // // // // // // //                  </ErrorBoundary>\n// // // // // // // // // //                  <Controls />\n// // // // // // // // // //                  {/* <axesHelper args={[5]} /> */}\n// // // // // // // // // //                  {/* <gridHelper args={[10, 10]} /> */}\n// // // // // // // // // //              </Canvas>\n// // // // // // // // // //          </>\n// // // // // // // // // //      );\n// // // // // // // // // //  };\n\n// // // // // // // // // // // --- Loading Placeholder ---\n// // // // // // // // // // const LoadingPlaceholder: React.FC = () => { return <div>Loading...</div>; };\n\n// // // // // // // // // // export default TemporalResonatorScene;\n\n\n// // // // // // // // // // // === Full Code: TemporalResonatorScene_V2_CSG_Complete.tsx ===\n\n// // // // // // // // // // // Ensure imports are correct for your project structure\n// // // // // // // // // // import React, { useRef, useEffect, useMemo, Suspense, useState } from 'react';\n// // // // // // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // // // // // // import * as THREE from 'three';\n// // // // // // // // // // import ErrorBoundary from './errorBoundary'; // Adjust path if needed\n// // // // // // // // // // import { useControls, Leva } from 'leva';\n// // // // // // // // // // import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\n// // // // // // // // // // import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n\n// // // // // // // // // // // --- BVH / CSG Setup ---\n// // // // // // // // // // // Ensure these run reliably at the top level\n// // // // // // // // // // try {\n// // // // // // // // // //     THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\n// // // // // // // // // //     THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\n// // // // // // // // // //     THREE.Mesh.prototype.raycast = acceleratedRaycast;\n// // // // // // // // // // } catch (error) {\n// // // // // // // // // //     console.error(\"Error setting up BVH extensions:\", error);\n// // // // // // // // // // }\n// // // // // // // // // // const csgEvaluator = new Evaluator();\n// // // // // // // // // // csgEvaluator.useGroups = true;\n// // // // // // // // // // extend({ OrbitControls }); // Extend R3F for OrbitControls\n\n// // // // // // // // // // // --- Constants ---\n// // // // // // // // // // const PHI = (1 + Math.sqrt(5)) / 2;\n// // // // // // // // // // const INV_PHI = 1 / PHI;\n\n// // // // // // // // // // // --- Helper: Get Dodecahedron Math Data ---\n// // // // // // // // // // function getDodecahedronData(radius: number): { vertices: THREE.Vector3[]; faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] } {\n// // // // // // // // // //     console.log(`--- Calculating Dodecahedron Data for radius: ${radius} ---`);\n// // // // // // // // // //     if (typeof radius !== 'number' || radius <= 0 || !Number.isFinite(radius)) {\n// // // // // // // // // //         console.error(\"!!! Invalid radius passed to getDodecahedronData:\", radius);\n// // // // // // // // // //         throw new Error(\"Invalid radius provided to getDodecahedronData\");\n// // // // // // // // // //     }\n\n// // // // // // // // // //     const uniqueVerticesMap = new Map<string, THREE.Vector3>();\n// // // // // // // // // //     const coords = [\n// // // // // // // // // //         [1, 1, 1], [-1, 1, 1], [1, -1, 1], [-1, -1, 1], [1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1],\n// // // // // // // // // //         [0, PHI, INV_PHI], [0, -PHI, INV_PHI], [0, PHI, -INV_PHI], [0, -PHI, -INV_PHI],\n// // // // // // // // // //         [INV_PHI, 0, PHI], [-INV_PHI, 0, PHI], [INV_PHI, 0, -PHI], [-INV_PHI, 0, -PHI],\n// // // // // // // // // //         [PHI, INV_PHI, 0], [-PHI, INV_PHI, 0], [PHI, -INV_PHI, 0], [-PHI, -INV_PHI, 0]\n// // // // // // // // // //     ];\n// // // // // // // // // //     const distOriginToVertex = Math.sqrt(PHI * PHI + INV_PHI * INV_PHI);\n// // // // // // // // // //     const scale = radius / distOriginToVertex;\n// // // // // // // // // //     if (!Number.isFinite(scale) || scale === 0) { throw new Error(\"Invalid scale factor\"); }\n\n// // // // // // // // // //     coords.forEach(v => {\n// // // // // // // // // //         const x = v[0] * scale; const y = v[1] * scale; const z = v[2] * scale;\n// // // // // // // // // //         const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`;\n// // // // // // // // // //         if (!uniqueVerticesMap.has(key)) { uniqueVerticesMap.set(key, new THREE.Vector3(x, y, z)); }\n// // // // // // // // // //     });\n// // // // // // // // // //     const vertices = Array.from(uniqueVerticesMap.values());\n\n// // // // // // // // // //     const faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] = [];\n// // // // // // // // // //     const icoVerts = [ [0, 1, PHI], [0, -1, PHI], [0, 1, -PHI], [0, -1, -PHI], [1, PHI, 0], [-1, PHI, 0], [1, -PHI, 0], [-1, -PHI, 0], [PHI, 0, 1], [-PHI, 0, 1], [PHI, 0, -1], [-PHI, 0, -1] ];\n// // // // // // // // // //     const faceCenterDist = radius * 1.53 / distOriginToVertex; // Relative positioning\n\n// // // // // // // // // //     icoVerts.forEach(v => {\n// // // // // // // // // //         const normal = new THREE.Vector3(v[0], v[1], v[2]).normalize();\n// // // // // // // // // //         const center = normal.clone().multiplyScalar(faceCenterDist);\n// // // // // // // // // //         faceData.push({ center, normal });\n// // // // // // // // // //     });\n\n// // // // // // // // // //     if (vertices.length !== 20 || faceData.length !== 12) {\n// // // // // // // // // //         console.error(\"!!! Vertex/Face generation failed. Vertices:\", vertices, \"Faces:\", faceData);\n// // // // // // // // // //         throw new Error(`Incorrect math data count: ${vertices.length} vertices, ${faceData.length} faces`);\n// // // // // // // // // //     }\n// // // // // // // // // //     console.log(`--- Generated ${vertices.length} vertices, ${faceData.length} faces. ---`);\n// // // // // // // // // //     return { vertices, faceData };\n// // // // // // // // // // }\n\n// // // // // // // // // // // --- Controls Component ---\n// // // // // // // // // // const Controls: React.FC = () => {\n// // // // // // // // // //      const { camera, gl } = useThree();\n// // // // // // // // // //      const controlsRef = useRef<OrbitControls>(null);\n// // // // // // // // // //      useEffect(() => {\n// // // // // // // // // //        const controls = new OrbitControls(camera, gl.domElement);\n// // // // // // // // // //        controls.enableDamping = true;\n// // // // // // // // // //        (controlsRef as React.MutableRefObject<OrbitControls>).current = controls;\n// // // // // // // // // //        return () => { controls.dispose(); };\n// // // // // // // // // //      }, [camera, gl]);\n// // // // // // // // // //      useFrame(() => { controlsRef.current?.update(); });\n// // // // // // // // // //      return null;\n// // // // // // // // // // };\n\n// // // // // // // // // // // --- Roman Dodecahedron CSG Component ---\n// // // // // // // // // // interface RomanDodecahedronProps {\n// // // // // // // // // //     outerRadius: number; thickness: number; holeBaseDiameter: number;\n// // // // // // // // // //     holeRatio: number; noduleRadius: number; material?: THREE.Material;\n// // // // // // // // // //     [key: string]: any;\n// // // // // // // // // // }\n// // // // // // // // // // const RomanDodecahedron: React.FC<RomanDodecahedronProps> = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>(\n// // // // // // // // // //     ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, ...props }, ref) => {\n// // // // // // // // // //     const [calculatedGeometry, setCalculatedGeometry] = useState<THREE.BufferGeometry | null>(null);\n\n// // // // // // // // // //     useEffect(() => {\n// // // // // // // // // //         console.log(`useEffect Check: outerRadius=${outerRadius} (${typeof outerRadius}), thickness=${thickness}, ...`);\n// // // // // // // // // //         if ( typeof outerRadius !== 'number' || outerRadius <= 0 || !Number.isFinite(outerRadius) || typeof thickness !== 'number' || thickness <= 0 || !Number.isFinite(thickness) || typeof holeBaseDiameter !== 'number' || holeBaseDiameter <= 0 || !Number.isFinite(holeBaseDiameter) || typeof holeRatio !== 'number' || holeRatio <= 0 || !Number.isFinite(holeRatio) || typeof noduleRadius !== 'number' || noduleRadius <= 0 || !Number.isFinite(noduleRadius) ) {\n// // // // // // // // // //             console.log(`--> Skipping CSG calculation in useEffect: Invalid props detected.`);\n// // // // // // // // // //             setCalculatedGeometry(null); return;\n// // // // // // // // // //         }\n\n// // // // // // // // // //         console.log(`Calculating CSG Geometry in useEffect for outerRadius: ${outerRadius}`);\n// // // // // // // // // //         let geometry: THREE.BufferGeometry | null = null;\n// // // // // // // // // //         const detailLevel = 1;\n// // // // // // // // // //         let tempGeoList: THREE.BufferGeometry[] = []; // Keep track of temp geos to dispose\n\n// // // // // // // // // //         try {\n// // // // // // // // // //             const { vertices: mathVertices, faceData: mathFaceData } = getDodecahedronData(outerRadius);\n\n// // // // // // // // // //             const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, detailLevel); outerDodecGeo.computeBoundsTree(); tempGeoList.push(outerDodecGeo);\n// // // // // // // // // //             const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, detailLevel); innerDodecGeo.computeBoundsTree(); tempGeoList.push(innerDodecGeo);\n// // // // // // // // // //             let outerBrush = new Brush(outerDodecGeo); let innerBrush = new Brush(innerDodecGeo); innerBrush.updateMatrixWorld();\n// // // // // // // // // //             let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n\n// // // // // // // // // //             const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * (holeRatio ** i));\n// // // // // // // // // //             const cylinderHeight = thickness * 3;\n// // // // // // // // // //             const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16); cylinderGeo.rotateX(Math.PI / 2); cylinderGeo.computeBoundsTree(); tempGeoList.push(cylinderGeo);\n// // // // // // // // // //             const tempQuat = new THREE.Quaternion();\n\n// // // // // // // // // //             mathFaceData.forEach((face, index) => {\n// // // // // // // // // //                 const holeRadius = holeDiameters[index] / 2; if (!holeRadius || holeRadius <= 0) return;\n// // // // // // // // // //                 const holeBrush = new Brush(cylinderGeo); holeBrush.scale.set(holeRadius, holeRadius, 1);\n// // // // // // // // // //                 tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), face.normal); holeBrush.quaternion.copy(tempQuat);\n// // // // // // // // // //                 holeBrush.position.copy(face.center); holeBrush.updateMatrixWorld();\n// // // // // // // // // //                 shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION);\n// // // // // // // // // //             });\n\n// // // // // // // // // //             const noduleGeo = new THREE.SphereGeometry(noduleRadius, 6, 6); noduleGeo.computeBoundsTree(); tempGeoList.push(noduleGeo);\n// // // // // // // // // //             mathVertices.forEach(vertexPos => {\n// // // // // // // // // //                 const noduleBrush = new Brush(noduleGeo); noduleBrush.position.copy(vertexPos);\n// // // // // // // // // //                 noduleBrush.updateMatrixWorld(); shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION);\n// // // // // // // // // //             });\n\n// // // // // // // // // //             geometry = shellBrush.geometry;\n// // // // // // // // // //             geometry.computeVertexNormals(); // Crucial for lighting\n// // // // // // // // // //             geometry.center(); // Center the final shape\n// // // // // // // // // //             console.log(\"CSG Calculation Complete.\");\n\n// // // // // // // // // //         } catch (error) {\n// // // // // // // // // //             console.error(\"CSG Error in useEffect:\", error);\n// // // // // // // // // //             geometry = null;\n// // // // // // // // // //         } finally {\n// // // // // // // // // //              // Dispose all temporary geometries used for brushes\n// // // // // // // // // //              tempGeoList.forEach(g => g.dispose());\n// // // // // // // // // //              console.log(`Disposed ${tempGeoList.length} temporary CSG geometries.`);\n// // // // // // // // // //         }\n\n// // // // // // // // // //         setCalculatedGeometry(geometry);\n\n// // // // // // // // // //         // Cleanup function disposes the *final* geometry state if it exists\n// // // // // // // // // //         return () => {\n// // // // // // // // // //             // The 'geometry' variable here refers to the one calculated in *this* effect run\n// // // // // // // // // //             if (geometry && typeof geometry.dispose === 'function') {\n// // // // // // // // // //                 geometry.dispose();\n// // // // // // // // // //                 console.log(\"Disposed final CSG geometry from useEffect cleanup.\");\n// // // // // // // // // //             }\n// // // // // // // // // //         };\n// // // // // // // // // //     }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]);\n\n// // // // // // // // // //     if (!calculatedGeometry) { return null; }\n// // // // // // // // // //     // Default to a basic red material if none provided, easier to see than black\n// // // // // // // // // //     const meshMaterial = material || new THREE.MeshStandardMaterial({ color: 0xff0000, side: THREE.DoubleSide });\n// // // // // // // // // //     return <mesh ref={ref} geometry={calculatedGeometry} material={meshMaterial} {...props} />;\n// // // // // // // // // // });\n\n// // // // // // // // // // // --- Physics State Interface ---\n// // // // // // // // // // interface PhysicsState {\n// // // // // // // // // //     shell_angular_velocity_scalar: number;\n// // // // // // // // // //     effective_field_velocity_scalar: number;\n// // // // // // // // // //     current_torque_scalar: number;\n// // // // // // // // // // }\n\n// // // // // // // // // // // --- Main Simulation Component ---\n// // // // // // // // // // const ResonatorSimulation: React.FC = () => {\n// // // // // // // // // //     const dodecahedronRef = useRef<THREE.Mesh>(null!);\n// // // // // // // // // //     const particlesRef = useRef<THREE.Points>(null!);\n// // // // // // // // // //     const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // // // // // // // // //     // Leva controls definition\n// // // // // // // // // //     const resonatorControls = useControls('Resonator Controls', {\n// // // // // // // // // //         baseFieldSpeed: { value: 1.0, min: -5, max: 5, step: 0.1 },\n// // // // // // // // // //         fieldIntensity: { value: 1.0, min: 0.1, max: 5, step: 0.1 },\n// // // // // // // // // //         k_drag: { label: 'Induction Strength', value: 0.5, min: 0, max: 2, step: 0.05 },\n// // // // // // // // // //         inertiaScale: { label: 'Inertia Scale', value: 1.0, min: 0.1, max: 5, step: 0.1 },\n// // // // // // // // // //         damping: { value: 0.1, min: 0, max: 1, step: 0.01 },\n// // // // // // // // // //         k_feedback: { value: -0.2, min: -2, max: 2, step: 0.05 },\n// // // // // // // // // //     });\n// // // // // // // // // //     const shellControls = useControls('Shell Geometry', {\n// // // // // // // // // //          outerRadius: { value: 1.0, min: 0.5, max: 2.0, step: 0.1 },\n// // // // // // // // // //          thickness: { value: 0.05, min: 0.01, max: 0.3, step: 0.01 },\n// // // // // // // // // //          holeBaseDiameter: { value: 0.1, min: 0.01, max: 0.3, step: 0.01 },\n// // // // // // // // // //          holeRatio: { value: 1.2, min: 1.0, max: 1.6, step: 0.01 },\n// // // // // // // // // //          noduleRadius: { value: 0.1, min: 0.01, max: 0.3, step: 0.01 },\n// // // // // // // // // //      });\n// // // // // // // // // //     const vizControls = useControls('Visualization', {\n// // // // // // // // // //         particleCount: { value: 1000, min: 100, max: 5000, step: 100 },\n// // // // // // // // // //         particleSize: { value: 0.05, min: 0.01, max: 0.2, step: 0.01 },\n// // // // // // // // // //         torusMajorRadius: { value: 1.5, min: 0.5, max: 5, step: 0.1 },\n// // // // // // // // // //         torusMinorRadius: { value: 0.5, min: 0.1, max: 2, step: 0.05 },\n// // // // // // // // // //         showParticles: true, // Add toggle for particles\n// // // // // // // // // //     });\n\n// // // // // // // // // //     // Combine leva controls with defaults (useMemo ensures this runs correctly)\n// // // // // // // // // //     const defaultShellParams = useMemo(() => ({ outerRadius: 1.0, thickness: 0.05, holeBaseDiameter: 0.1, holeRatio: 1.2, noduleRadius: 0.1 }), []);\n// // // // // // // // // //     const finalShellParams = useMemo(() => ({\n// // // // // // // // // //         outerRadius: (typeof shellControls.outerRadius === 'number' && Number.isFinite(shellControls.outerRadius)) ? shellControls.outerRadius : defaultShellParams.outerRadius,\n// // // // // // // // // //         thickness: (typeof shellControls.thickness === 'number' && Number.isFinite(shellControls.thickness)) ? shellControls.thickness : defaultShellParams.thickness,\n// // // // // // // // // //         holeBaseDiameter: (typeof shellControls.holeBaseDiameter === 'number' && Number.isFinite(shellControls.holeBaseDiameter)) ? shellControls.holeBaseDiameter : defaultShellParams.holeBaseDiameter,\n// // // // // // // // // //         holeRatio: (typeof shellControls.holeRatio === 'number' && Number.isFinite(shellControls.holeRatio)) ? shellControls.holeRatio : defaultShellParams.holeRatio,\n// // // // // // // // // //         noduleRadius: (typeof shellControls.noduleRadius === 'number' && Number.isFinite(shellControls.noduleRadius)) ? shellControls.noduleRadius : defaultShellParams.noduleRadius,\n// // // // // // // // // //     }), [shellControls, defaultShellParams]);\n\n// // // // // // // // // //     // Inertia calculation using final params\n// // // // // // // // // //     const effectiveInertia = useMemo(() => resonatorControls.inertiaScale * (finalShellParams.outerRadius ** 5 - (finalShellParams.outerRadius - finalShellParams.thickness) ** 5) / finalShellParams.outerRadius ** 5,\n// // // // // // // // // //                                  [resonatorControls.inertiaScale, finalShellParams.outerRadius, finalShellParams.thickness]);\n\n// // // // // // // // // //     // Physics state initialization\n// // // // // // // // // //     const physicsState = useRef<PhysicsState>({\n// // // // // // // // // //          shell_angular_velocity_scalar: 0.0,\n// // // // // // // // // //          effective_field_velocity_scalar: resonatorControls.baseFieldSpeed || 0,\n// // // // // // // // // //          current_torque_scalar: 0.0,\n// // // // // // // // // //     });\n\n// // // // // // // // // //     // Particle data memoization\n// // // // // // // // // //     const particleData = useMemo(() => {\n// // // // // // // // // //         console.log(`Creating particle data for count: ${vizControls.particleCount}`);\n// // // // // // // // // //         try {\n// // // // // // // // // //              const data = [];\n// // // // // // // // // //              const positions = new Float32Array(vizControls.particleCount * 3);\n// // // // // // // // // //              for (let i = 0; i < vizControls.particleCount; i++) {\n// // // // // // // // // //                  const u = Math.random() * Math.PI * 2; const v = Math.random() * Math.PI * 2;\n// // // // // // // // // //                  const R = vizControls.torusMajorRadius; const r = vizControls.torusMinorRadius;\n// // // // // // // // // //                  const randR = R + (Math.random() - 0.5) * 0.2; const randr = r * Math.sqrt(Math.random());\n// // // // // // // // // //                  positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u);\n// // // // // // // // // //                  positions[i * 3 + 1] = randr * Math.sin(v);\n// // // // // // // // // //                  positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u);\n// // // // // // // // // //                  data.push({ u, v, R, r: randr, fieldIndex: 0 });\n// // // // // // // // // //              }\n// // // // // // // // // //              return { positions, data };\n// // // // // // // // // //         } catch (error) { console.error(\"Error creating particle data:\", error); return { positions: new Float32Array(0), data: [] }; }\n// // // // // // // // // //      }, [vizControls.particleCount, vizControls.torusMajorRadius, vizControls.torusMinorRadius]); // Use specific control values\n\n// // // // // // // // // //     // Particle buffer update effect\n// // // // // // // // // //      useEffect(() => {\n// // // // // // // // // //          if (particleGeoRef.current && particleData && particleData.positions) {\n// // // // // // // // // //              const existingAttribute = particleGeoRef.current.getAttribute('position') as THREE.BufferAttribute | undefined;\n// // // // // // // // // //              // Always update if attribute exists but size differs, or if attribute doesn't exist\n// // // // // // // // // //              if (!existingAttribute || existingAttribute.array.length !== particleData.positions.length) {\n// // // // // // // // // //                  particleGeoRef.current.setAttribute('position', new THREE.BufferAttribute(particleData.positions, 3, false));\n// // // // // // // // // //                  console.log(`Particle buffer attribute CREATED/REPLACED (Count: ${particleData.positions.length / 3}).`);\n// // // // // // // // // //              } else {\n// // // // // // // // // //                  // Optional: If sizes match, could potentially update content if needed, but usually creation is enough\n// // // // // // // // // //                  // console.log(\"Particle buffer exists and size matches.\");\n// // // // // // // // // //              }\n// // // // // // // // // //          } else {\n// // // // // // // // // //              if (particleGeoRef.current?.getAttribute('position')) {\n// // // // // // // // // //                   particleGeoRef.current.deleteAttribute('position'); console.log(\"Particle buffer attribute removed.\");\n// // // // // // // // // //              }\n// // // // // // // // // //          }\n// // // // // // // // // //      }, [particleData]); // Depend only on particleData object ref\n\n// // // // // // // // // //     // Animation loop\n// // // // // // // // // //     useFrame((state, delta) => {\n// // // // // // // // // //         const currentPhysics = physicsState.current;\n// // // // // // // // // //         // V1 Physics Calculations\n// // // // // // // // // //         const relative_speed = currentPhysics.effective_field_velocity_scalar - currentPhysics.shell_angular_velocity_scalar;\n// // // // // // // // // //         currentPhysics.current_torque_scalar = resonatorControls.k_drag * resonatorControls.fieldIntensity * relative_speed;\n// // // // // // // // // //         const angular_acceleration = currentPhysics.current_torque_scalar / effectiveInertia;\n// // // // // // // // // //         currentPhysics.shell_angular_velocity_scalar += angular_acceleration * delta;\n// // // // // // // // // //         currentPhysics.shell_angular_velocity_scalar *= (1 - resonatorControls.damping * delta);\n// // // // // // // // // //         currentPhysics.effective_field_velocity_scalar = resonatorControls.baseFieldSpeed + resonatorControls.k_feedback * currentPhysics.shell_angular_velocity_scalar;\n\n// // // // // // // // // //         // Dodecahedron Visual Update\n// // // // // // // // // //         if (dodecahedronRef.current) {\n// // // // // // // // // //              dodecahedronRef.current.rotation.y += currentPhysics.shell_angular_velocity_scalar * delta;\n// // // // // // // // // //              const material = dodecahedronRef.current.material as THREE.MeshStandardMaterial;\n// // // // // // // // // //              if (material?.emissive) { // Check material exists too\n// // // // // // // // // //                  const maxTorqueEst = resonatorControls.k_drag * resonatorControls.fieldIntensity * (Math.abs(resonatorControls.baseFieldSpeed) * 1.5 + 1); // Safer estimation\n// // // // // // // // // //                  const emissionStrength = Math.min(Math.abs(currentPhysics.current_torque_scalar) / (maxTorqueEst + 0.01), 1.0);\n// // // // // // // // // //                  material.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5);\n// // // // // // // // // //              }\n// // // // // // // // // //         }\n\n// // // // // // // // // //         // Particle Field Update\n// // // // // // // // // //         if (vizControls.showParticles && particleGeoRef.current?.attributes.position && particlesRef.current && particleData?.data) {\n// // // // // // // // // //              const positions = particleGeoRef.current.attributes.position.array as Float32Array;\n// // // // // // // // // //              const speed = currentPhysics.effective_field_velocity_scalar * resonatorControls.fieldIntensity;\n// // // // // // // // // //              const pData = particleData.data;\n// // // // // // // // // //              (particlesRef.current.material as THREE.PointsMaterial).size = vizControls.particleSize * (1 + resonatorControls.fieldIntensity * 0.5);\n// // // // // // // // // //              (particlesRef.current.material as THREE.PointsMaterial).needsUpdate = true; // Ensure material updates take effect\n\n// // // // // // // // // //              if (pData.length * 3 === positions.length) { // Ensure data and buffer match\n// // // // // // // // // //                  for (let i = 0; i < pData.length; i++) {\n// // // // // // // // // //                      const data = pData[i]; data.u += speed * delta;\n// // // // // // // // // //                      const R = data.R; const r = data.r; const u = data.u; const v = data.v;\n// // // // // // // // // //                      positions[i * 3]     = (R + r * Math.cos(v)) * Math.cos(u);\n// // // // // // // // // //                      positions[i * 3 + 1] = r * Math.sin(v);\n// // // // // // // // // //                      positions[i * 3 + 2] = (R + r * Math.cos(v)) * Math.sin(u);\n// // // // // // // // // //                  }\n// // // // // // // // // //                  particleGeoRef.current.attributes.position.needsUpdate = true;\n// // // // // // // // // //              } else {\n// // // // // // // // // //                   console.warn(\"Mismatch between particle data length and buffer length in useFrame.\");\n// // // // // // // // // //              }\n// // // // // // // // // //         }\n// // // // // // // // // //     });\n\n// // // // // // // // // //     // Memoized Copper Material\n// // // // // // // // // //     const copperMaterial = useMemo(() => new THREE.MeshStandardMaterial({\n// // // // // // // // // //         name: 'Copper CSG Material', // Add name for debugging\n// // // // // // // // // //         color: 0xB87333, metalness: 0.8, roughness: 0.3,\n// // // // // // // // // //         emissive: 0x000000, emissiveIntensity: 1.0,\n// // // // // // // // // //         side: THREE.DoubleSide\n// // // // // // // // // //     }), []);\n\n// // // // // // // // // //     return (\n// // // // // // // // // //         <>\n// // // // // // // // // //             <RomanDodecahedron\n// // // // // // // // // //                 ref={dodecahedronRef}\n// // // // // // // // // //                 outerRadius={finalShellParams.outerRadius}\n// // // // // // // // // //                 thickness={finalShellParams.thickness}\n// // // // // // // // // //                 holeBaseDiameter={finalShellParams.holeBaseDiameter}\n// // // // // // // // // //                 holeRatio={finalShellParams.holeRatio}\n// // // // // // // // // //                 noduleRadius={finalShellParams.noduleRadius}\n// // // // // // // // // //                 material={copperMaterial} // Pass the memoized material\n// // // // // // // // // //                 castShadow receiveShadow\n// // // // // // // // // //             />\n// // // // // // // // // //             {/* Conditionally render particles based on leva toggle */}\n// // // // // // // // // //             {vizControls.showParticles && (\n// // // // // // // // // //                  <points ref={particlesRef} name=\"FieldParticles\"> {/* Add name */}\n// // // // // // // // // //                      <bufferGeometry ref={particleGeoRef} />\n// // // // // // // // // //                      <pointsMaterial\n// // // // // // // // // //                          name=\"ParticleMaterial\" // Add name\n// // // // // // // // // //                          color={0x00ffff}\n// // // // // // // // // //                          size={vizControls.particleSize} // Size managed in useFrame\n// // // // // // // // // //                          transparent opacity={0.7}\n// // // // // // // // // //                          blending={THREE.AdditiveBlending}\n// // // // // // // // // //                          sizeAttenuation={true}\n// // // // // // // // // //                          map={null}\n// // // // // // // // // //                      />\n// // // // // // // // // //                  </points>\n// // // // // // // // // //             )}\n// // // // // // // // // //         </>\n// // // // // // // // // //     );\n// // // // // // // // // // };\n\n// // // // // // // // // // // --- Scene Component ---\n// // // // // // // // // // const TemporalResonatorScene: React.FC = () => {\n// // // // // // // // // //     return (\n// // // // // // // // // //     <>\n// // // // // // // // // //         <Leva collapsed={false} titleBar={{ title: 'Controls' }} />\n// // // // // // // // // //         <Canvas\n// // // // // // // // // //              style={{ position: 'absolute', top: 0, left: 0, width: '100vw', height: '100vh', background: '#111122', zIndex: 0 }}\n// // // // // // // // // //              camera={{ position: [3, 3, 5], fov: 75 }}\n// // // // // // // // // //              gl={{ antialias: true }} shadows\n// // // // // // // // // //         >\n// // // // // // // // // //              {/* Increased Light Intensity */}\n// // // // // // // // // //              <ambientLight intensity={0.5} />\n// // // // // // // // // //              <hemisphereLight groundColor={0x404040} intensity={1.0} />\n// // // // // // // // // //              <directionalLight\n// // // // // // // // // //                  position={[5, 10, 7.5]} intensity={1.5} // Increased intensity\n// // // // // // // // // //                  castShadow shadow-mapSize-width={1024} shadow-mapSize-height={1024}\n// // // // // // // // // //                  shadow-camera-far={25} shadow-camera-left={-10} shadow-camera-right={10}\n// // // // // // // // // //                  shadow-camera-top={10} shadow-camera-bottom={-10}\n// // // // // // // // // //              />\n// // // // // // // // // //              <ErrorBoundary>\n// // // // // // // // // //                  <Suspense fallback={<LoadingPlaceholder />}>\n// // // // // // // // // //                       <ResonatorSimulation />\n// // // // // // // // // //                  </Suspense>\n// // // // // // // // // //              </ErrorBoundary>\n// // // // // // // // // //              <Controls />\n// // // // // // // // // //              {/* Optional: Add helpers for debugging */}\n// // // // // // // // // //              {/* <axesHelper args={[5]} /> */}\n// // // // // // // // // //              {/* <gridHelper args={[10, 10]} /> */}\n// // // // // // // // // //         </Canvas>\n// // // // // // // // // //     </>\n// // // // // // // // // // )};\n\n// // // // // // // // // // // --- Loading Placeholder ---\n// // // // // // // // // // const LoadingPlaceholder: React.FC = () => {\n// // // // // // // // // //     return (\n// // // // // // // // // //         <mesh>\n// // // // // // // // // //             <boxGeometry args={[0.1, 0.1, 0.1]} />\n// // // // // // // // // //             <meshBasicMaterial color=\"orange\" wireframe attach=\"material\" /> {/* Use attach */}\n// // // // // // // // // //         </mesh>\n// // // // // // // // // //     );\n// // // // // // // // // // };\n\n// // // // // // // // // // export default TemporalResonatorScene;\n\n\n// // // // // // // // // // // // TemporalResonatorScene_V2_CSG_Fixes_4.tsx\n// // // // // // // // // // // import React, { useRef, useState, useEffect, useMemo, Suspense } from 'react';\n// // // // // // // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // // // // // // // import * as THREE from 'three';\n// // // // // // // // // // // import ErrorBoundary from './errorBoundary';\n// // // // // // // // // // // import { useControls, Leva } from 'leva';\n// // // // // // // // // // // import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\n// // // // // // // // // // // import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n\n// // // // // // // // // // // THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\n// // // // // // // // // // // THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\n// // // // // // // // // // // THREE.Mesh.prototype.raycast = acceleratedRaycast;\n\n// // // // // // // // // // // const csgEvaluator = new Evaluator();\n// // // // // // // // // // // csgEvaluator.useGroups = true;\n\n// // // // // // // // // // // extend({ OrbitControls });\n\n// // // // // // // // // // // // --- Constants ---\n// // // // // // // // // // // const PHI = (1 + Math.sqrt(5)) / 2;\n// // // // // // // // // // // const INV_PHI = 1 / PHI;\n\n// // // // // // // // // // // // --- Helper: Get Dodecahedron Math Data (WITH DEBUGGING) ---\n// // // // // // // // // // // function getDodecahedronData(radius: number) {\n// // // // // // // // // // //     console.log(`--- Calculating Dodecahedron Data for radius: ${radius} ---`); // DEBUG START\n// // // // // // // // // // //     if (radius <= 0 || !Number.isFinite(radius)) {\n// // // // // // // // // // //         console.error(\"!!! Invalid radius passed:\", radius);\n// // // // // // // // // // //         throw new Error(\"Invalid radius\");\n// // // // // // // // // // //     }\n\n// // // // // // // // // // //     const uniqueVerticesMap = new Map<string, THREE.Vector3>();\n// // // // // // // // // // //     console.log(`PHI: ${PHI.toFixed(6)}, INV_PHI: ${INV_PHI.toFixed(6)}`); // DEBUG\n\n// // // // // // // // // // //     const coords = [\n// // // // // // // // // // //         [1, 1, 1], [-1, 1, 1], [1, -1, 1], [-1, -1, 1], [1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1],\n// // // // // // // // // // //         [0, PHI, INV_PHI], [0, -PHI, INV_PHI], [0, PHI, -INV_PHI], [0, -PHI, -INV_PHI],\n// // // // // // // // // // //         [INV_PHI, 0, PHI], [-INV_PHI, 0, PHI], [INV_PHI, 0, -PHI], [-INV_PHI, 0, -PHI],\n// // // // // // // // // // //         [PHI, INV_PHI, 0], [-PHI, INV_PHI, 0], [PHI, -INV_PHI, 0], [-PHI, -INV_PHI, 0]\n// // // // // // // // // // //     ];\n\n// // // // // // // // // // //     const distOriginToVertex = Math.sqrt(PHI*PHI + INV_PHI*INV_PHI);\n// // // // // // // // // // //     const scale = radius / distOriginToVertex;\n// // // // // // // // // // //     console.log(`distOriginToVertex: ${distOriginToVertex.toFixed(6)}, scale: ${scale.toFixed(6)}`); // DEBUG\n// // // // // // // // // // //     if (!Number.isFinite(scale) || scale === 0) {\n// // // // // // // // // // //         console.error(\"!!! Invalid scale factor calculated:\", scale);\n// // // // // // // // // // //         throw new Error(\"Invalid scale factor\");\n// // // // // // // // // // //     }\n\n// // // // // // // // // // //     coords.forEach((v, index) => {\n// // // // // // // // // // //         const x = v[0] * scale;\n// // // // // // // // // // //         const y = v[1] * scale;\n// // // // // // // // // // //         const z = v[2] * scale;\n// // // // // // // // // // //         const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`;\n// // // // // // // // // // //         // console.log(`Vertex ${index}: Scaled [${x.toFixed(6)}, ${y.toFixed(6)}, ${z.toFixed(6)}] -> Key: ${key}`); // DEBUG (Verbose)\n// // // // // // // // // // //         if (!uniqueVerticesMap.has(key)) {\n// // // // // // // // // // //             uniqueVerticesMap.set(key, new THREE.Vector3(x, y, z));\n// // // // // // // // // // //         } else {\n// // // // // // // // // // //              // This should ideally not happen often if coordinates are distinct\n// // // // // // // // // // //              console.warn(` -> Key ${key} collision detected at index ${index}!`); // DEBUG COLLISION\n// // // // // // // // // // //         }\n// // // // // // // // // // //     });\n\n// // // // // // // // // // //     const vertices = Array.from(uniqueVerticesMap.values());\n// // // // // // // // // // //     console.log(`--- Generated ${vertices.length} unique vertices. ---`); // DEBUG COUNT\n\n// // // // // // // // // // //     // ... face data calculation ...\n// // // // // // // // // // //     const faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] = [];\n// // // // // // // // // // //     const icoVerts = [ [0, 1, PHI], [0, -1, PHI], [0, 1, -PHI], [0, -1, -PHI], [1, PHI, 0], [-1, PHI, 0], [1, -PHI, 0], [-1, -PHI, 0], [PHI, 0, 1], [-PHI, 0, 1], [PHI, 0, -1], [-PHI, 0, -1] ];\n// // // // // // // // // // //     const faceCenterDist = radius * 1.53 / 1.902;\n// // // // // // // // // // //     // console.log(`Calculated faceCenterDist: ${faceCenterDist.toFixed(6)}`); // DEBUG\n// // // // // // // // // // //     icoVerts.forEach(v => { const normal = new THREE.Vector3(v[0], v[1], v[2]).normalize(); const center = normal.clone().multiplyScalar(faceCenterDist); faceData.push({ center, normal }); });\n// // // // // // // // // // //     // console.log(`Generated ${faceData.length} face data entries.`); // DEBUG\n\n// // // // // // // // // // //     if (vertices.length !== 20 || faceData.length !== 12) {\n// // // // // // // // // // //          // Log the generated vertices if the count is wrong\n// // // // // // // // // // //          console.error(\"!!! Vertex generation failed. Generated vertices:\", vertices);\n// // // // // // // // // // //          throw new Error(`Incorrect math data count: ${vertices.length} vertices, ${faceData.length} faces`);\n// // // // // // // // // // //     }\n// // // // // // // // // // //     console.log(\"--- Dodecahedron Data Calculation Successful ---\"); // DEBUG SUCCESS\n// // // // // // // // // // //     return { vertices, faceData };\n// // // // // // // // // // // }\n\n\n// // // // // // // // // // // // --- Controls Component (Unchanged) ---\n// // // // // // // // // // // const Controls = () => { /* ... */\n// // // // // // // // // // //      const { camera, gl } = useThree(); const controlsRef = useRef<OrbitControls>(null);\n// // // // // // // // // // //      useEffect(() => { const controls = new OrbitControls(camera, gl.domElement); controls.enableDamping = true; (controlsRef as any).current = controls; return () => { controls.dispose(); }; }, [camera, gl]);\n// // // // // // // // // // //      useFrame(() => { controlsRef.current?.update(); }); return null;\n// // // // // // // // // // //  };\n\n// // // // // // // // // // // // --- Roman Dodecahedron CSG Component (Guard in useEffect might now be redundant but safe) ---\n// // // // // // // // // // // interface RomanDodecahedronProps { outerRadius: number; thickness: number; holeBaseDiameter: number; holeRatio: number; noduleRadius: number; material?: THREE.Material; [key: string]: any;} // Make material optional too\n// // // // // // // // // // // const RomanDodecahedron: React.FC<RomanDodecahedronProps> = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>(\n// // // // // // // // // // //     ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, ...props }, ref) => {\n// // // // // // // // // // //         const [calculatedGeometry, setCalculatedGeometry] = useState<THREE.BufferGeometry | null>(null);\n// // // // // // // // // // //         useEffect(() => {\n// // // // // // // // // // //             // Guard still useful as a safety check\n// // // // // // // // // // //             if ( typeof outerRadius !== 'number' || /* ... other checks ... */ typeof noduleRadius !== 'number' || noduleRadius <= 0 || !Number.isFinite(noduleRadius) ) {\n// // // // // // // // // // //                 console.log(`Skipping CSG calculation in useEffect: Invalid props received.`);\n// // // // // // // // // // //                 setCalculatedGeometry(null); return;\n// // // // // // // // // // //             }\n// // // // // // // // // // //             console.log(`Calculating CSG Geometry in useEffect for outerRadius: ${outerRadius}`);\n// // // // // // // // // // //             let geometry: THREE.BufferGeometry | null = null;\n// // // // // // // // // // //             let shellBrush = { geometry: new THREE.DodecahedronGeometry(outerRadius, 1) };\n// // // // // // // // // // //             try { /* ... CSG Logic ... */ geometry = shellBrush.geometry; geometry.computeVertexNormals(); geometry.center(); console.log(\"CSG Calculation Complete.\"); }\n// // // // // // // // // // //             catch(error) { console.error(\"CSG Error in useEffect:\", error); geometry = null; }\n// // // // // // // // // // //             setCalculatedGeometry(geometry);\n// // // // // // // // // // //             return () => { /* ... dispose previous geometry ... */ };\n// // // // // // // // // // //         }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]);\n\n// // // // // // // // // // //         if (!calculatedGeometry) { return null; }\n// // // // // // // // // // //         // Use default material if none provided\n// // // // // // // // // // //         const meshMaterial = material || new THREE.MeshStandardMaterial({ color: 0xff0000 });\n// // // // // // // // // // //         return <mesh ref={ref} geometry={calculatedGeometry} material={meshMaterial} {...props} />;\n// // // // // // // // // // // });\n\n// // // // // // // // // // // // --- Physics State Interface (Unchanged) ---\n// // // // // // // // // // // interface PhysicsState { /* ... */ shell_angular_velocity_scalar: number; effective_field_velocity_scalar: number; current_torque_scalar: number;}\n\n// // // // // // // // // // // // --- Main Simulation Component (Provide Defaults) ---\n// // // // // // // // // // // const ResonatorSimulation = () => {\n// // // // // // // // // // //     const dodecahedronRef = useRef<THREE.Mesh>(null!);\n// // // // // // // // // // //     const particlesRef = useRef<THREE.Points>(null!);\n// // // // // // // // // // //     const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // // // // // // // // // //     // Leva controls\n// // // // // // // // // // //     const params = useControls('Resonator Controls', { /* ... */\n// // // // // // // // // // //         baseFieldSpeed: { value: 1.0, min: -5, max: 5, step: 0.1 },\n// // // // // // // // // // //         fieldIntensity: { value: 1.0, min: 0.1, max: 5, step: 0.1 },\n// // // // // // // // // // //         k_drag: { label: 'Induction Strength', value: 0.5, min: 0, max: 2, step: 0.05 },\n// // // // // // // // // // //         inertiaScale: { label: 'Inertia Scale', value: 1.0, min: 0.1, max: 5, step: 0.1 },\n// // // // // // // // // // //         damping: { value: 0.1, min: 0, max: 1, step: 0.01 },\n// // // // // // // // // // //         k_feedback: { value: -0.2, min: -2, max: 2, step: 0.05 },\n// // // // // // // // // // //     });\n// // // // // // // // // // //     // Get potentially undefined values from Leva first\n// // // // // // // // // // //     const shellParamsFromLeva = useControls('Shell Geometry', {\n// // // // // // // // // // //          outerRadius: { value: 1.0, min: 0.5, max: 2.0, step: 0.1 },\n// // // // // // // // // // //          thickness: { value: 0.05, min: 0.01, max: 0.3, step: 0.01 },\n// // // // // // // // // // //          holeBaseDiameter: { value: 0.1, min: 0.01, max: 0.3, step: 0.01 },\n// // // // // // // // // // //          holeRatio: { value: 1.2, min: 1.0, max: 1.6, step: 0.01 },\n// // // // // // // // // // //          noduleRadius: { value: 0.1, min: 0.01, max: 0.3, step: 0.01 },\n// // // // // // // // // // //      });\n// // // // // // // // // // //     const vizParams = useControls('Visualization', { /* ... */\n// // // // // // // // // // //         particleCount: { value: 1000, min: 100, max: 5000, step: 100 },\n// // // // // // // // // // //         particleSize: { value: 0.05, min: 0.01, max: 0.2, step: 0.01 },\n// // // // // // // // // // //         torusMajorRadius: { value: 1.5, min: 0.5, max: 5, step: 0.1 },\n// // // // // // // // // // //         torusMinorRadius: { value: 0.5, min: 0.1, max: 2, step: 0.05 },\n// // // // // // // // // // //     });\n\n// // // // // // // // // // //     // --- FIX: Define hardcoded defaults ---\n// // // // // // // // // // //     const defaultShellParams = useMemo(() => ({\n// // // // // // // // // // //         outerRadius: 1.0,\n// // // // // // // // // // //         thickness: 0.05,\n// // // // // // // // // // //         holeBaseDiameter: 0.1,\n// // // // // // // // // // //         holeRatio: 1.2,\n// // // // // // // // // // //         noduleRadius: 0.1,\n// // // // // // // // // // //     }), []); // Empty dependency array - create only once\n\n// // // // // // // // // // //     // --- FIX: Create final params, merging leva values over defaults ---\n// // // // // // // // // // //     const finalShellParams = useMemo(() => ({\n// // // // // // // // // // //         outerRadius: (typeof shellParamsFromLeva.outerRadius === 'number' && Number.isFinite(shellParamsFromLeva.outerRadius)) ? shellParamsFromLeva.outerRadius : defaultShellParams.outerRadius,\n// // // // // // // // // // //         thickness: (typeof shellParamsFromLeva.thickness === 'number' && Number.isFinite(shellParamsFromLeva.thickness)) ? shellParamsFromLeva.thickness : defaultShellParams.thickness,\n// // // // // // // // // // //         holeBaseDiameter: (typeof shellParamsFromLeva.holeBaseDiameter === 'number' && Number.isFinite(shellParamsFromLeva.holeBaseDiameter)) ? shellParamsFromLeva.holeBaseDiameter : defaultShellParams.holeBaseDiameter,\n// // // // // // // // // // //         holeRatio: (typeof shellParamsFromLeva.holeRatio === 'number' && Number.isFinite(shellParamsFromLeva.holeRatio)) ? shellParamsFromLeva.holeRatio : defaultShellParams.holeRatio,\n// // // // // // // // // // //         noduleRadius: (typeof shellParamsFromLeva.noduleRadius === 'number' && Number.isFinite(shellParamsFromLeva.noduleRadius)) ? shellParamsFromLeva.noduleRadius : defaultShellParams.noduleRadius,\n// // // // // // // // // // //     }), [shellParamsFromLeva, defaultShellParams]); // Re-calculate if leva values change\n\n// // // // // // // // // // //     // Typed assertions (still used for convenience)\n// // // // // // // // // // //     const typedParams = params as any;\n// // // // // // // // // // //     // const typedShellParams = shellParams as any; // Use finalShellParams now\n// // // // // // // // // // //     const typedVizParams = vizParams as any;\n\n// // // // // // // // // // //     // Inertia - Use finalShellParams\n// // // // // // // // // // //     const effectiveInertia = useMemo(() => typedParams.inertiaScale * (finalShellParams.outerRadius ** 5 - (finalShellParams.outerRadius - finalShellParams.thickness) ** 5) / finalShellParams.outerRadius ** 5,\n// // // // // // // // // // //                                  [typedParams.inertiaScale, finalShellParams.outerRadius, finalShellParams.thickness]); // Depend on final params\n\n// // // // // // // // // // //     // Physics state ref - Use finalShellParams for initial derived values if needed\n// // // // // // // // // // //     const physicsState = useRef<PhysicsState>({\n// // // // // // // // // // //          shell_angular_velocity_scalar: 0.0,\n// // // // // // // // // // //          effective_field_velocity_scalar: typedParams.baseFieldSpeed || 0,\n// // // // // // // // // // //          current_torque_scalar: 0.0,\n// // // // // // // // // // //     });\n\n// // // // // // // // // // //     // Particle data memoization\n// // // // // // // // // // //     const particleData = useMemo(() => { /* ... unchanged ... */ }, [typedVizParams.particleCount, typedVizParams.torusMajorRadius, typedVizParams.torusMinorRadius]);\n// // // // // // // // // // //     // Particle buffer effect\n// // // // // // // // // // //     useEffect(() => { /* ... unchanged ... */ }, [particleData]);\n// // // // // // // // // // //     // Animation loop\n// // // // // // // // // // //     useFrame((state, delta) => { /* ... V1 physics + Visual updates ... */ });\n// // // // // // // // // // //     // Material\n// // // // // // // // // // //     const copperMaterial = useMemo(() => new THREE.MeshStandardMaterial({ color: 0xB87333, metalness: 0.8, roughness: 0.3, emissive: 0x000000, emissiveIntensity: 1.0, side: THREE.DoubleSide }), []);\n\n// // // // // // // // // // //     return (\n// // // // // // // // // // //         <>\n// // // // // // // // // // //             {/* Pass the guaranteed valid finalShellParams */}\n// // // // // // // // // // //             <RomanDodecahedron\n// // // // // // // // // // //                 ref={dodecahedronRef}\n// // // // // // // // // // //                 outerRadius={finalShellParams.outerRadius}\n// // // // // // // // // // //                 thickness={finalShellParams.thickness}\n// // // // // // // // // // //                 holeBaseDiameter={finalShellParams.holeBaseDiameter}\n// // // // // // // // // // //                 holeRatio={finalShellParams.holeRatio}\n// // // // // // // // // // //                 noduleRadius={finalShellParams.noduleRadius}\n// // // // // // // // // // //                 material={copperMaterial}\n// // // // // // // // // // //                 castShadow receiveShadow\n// // // // // // // // // // //             />\n// // // // // // // // // // //             {/* Points */}\n// // // // // // // // // // //             <points ref={particlesRef}>\n// // // // // // // // // // //                  <bufferGeometry ref={particleGeoRef} />\n// // // // // // // // // // //                  <pointsMaterial color={0x00ffff} size={typedVizParams.particleSize} transparent opacity={0.7} blending={THREE.AdditiveBlending} sizeAttenuation={true} map={null} />\n// // // // // // // // // // //             </points>\n// // // // // // // // // // //         </>\n// // // // // // // // // // //     );\n// // // // // // // // // // // };\n\n// // // // // // // // // // // // --- Scene Component (Container - Unchanged) ---\n// // // // // // // // // // // const TemporalResonatorScene: React.FC = () => { /* ... */ return (<>{/* Leva */}<Canvas>{/* Lights */}<ErrorBoundary><Suspense fallback={<LoadingPlaceholder />}><ResonatorSimulation /></Suspense></ErrorBoundary><Controls /></Canvas></>);};\n// // // // // // // // // // // const LoadingPlaceholder = () => { /* ... */ return (<mesh><boxGeometry args={[0.1, 0.1, 0.1]} /><meshBasicMaterial color=\"orange\" wireframe /></mesh>);};\n// // // // // // // // // // // export default TemporalResonatorScene;\n\n\n// // // // // // // // // // // // // TemporalResonatorScene_V2_CSG_Fixes_4.tsx\n// // // // // // // // // // // // import React, { useRef, useEffect, useMemo, Suspense } from 'react';\n// // // // // // // // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // // // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // // // // // // // // import * as THREE from 'three';\n// // // // // // // // // // // // import ErrorBoundary from './errorBoundary';\n// // // // // // // // // // // // import { useControls, Leva } from 'leva';\n// // // // // // // // // // // // import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\n// // // // // // // // // // // // import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n\n// // // // // // // // // // // // THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\n// // // // // // // // // // // // THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\n// // // // // // // // // // // // THREE.Mesh.prototype.raycast = acceleratedRaycast;\n\n// // // // // // // // // // // // const csgEvaluator = new Evaluator();\n// // // // // // // // // // // // csgEvaluator.useGroups = true;\n\n// // // // // // // // // // // // extend({ OrbitControls });\n\n// // // // // // // // // // // // // --- Constants ---\n// // // // // // // // // // // // const PHI = (1 + Math.sqrt(5)) / 2;\n// // // // // // // // // // // // const INV_PHI = 1 / PHI;\n\n// // // // // // // // // // // // // --- Helper: Get Dodecahedron Math Data (FIXED Vertex Uniqueness) ---\n// // // // // // // // // // // // function getDodecahedronData(radius: number) {\n// // // // // // // // // // // //     const uniqueVerticesMap = new Map<string, THREE.Vector3>(); // Use Map for uniqueness\n\n// // // // // // // // // // // //     // Standard vertex coordinates components\n// // // // // // // // // // // //     const coords = [\n// // // // // // // // // // // //         [1, 1, 1], [-1, 1, 1], [1, -1, 1], [-1, -1, 1],\n// // // // // // // // // // // //         [1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1], // (Â±1, Â±1, Â±1)\n// // // // // // // // // // // //         [0, PHI, INV_PHI], [0, -PHI, INV_PHI], [0, PHI, -INV_PHI], [0, -PHI, -INV_PHI], // (0, Â±Ï†, Â±1/Ï†)\n// // // // // // // // // // // //         [INV_PHI, 0, PHI], [-INV_PHI, 0, PHI], [INV_PHI, 0, -PHI], [-INV_PHI, 0, -PHI], // (Â±1/Ï†, 0, Â±Ï†)\n// // // // // // // // // // // //         [PHI, INV_PHI, 0], [-PHI, INV_PHI, 0], [PHI, -INV_PHI, 0], [-PHI, -INV_PHI, 0]  // (Â±Ï†, Â±1/Ï†, 0)\n// // // // // // // // // // // //     ];\n\n// // // // // // // // // // // //     // Find scale factor (distance from origin to a known vertex like (PHI, INV_PHI, 0))\n// // // // // // // // // // // //     const distOriginToVertex = Math.sqrt(PHI*PHI + INV_PHI*INV_PHI); // ~1.9021\n// // // // // // // // // // // //     const scale = radius / distOriginToVertex;\n\n// // // // // // // // // // // //     coords.forEach(v => {\n// // // // // // // // // // // //         const x = v[0] * scale;\n// // // // // // // // // // // //         const y = v[1] * scale;\n// // // // // // // // // // // //         const z = v[2] * scale;\n// // // // // // // // // // // //         // Use a precise key for the Map\n// // // // // // // // // // // //         const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`;\n// // // // // // // // // // // //         if (!uniqueVerticesMap.has(key)) {\n// // // // // // // // // // // //             uniqueVerticesMap.set(key, new THREE.Vector3(x, y, z));\n// // // // // // // // // // // //         }\n// // // // // // // // // // // //     });\n\n// // // // // // // // // // // //     const vertices = Array.from(uniqueVerticesMap.values()); // Convert Map values to array\n\n// // // // // // // // // // // //     // Face centers & normals (dual icosahedron vertices)\n// // // // // // // // // // // //     const faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] = [];\n// // // // // // // // // // // //     const icoVerts = [ // Coordinates for icosahedron vertices (will be scaled)\n// // // // // // // // // // // //         [0, 1, PHI], [0, -1, PHI], [0, 1, -PHI], [0, -1, -PHI],\n// // // // // // // // // // // //         [1, PHI, 0], [-1, PHI, 0], [1, -PHI, 0], [-1, -PHI, 0],\n// // // // // // // // // // // //         [PHI, 0, 1], [-PHI, 0, 1], [PHI, 0, -1], [-PHI, 0, -1]\n// // // // // // // // // // // //     ];\n\n// // // // // // // // // // // //     // Estimate face center distance (approx relation to radius)\n// // // // // // // // // // // //     const faceCenterDist = radius * 1.53 / 1.902; // Adjust if needed\n\n// // // // // // // // // // // //     icoVerts.forEach(v => {\n// // // // // // // // // // // //         const normal = new THREE.Vector3(v[0], v[1], v[2]).normalize();\n// // // // // // // // // // // //         const center = normal.clone().multiplyScalar(faceCenterDist);\n// // // // // // // // // // // //         faceData.push({ center, normal });\n// // // // // // // // // // // //     });\n\n// // // // // // // // // // // //     // Final check (should pass now)\n// // // // // // // // // // // //     if (vertices.length !== 20 || faceData.length !== 12) {\n// // // // // // // // // // // //          // Throw error ONLY if count is wrong after the Map fix\n// // // // // // // // // // // //          throw new Error(`Incorrect math data count: ${vertices.length} vertices, ${faceData.length} faces`);\n// // // // // // // // // // // //     }\n\n// // // // // // // // // // // //     return { vertices, faceData };\n// // // // // // // // // // // // }\n\n\n// // // // // // // // // // // // // --- Controls Component (Unchanged) ---\n// // // // // // // // // // // // const Controls = () => { /* ... */\n// // // // // // // // // // // //      const { camera, gl } = useThree(); const controlsRef = useRef<OrbitControls>(null);\n// // // // // // // // // // // //      useEffect(() => { const controls = new OrbitControls(camera, gl.domElement); controls.enableDamping = true; (controlsRef as any).current = controls; return () => { controls.dispose(); }; }, [camera, gl]);\n// // // // // // // // // // // //      useFrame(() => { controlsRef.current?.update(); }); return null;\n// // // // // // // // // // // //  };\n\n// // // // // // // // // // // // // --- Roman Dodecahedron CSG Component (Unchanged, relies on fixed helper) ---\n// // // // // // // // // // // // interface RomanDodecahedronProps { /* ... */ outerRadius: number; thickness: number; holeBaseDiameter: number; holeRatio: number; noduleRadius: number; material: THREE.Material; [key: string]: any;}\n// // // // // // // // // // // // const RomanDodecahedron: React.FC<RomanDodecahedronProps> = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>( /* ... CSG logic using math data ... */\n// // // // // // // // // // // //     ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, ...props }, ref) => {\n// // // // // // // // // // // //         const geometry = useMemo(() => {\n// // // // // // // // // // // //              console.log(\"Recalculating CSG Geometry using Math Data...\");\n// // // // // // // // // // // //              const detailLevel = 1;\n// // // // // // // // // // // //              try {\n// // // // // // // // // // // //                  const { vertices: mathVertices, faceData: mathFaceData } = getDodecahedronData(outerRadius); // Use fixed helper\n// // // // // // // // // // // //                  // Base shell\n// // // // // // // // // // // //                  const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, detailLevel); outerDodecGeo.computeBoundsTree();\n// // // // // // // // // // // //                  const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, detailLevel); innerDodecGeo.computeBoundsTree();\n// // // // // // // // // // // //                  let outerBrush = new Brush(outerDodecGeo); let innerBrush = new Brush(innerDodecGeo); innerBrush.updateMatrixWorld();\n// // // // // // // // // // // //                  let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n// // // // // // // // // // // //                  outerBrush.geometry.dispose(); innerBrush.geometry.dispose();\n// // // // // // // // // // // //                  // Holes\n// // // // // // // // // // // //                  const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * (holeRatio ** i));\n// // // // // // // // // // // //                  const cylinderHeight = thickness * 3; const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16);\n// // // // // // // // // // // //                  cylinderGeo.rotateX(Math.PI / 2); cylinderGeo.computeBoundsTree(); const tempQuat = new THREE.Quaternion();\n// // // // // // // // // // // //                  mathFaceData.forEach((face, index) => { /* ... subtract holes ... */\n// // // // // // // // // // // //                       const holeRadius = holeDiameters[index] / 2; if (!holeRadius || holeRadius <= 0) { return; }\n// // // // // // // // // // // //                       const holeBrush = new Brush(cylinderGeo); holeBrush.scale.set(holeRadius, holeRadius, 1);\n// // // // // // // // // // // //                       tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), face.normal); holeBrush.quaternion.copy(tempQuat);\n// // // // // // // // // // // //                       holeBrush.position.copy(face.center); holeBrush.updateMatrixWorld();\n// // // // // // // // // // // //                       shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION);\n// // // // // // // // // // // //                   });\n// // // // // // // // // // // //                  cylinderGeo.dispose();\n// // // // // // // // // // // //                  // Nodules\n// // // // // // // // // // // //                  const noduleGeo = new THREE.SphereGeometry(noduleRadius, 6, 6); noduleGeo.computeBoundsTree();\n// // // // // // // // // // // //                  mathVertices.forEach(vertexPos => { /* ... add nodules ... */\n// // // // // // // // // // // //                       const noduleBrush = new Brush(noduleGeo); noduleBrush.position.copy(vertexPos);\n// // // // // // // // // // // //                       noduleBrush.updateMatrixWorld(); shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION);\n// // // // // // // // // // // //                   });\n// // // // // // // // // // // //                  noduleGeo.dispose();\n// // // // // // // // // // // //                  // Final Geometry & Recenter\n// // // // // // // // // // // //                  const finalGeometry = shellBrush.geometry; finalGeometry.computeVertexNormals(); finalGeometry.center();\n// // // // // // // // // // // //                  console.log(\"CSG Geometry Recalculation Complete & Centered.\"); return finalGeometry;\n// // // // // // // // // // // //              } catch(error) { console.error(\"CSG Error:\", error); return new THREE.BufferGeometry(); }\n// // // // // // // // // // // //          }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]);\n// // // // // // // // // // // //         useEffect(() => { /* ... dispose geometry ... */ return () => { if (geometry && typeof (geometry as any).dispose === 'function') { (geometry as any).dispose(); console.log(\"Disposed CSG geometry\"); } }; }, [geometry]);\n// // // // // // // // // // // //         return <mesh ref={ref} geometry={geometry} material={material} {...props} />;\n// // // // // // // // // // // // });\n\n// // // // // // // // // // // // // --- Physics State Interface (Unchanged) ---\n// // // // // // // // // // // // interface PhysicsState { /* ... */ shell_angular_velocity_scalar: number; effective_field_velocity_scalar: number; current_torque_scalar: number;}\n\n// // // // // // // // // // // // // --- Main Simulation Component (Particle Buffer Fix) ---\n// // // // // // // // // // // // const ResonatorSimulation = () => {\n// // // // // // // // // // // //     const dodecahedronRef = useRef<THREE.Mesh>(null!);\n// // // // // // // // // // // //     const particlesRef = useRef<THREE.Points>(null!);\n// // // // // // // // // // // //     const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // // // // // // // // // // //     // Leva controls\n// // // // // // // // // // // //     const params = useControls('Resonator Controls', { /* ... */ });\n// // // // // // // // // // // //     const shellParams = useControls('Shell Geometry', { /* ... */ });\n// // // // // // // // // // // //     const vizParams = useControls('Visualization', { /* ... */ });\n// // // // // // // // // // // //     // Typed assertions (workaround)\n// // // // // // // // // // // //     const typedParams = params as any; const typedShellParams = shellParams as any; const typedVizParams = vizParams as any;\n// // // // // // // // // // // //     // Inertia calculation\n// // // // // // // // // // // //     const effectiveInertia = useMemo(() => typedParams.inertiaScale * (typedShellParams.outerRadius ** 5 - (typedShellParams.outerRadius - typedShellParams.thickness) ** 5) / typedShellParams.outerRadius ** 5, [typedParams.inertiaScale, typedShellParams.outerRadius, typedShellParams.thickness]);\n// // // // // // // // // // // //     // Physics state ref\n// // // // // // // // // // // //     const physicsState = useRef<PhysicsState>({ shell_angular_velocity_scalar: 0.0, effective_field_velocity_scalar: typedParams.baseFieldSpeed, current_torque_scalar: 0.0, });\n\n// // // // // // // // // // // //     // Particle data memoization\n// // // // // // // // // // // //     const particleData = useMemo(() => {\n// // // // // // // // // // // //         try { /* ... create particle positions and data ... */\n// // // // // // // // // // // //              const data = []; const positions = new Float32Array(typedVizParams.particleCount * 3);\n// // // // // // // // // // // //              for (let i = 0; i < typedVizParams.particleCount; i++) {\n// // // // // // // // // // // //                  const u = Math.random() * Math.PI * 2; const v = Math.random() * Math.PI * 2; const R = typedVizParams.torusMajorRadius; const r = typedVizParams.torusMinorRadius; const randR = R + (Math.random() - 0.5) * 0.2; const randr = r * Math.sqrt(Math.random());\n// // // // // // // // // // // //                  positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u); positions[i * 3 + 1] = randr * Math.sin(v); positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u);\n// // // // // // // // // // // //                  data.push({ u, v, R, r: randr, fieldIndex: 0 }); }\n// // // // // // // // // // // //              return { positions, data };\n// // // // // // // // // // // //         } catch (error) { console.error(\"Error creating particle data:\", error); return { positions: new Float32Array(0), data: [] }; }\n// // // // // // // // // // // //      }, [typedVizParams.particleCount, typedVizParams.torusMajorRadius, typedVizParams.torusMinorRadius]);\n\n\n// // // // // // // // // // // //     // --- FIX: Particle Buffer Update Effect ---\n// // // // // // // // // // // //      useEffect(() => {\n// // // // // // // // // // // //          // Ensure geometry and data are ready\n// // // // // // // // // // // //          if (particleGeoRef.current && particleData && particleData.positions) {\n// // // // // // // // // // // //              // Check if attribute exists and if size matches\n// // // // // // // // // // // //              const existingAttribute = particleGeoRef.current.getAttribute('position') as THREE.BufferAttribute | undefined;\n// // // // // // // // // // // //              if (existingAttribute && existingAttribute.array.length === particleData.positions.length) {\n// // // // // // // // // // // //                  // If size matches, just update the array content (if needed, though initial set is main goal)\n// // // // // // // // // // // //                  // existingAttribute.copyArray(particleData.positions); // Alternative to full replace\n// // // // // // // // // // // //                  // existingAttribute.needsUpdate = true;\n// // // // // // // // // // // //                  // console.log(\"Particle buffer array content updated (size matched).\");\n// // // // // // // // // // // //              } else {\n// // // // // // // // // // // //                  // If attribute doesn't exist or size differs, create/replace it\n// // // // // // // // // // // //                  particleGeoRef.current.setAttribute('position', new THREE.BufferAttribute(particleData.positions, 3, false)); // normalize = false\n// // // // // // // // // // // //                  console.log(\"Particle buffer attribute CREATED/REPLACED.\");\n// // // // // // // // // // // //              }\n// // // // // // // // // // // //          } else {\n// // // // // // // // // // // //               // Clean up old attribute if data is gone? Optional.\n// // // // // // // // // // // //               if (particleGeoRef.current?.getAttribute('position')) {\n// // // // // // // // // // // //                    particleGeoRef.current.deleteAttribute('position');\n// // // // // // // // // // // //                    console.log(\"Particle buffer attribute removed (no data).\");\n// // // // // // // // // // // //               }\n// // // // // // // // // // // //          }\n// // // // // // // // // // // //      }, [particleData]); // Rerun ONLY when the particleData object reference changes\n\n\n// // // // // // // // // // // //     useFrame((state, delta) => {\n// // // // // // // // // // // //         const currentPhysics = physicsState.current;\n// // // // // // // // // // // //         // V1 Physics Placeholder\n// // // // // // // // // // // //         /* ... physics calculations ... */\n// // // // // // // // // // // //         const relative_speed = currentPhysics.effective_field_velocity_scalar - currentPhysics.shell_angular_velocity_scalar; currentPhysics.current_torque_scalar = typedParams.k_drag * typedParams.fieldIntensity * relative_speed; const angular_acceleration = currentPhysics.current_torque_scalar / effectiveInertia; currentPhysics.shell_angular_velocity_scalar += angular_acceleration * delta; currentPhysics.shell_angular_velocity_scalar *= (1 - typedParams.damping * delta); currentPhysics.effective_field_velocity_scalar = typedParams.baseFieldSpeed + typedParams.k_feedback * currentPhysics.shell_angular_velocity_scalar;\n\n// // // // // // // // // // // //         // Visuals Update\n// // // // // // // // // // // //         if (dodecahedronRef.current) { /* ... rotation + emissive */ dodecahedronRef.current.rotation.y += currentPhysics.shell_angular_velocity_scalar * delta; const material = dodecahedronRef.current.material as THREE.MeshStandardMaterial; if (material.emissive) { const maxExpectedTorque = typedParams.k_drag * typedParams.fieldIntensity * (typedParams.baseFieldSpeed * 1.5); const emissionStrength = Math.min(Math.abs(currentPhysics.current_torque_scalar) / (maxExpectedTorque + 0.01), 1.0); material.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5); } }\n\n// // // // // // // // // // // //         // Particle Field Update\n// // // // // // // // // // // //         if (particleGeoRef.current?.attributes.position && particlesRef.current && particleData?.data) {\n// // // // // // // // // // // //              const positions = particleGeoRef.current.attributes.position.array as Float32Array;\n// // // // // // // // // // // //              // --- FIX: Remove the size check and attribute reset from here ---\n// // // // // // // // // // // //              // if (positions.length === typedVizParams.particleCount * 3) { // REMOVED CHECK\n// // // // // // // // // // // //                  const speed = currentPhysics.effective_field_velocity_scalar * typedParams.fieldIntensity;\n// // // // // // // // // // // //                  const pData = particleData.data;\n// // // // // // // // // // // //                  (particlesRef.current.material as THREE.PointsMaterial).size = typedVizParams.particleSize * (1 + typedParams.fieldIntensity * 0.5);\n\n// // // // // // // // // // // //                  for (let i = 0; i < pData.length; i++) { // Iterate based on pData length\n// // // // // // // // // // // //                      // Check array bounds just in case\n// // // // // // // // // // // //                      if (i * 3 + 2 >= positions.length) break;\n\n// // // // // // // // // // // //                      const data = pData[i]; data.u += speed * delta;\n// // // // // // // // // // // //                      const R = data.R; const r = data.r; const u = data.u; const v = data.v;\n// // // // // // // // // // // //                      positions[i * 3]     = (R + r * Math.cos(v)) * Math.cos(u);\n// // // // // // // // // // // //                      positions[i * 3 + 1] = r * Math.sin(v);\n// // // // // // // // // // // //                      positions[i * 3 + 2] = (R + r * Math.cos(v)) * Math.sin(u);\n// // // // // // // // // // // //                  }\n// // // // // // // // // // // //                  particleGeoRef.current.attributes.position.needsUpdate = true;\n// // // // // // // // // // // //             // } else { // REMOVED ELSE BLOCK\n// // // // // // // // // // // //             //    console.warn(\"Particle buffer size mismatch inside useFrame.\"); // Should not happen now\n// // // // // // // // // // // //             // }\n// // // // // // // // // // // //         }\n// // // // // // // // // // // //     });\n\n// // // // // // // // // // // //     const copperMaterial = useMemo(() => new THREE.MeshStandardMaterial({ /* ... */ color: 0xB87333, metalness: 0.8, roughness: 0.3, emissive: 0x000000, emissiveIntensity: 1.0, side: THREE.DoubleSide }), []);\n\n// // // // // // // // // // // //     return (\n// // // // // // // // // // // //         <>\n// // // // // // // // // // // //             <RomanDodecahedron ref={dodecahedronRef} outerRadius={typedShellParams.outerRadius} thickness={typedShellParams.thickness} holeBaseDiameter={typedShellParams.holeBaseDiameter} holeRatio={typedShellParams.holeRatio} noduleRadius={typedShellParams.noduleRadius} material={copperMaterial} castShadow receiveShadow />\n// // // // // // // // // // // //             <points ref={particlesRef}>\n// // // // // // // // // // // //                  {/* Geometry ref is enough, attribute is handled by effect */}\n// // // // // // // // // // // //                  <bufferGeometry ref={particleGeoRef} />\n// // // // // // // // // // // //                  <pointsMaterial color={0x00ffff} size={typedVizParams.particleSize} transparent opacity={0.7} blending={THREE.AdditiveBlending} sizeAttenuation={true} map={null} />\n// // // // // // // // // // // //             </points>\n// // // // // // // // // // // //         </>\n// // // // // // // // // // // //     );\n// // // // // // // // // // // // };\n\n// // // // // // // // // // // // // --- Scene Component (Container - Unchanged) ---\n// // // // // // // // // // // // const TemporalResonatorScene: React.FC = () => { /* ... */ return (<>{/* Leva */}<Canvas>{/* Lights */}<ErrorBoundary><Suspense fallback={<LoadingPlaceholder />}><ResonatorSimulation /></Suspense></ErrorBoundary><Controls /></Canvas></>);};\n// // // // // // // // // // // // const LoadingPlaceholder = () => { /* ... */ return (<mesh><boxGeometry args={[0.1, 0.1, 0.1]} /><meshBasicMaterial color=\"orange\" wireframe /></mesh>);};\n// // // // // // // // // // // // export default TemporalResonatorScene;\n\n\n// // // // // // // // // // // // // // TemporalResonatorScene_V2_CSG_Fixes_3.tsx\n// // // // // // // // // // // // // import React, { useRef, useEffect, useMemo, Suspense } from 'react';\n// // // // // // // // // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // // // // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // // // // // // // // // import * as THREE from 'three';\n// // // // // // // // // // // // // import ErrorBoundary from './errorBoundary';\n// // // // // // // // // // // // // import { useControls, Leva } from 'leva';\n// // // // // // // // // // // // // import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\n// // // // // // // // // // // // // import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n\n// // // // // // // // // // // // // THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\n// // // // // // // // // // // // // THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\n// // // // // // // // // // // // // THREE.Mesh.prototype.raycast = acceleratedRaycast;\n\n// // // // // // // // // // // // // const csgEvaluator = new Evaluator();\n// // // // // // // // // // // // // csgEvaluator.useGroups = true;\n\n// // // // // // // // // // // // // extend({ OrbitControls });\n\n// // // // // // // // // // // // // // --- Constants ---\n// // // // // // // // // // // // // const PHI = (1 + Math.sqrt(5)) / 2; // Golden ratio\n// // // // // // // // // // // // // const INV_PHI = 1 / PHI;\n\n// // // // // // // // // // // // // // --- Helper: Get Dodecahedron Math Data ---\n// // // // // // // // // // // // // function getDodecahedronData(radius: number) {\n// // // // // // // // // // // // //     const vertices: THREE.Vector3[] = [];\n// // // // // // // // // // // // //     // Vertices based on permutations (scaled for radius 1 initially, then scaled by actual radius)\n// // // // // // // // // // // // //     // Standard vertex positions for radius sqrt(3)\n// // // // // // // // // // // // //     const baseVerts = [\n// // // // // // // // // // // // //         [1, 1, 1], [-1, 1, 1], [1, -1, 1], [-1, -1, 1],\n// // // // // // // // // // // // //         [1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1]\n// // // // // // // // // // // // //     ];\n// // // // // // // // // // // // //     const phiVerts = [\n// // // // // // // // // // // // //         [0, PHI, INV_PHI], [0, -PHI, INV_PHI], [0, PHI, -INV_PHI], [0, -PHI, -INV_PHI],\n// // // // // // // // // // // // //         [INV_PHI, 0, PHI], [-INV_PHI, 0, PHI], [INV_PHI, 0, -PHI], [-INV_PHI, 0, -PHI],\n// // // // // // // // // // // // //         [PHI, INV_PHI, 0], [-PHI, INV_PHI, 0], [PHI, -INV_PHI, 0], [-PHI, -INV_PHI, 0]\n// // // // // // // // // // // // //     ];\n\n// // // // // // // // // // // // //     // Calculate scale factor: DodecahedronGeometry(1) seems to have vertices at distance ~1.902 from origin.\n// // // // // // // // // // // // //     // Let's use the PHI-based vertices which naturally give radius ~sqrt(3)? No, needs scaling.\n// // // // // // // // // // // // //     // Let vertex (PHI, INV_PHI, 0) define the radius. dist = sqrt(PHI^2 + INV_PHI^2)\n// // // // // // // // // // // // //     const distOriginToVertex = Math.sqrt(PHI*PHI + INV_PHI*INV_PHI); // ~1.9021\n// // // // // // // // // // // // //     const scale = radius / distOriginToVertex;\n\n// // // // // // // // // // // // //     [...baseVerts, ...phiVerts].forEach(v => {\n// // // // // // // // // // // // //         // Filter unique vertices based on rounded coords (handles permutations creating duplicates)\n// // // // // // // // // // // // //         const x = v[0] * scale, y = v[1] * scale, z = v[2] * scale;\n// // // // // // // // // // // // //         const key = `${x.toFixed(4)},${y.toFixed(4)},${z.toFixed(4)}`;\n// // // // // // // // // // // // //         // Use a Map to check uniqueness easily\n// // // // // // // // // // // // //         if (!vertices.some(existingV => `${existingV.x.toFixed(4)},${existingV.y.toFixed(4)},${existingV.z.toFixed(4)}` === key)) {\n// // // // // // // // // // // // //              vertices.push(new THREE.Vector3(x, y, z));\n// // // // // // // // // // // // //         }\n// // // // // // // // // // // // //     });\n// // // // // // // // // // // // //      // Ensure exactly 20 unique vertices\n// // // // // // // // // // // // //      if (vertices.length !== 20) {\n// // // // // // // // // // // // //           console.warn(`Expected 20 vertices, but calculated ${vertices.length}. Using generated vertices anyway.`);\n// // // // // // // // // // // // //           // Fallback might be needed if vertex calc is wrong.\n// // // // // // // // // // // // //      }\n\n\n// // // // // // // // // // // // //     // Face centers & normals (points towards vertices of dual icosahedron)\n// // // // // // // // // // // // //     const faceData: { center: THREE.Vector3; normal: THREE.Vector3 }[] = [];\n// // // // // // // // // // // // //     const icoVerts = [\n// // // // // // // // // // // // //         [0, 1, PHI], [0, -1, PHI], [0, 1, -PHI], [0, -1, -PHI],\n// // // // // // // // // // // // //         [1, PHI, 0], [-1, PHI, 0], [1, -PHI, 0], [-1, -PHI, 0],\n// // // // // // // // // // // // //         [PHI, 0, 1], [-PHI, 0, 1], [PHI, 0, -1], [-PHI, 0, -1]\n// // // // // // // // // // // // //     ];\n\n// // // // // // // // // // // // //     // Calculate distance from origin to face center for radius R\n// // // // // // // // // // // // //     // Inradius of dodecahedron = R * PHI^2 / sqrt(3) ? No, that's circumradius relation.\n// // // // // // // // // // // // //     // Inradius = edgeLength * PHI^2 / (2 * sqrt(3-PHI))\n// // // // // // // // // // // // //     // Simpler: Face center distance = scale * sqrt(2 + PHI) ? No.\n// // // // // // // // // // // // //     // Let's scale the NORMAL vector from the icosahedron vertex to an appropriate length.\n// // // // // // // // // // // // //     // How far is face center in DodecahedronGeometry(1)? Let's estimate ~1.53\n// // // // // // // // // // // // //     const faceCenterDist = radius * 1.53 / 1.902; // Scale proportionally\n\n// // // // // // // // // // // // //     icoVerts.forEach(v => {\n// // // // // // // // // // // // //         const normal = new THREE.Vector3(v[0], v[1], v[2]).normalize();\n// // // // // // // // // // // // //         const center = normal.clone().multiplyScalar(faceCenterDist); // Place center along normal\n// // // // // // // // // // // // //         faceData.push({ center, normal });\n// // // // // // // // // // // // //     });\n\n// // // // // // // // // // // // //     return { vertices, faceData };\n// // // // // // // // // // // // // }\n\n\n// // // // // // // // // // // // // // --- Controls Component (Unchanged) ---\n// // // // // // // // // // // // // const Controls = () => { /* ... */\n// // // // // // // // // // // // //      const { camera, gl } = useThree(); const controlsRef = useRef<OrbitControls>(null);\n// // // // // // // // // // // // //      useEffect(() => { const controls = new OrbitControls(camera, gl.domElement); controls.enableDamping = true; (controlsRef as any).current = controls; return () => { controls.dispose(); }; }, [camera, gl]);\n// // // // // // // // // // // // //      useFrame(() => { controlsRef.current?.update(); }); return null;\n// // // // // // // // // // // // //  };\n\n// // // // // // // // // // // // // // --- Roman Dodecahedron CSG Component (Using Math Data) ---\n// // // // // // // // // // // // // interface RomanDodecahedronProps { /* ... */ outerRadius: number; thickness: number; holeBaseDiameter: number; holeRatio: number; noduleRadius: number; material: THREE.Material; [key: string]: any;}\n// // // // // // // // // // // // // const RomanDodecahedron: React.FC<RomanDodecahedronProps> = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>(\n// // // // // // // // // // // // //     ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, ...props }, ref) => {\n\n// // // // // // // // // // // // //     const geometry = useMemo(() => {\n// // // // // // // // // // // // //         console.log(\"Recalculating CSG Geometry using Math Data...\");\n// // // // // // // // // // // // //         const detailLevel = 1; // Keep detail low for CSG base\n\n// // // // // // // // // // // // //         try {\n// // // // // // // // // // // // //             // 0. Get Math Data\n// // // // // // // // // // // // //             const { vertices: mathVertices, faceData: mathFaceData } = getDodecahedronData(outerRadius);\n// // // // // // // // // // // // //             if (mathVertices.length !== 20 || mathFaceData.length !== 12) {\n// // // // // // // // // // // // //                  throw new Error(`Incorrect math data count: ${mathVertices.length} vertices, ${mathFaceData.length} faces`);\n// // // // // // // // // // // // //             }\n\n// // // // // // // // // // // // //             // 1. Base Shell Brushes\n// // // // // // // // // // // // //             const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, detailLevel);\n// // // // // // // // // // // // //             outerDodecGeo.computeBoundsTree();\n// // // // // // // // // // // // //             const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, detailLevel);\n// // // // // // // // // // // // //             innerDodecGeo.computeBoundsTree();\n// // // // // // // // // // // // //             let outerBrush = new Brush(outerDodecGeo); let innerBrush = new Brush(innerDodecGeo);\n// // // // // // // // // // // // //             innerBrush.updateMatrixWorld();\n// // // // // // // // // // // // //             let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n// // // // // // // // // // // // //             outerBrush.geometry.dispose(); innerBrush.geometry.dispose();\n\n// // // // // // // // // // // // //             // 2. Holes (Cylinders - Using Math Face Data)\n// // // // // // // // // // // // //             const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * (holeRatio ** i));\n// // // // // // // // // // // // //             const cylinderHeight = thickness * 3; // Ensure it goes through\n// // // // // // // // // // // // //             const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16);\n// // // // // // // // // // // // //             cylinderGeo.rotateX(Math.PI / 2); cylinderGeo.computeBoundsTree();\n// // // // // // // // // // // // //             const tempQuat = new THREE.Quaternion();\n\n// // // // // // // // // // // // //             mathFaceData.forEach((face, index) => {\n// // // // // // // // // // // // //                 const holeRadius = holeDiameters[index] / 2;\n// // // // // // // // // // // // //                 if (!holeRadius || holeRadius <= 0) {\n// // // // // // // // // // // // //                     console.warn(`Skipping hole ${index} due to invalid radius: ${holeRadius}`);\n// // // // // // // // // // // // //                     return; // Skip this hole\n// // // // // // // // // // // // //                 }\n// // // // // // // // // // // // //                 const holeBrush = new Brush(cylinderGeo);\n// // // // // // // // // // // // //                 holeBrush.scale.set(holeRadius, holeRadius, 1);\n// // // // // // // // // // // // //                 // Align cylinder's Z-axis to the calculated face normal\n// // // // // // // // // // // // //                 tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), face.normal);\n// // // // // // // // // // // // //                 holeBrush.quaternion.copy(tempQuat);\n// // // // // // // // // // // // //                 // Position cylinder at the calculated face center\n// // // // // // // // // // // // //                 holeBrush.position.copy(face.center);\n// // // // // // // // // // // // //                 holeBrush.updateMatrixWorld();\n// // // // // // // // // // // // //                 shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION);\n// // // // // // // // // // // // //             });\n// // // // // // // // // // // // //             cylinderGeo.dispose(); // Dispose template geo\n\n// // // // // // // // // // // // //             // 3. Nodules (Spheres - Using Math Vertex Data)\n// // // // // // // // // // // // //             const noduleGeo = new THREE.SphereGeometry(noduleRadius, 6, 6);\n// // // // // // // // // // // // //             noduleGeo.computeBoundsTree();\n// // // // // // // // // // // // //             mathVertices.forEach(vertexPos => {\n// // // // // // // // // // // // //                 const noduleBrush = new Brush(noduleGeo);\n// // // // // // // // // // // // //                 noduleBrush.position.copy(vertexPos);\n// // // // // // // // // // // // //                 noduleBrush.updateMatrixWorld();\n// // // // // // // // // // // // //                 shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION);\n// // // // // // // // // // // // //             });\n// // // // // // // // // // // // //             noduleGeo.dispose(); // Dispose template geo\n\n// // // // // // // // // // // // //             // 4. Final Geometry & Recenter\n// // // // // // // // // // // // //             const finalGeometry = shellBrush.geometry;\n// // // // // // // // // // // // //             finalGeometry.computeVertexNormals();\n// // // // // // // // // // // // //             // --- FIX: Recenter the final geometry ---\n// // // // // // // // // // // // //             finalGeometry.center();\n\n// // // // // // // // // // // // //             console.log(\"CSG Geometry Recalculation Complete & Centered.\");\n// // // // // // // // // // // // //             return finalGeometry;\n\n// // // // // // // // // // // // //         } catch(error) {\n// // // // // // // // // // // // //             console.error(\"CSG Error:\", error);\n// // // // // // // // // // // // //             return new THREE.BufferGeometry();\n// // // // // // // // // // // // //         }\n\n// // // // // // // // // // // // //     }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]); // Dependencies\n\n// // // // // // // // // // // // //     useEffect(() => { /* ... dispose effect ... */ return () => { if (geometry && typeof (geometry as any).dispose === 'function') { (geometry as any).dispose(); console.log(\"Disposed CSG geometry\"); } }; }, [geometry]);\n\n// // // // // // // // // // // // //     return <mesh ref={ref} geometry={geometry} material={material} {...props} />;\n// // // // // // // // // // // // // });\n\n// // // // // // // // // // // // // // --- Physics State Interface (Unchanged) ---\n// // // // // // // // // // // // // interface PhysicsState { /* ... */ shell_angular_velocity_scalar: number; effective_field_velocity_scalar: number; current_torque_scalar: number;}\n\n// // // // // // // // // // // // // // --- Main Simulation Component (Unchanged from previous attempt) ---\n// // // // // // // // // // // // // const ResonatorSimulation = () => {\n// // // // // // // // // // // // //     const dodecahedronRef = useRef<THREE.Mesh>(null!);\n// // // // // // // // // // // // //     const particlesRef = useRef<THREE.Points>(null!);\n// // // // // // // // // // // // //     const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // // // // // // // // // // // //     const params = useControls('Resonator Controls', { /* ... */ });\n// // // // // // // // // // // // //     const shellParams = useControls('Shell Geometry', { /* ... */ });\n// // // // // // // // // // // // //     const vizParams = useControls('Visualization', { /* ... */ });\n// // // // // // // // // // // // //     const typedParams = params as any; const typedShellParams = shellParams as any; const typedVizParams = vizParams as any;\n// // // // // // // // // // // // //     const effectiveInertia = useMemo(() => { /* ... */ return typedParams.inertiaScale * (typedShellParams.outerRadius ** 5 - (typedShellParams.outerRadius - typedShellParams.thickness) ** 5) / typedShellParams.outerRadius ** 5; }, [typedParams.inertiaScale, typedShellParams.outerRadius, typedShellParams.thickness]);\n// // // // // // // // // // // // //     const physicsState = useRef<PhysicsState>({ shell_angular_velocity_scalar: 0.0, effective_field_velocity_scalar: typedParams.baseFieldSpeed, current_torque_scalar: 0.0, });\n// // // // // // // // // // // // //     const particleData = useMemo(() => { try { /* ... create particle data ... */ const data = []; const positions = new Float32Array(typedVizParams.particleCount * 3); for (let i = 0; i < typedVizParams.particleCount; i++) { const u = Math.random() * Math.PI * 2; const v = Math.random() * Math.PI * 2; const R = typedVizParams.torusMajorRadius; const r = typedVizParams.torusMinorRadius; const randR = R + (Math.random() - 0.5) * 0.2; const randr = r * Math.sqrt(Math.random()); positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u); positions[i * 3 + 1] = randr * Math.sin(v); positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u); data.push({ u, v, R, r: randr, fieldIndex: 0 }); } return { positions, data }; } catch (error) { console.error(\"Error creating particle data:\", error); return { positions: new Float32Array(0), data: [] }; } }, [typedVizParams.particleCount, typedVizParams.torusMajorRadius, typedVizParams.torusMinorRadius]);\n\n// // // // // // // // // // // // //     useFrame((state, delta) => { /* ... V1 physics + Visual updates ... */\n// // // // // // // // // // // // //         const currentPhysics = physicsState.current;\n// // // // // // // // // // // // //         const relative_speed = currentPhysics.effective_field_velocity_scalar - currentPhysics.shell_angular_velocity_scalar;\n// // // // // // // // // // // // //         currentPhysics.current_torque_scalar = typedParams.k_drag * typedParams.fieldIntensity * relative_speed;\n// // // // // // // // // // // // //         const angular_acceleration = currentPhysics.current_torque_scalar / effectiveInertia;\n// // // // // // // // // // // // //         currentPhysics.shell_angular_velocity_scalar += angular_acceleration * delta;\n// // // // // // // // // // // // //         currentPhysics.shell_angular_velocity_scalar *= (1 - typedParams.damping * delta);\n// // // // // // // // // // // // //         currentPhysics.effective_field_velocity_scalar = typedParams.baseFieldSpeed + typedParams.k_feedback * currentPhysics.shell_angular_velocity_scalar;\n// // // // // // // // // // // // //         if (dodecahedronRef.current) { dodecahedronRef.current.rotation.y += currentPhysics.shell_angular_velocity_scalar * delta; const material = dodecahedronRef.current.material as THREE.MeshStandardMaterial; if (material.emissive) { const maxExpectedTorque = typedParams.k_drag * typedParams.fieldIntensity * (typedParams.baseFieldSpeed * 1.5); const emissionStrength = Math.min(Math.abs(currentPhysics.current_torque_scalar) / (maxExpectedTorque + 0.01), 1.0); material.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5); } }\n// // // // // // // // // // // // //         if (particleGeoRef.current && particlesRef.current && particleData && particleData.positions) { const positions = particleGeoRef.current.attributes.position.array as Float32Array; if (positions.length === typedVizParams.particleCount * 3) { const speed = currentPhysics.effective_field_velocity_scalar * typedParams.fieldIntensity; const pData = particleData.data; (particlesRef.current.material as THREE.PointsMaterial).size = typedVizParams.particleSize * (1 + typedParams.fieldIntensity * 0.5); for (let i = 0; i < typedVizParams.particleCount; i++) { const data = pData[i]; data.u += speed * delta; const R = data.R; const r = data.r; const u = data.u; const v = data.v; positions[i * 3] = (R + r * Math.cos(v)) * Math.cos(u); positions[i * 3 + 1] = r * Math.sin(v); positions[i * 3 + 2] = (R + r * Math.cos(v)) * Math.sin(u); } particleGeoRef.current.attributes.position.needsUpdate = true; } else if (particleGeoRef.current.attributes.position) { console.warn(\"Particle buffer size mismatch.\"); particleGeoRef.current.setAttribute('position', new THREE.BufferAttribute(particleData.positions, 3)); } }\n// // // // // // // // // // // // //      });\n\n// // // // // // // // // // // // //     const copperMaterial = useMemo(() => new THREE.MeshStandardMaterial({ /* ... */ color: 0xB87333, metalness: 0.8, roughness: 0.3, emissive: 0x000000, emissiveIntensity: 1.0, side: THREE.DoubleSide }), []);\n// // // // // // // // // // // // //     useEffect(() => { if (particleGeoRef.current && particleData && particleData.positions) { particleGeoRef.current.setAttribute('position', new THREE.BufferAttribute(particleData.positions, 3)); console.log(\"Particle buffer attribute updated/created.\"); } }, [particleData]);\n\n// // // // // // // // // // // // //     return (\n// // // // // // // // // // // // //         <>\n// // // // // // // // // // // // //             <RomanDodecahedron\n// // // // // // // // // // // // //                 ref={dodecahedronRef}\n// // // // // // // // // // // // //                 outerRadius={typedShellParams.outerRadius} thickness={typedShellParams.thickness}\n// // // // // // // // // // // // //                 holeBaseDiameter={typedShellParams.holeBaseDiameter} holeRatio={typedShellParams.holeRatio}\n// // // // // // // // // // // // //                 noduleRadius={typedShellParams.noduleRadius}\n// // // // // // // // // // // // //                 material={copperMaterial}\n// // // // // // // // // // // // //                 castShadow receiveShadow\n// // // // // // // // // // // // //             />\n// // // // // // // // // // // // //             <points ref={particlesRef}>\n// // // // // // // // // // // // //                  <bufferGeometry ref={particleGeoRef} /> {/* Attribute set by useEffect */}\n// // // // // // // // // // // // //                  <pointsMaterial\n// // // // // // // // // // // // //                      color={0x00ffff} size={typedVizParams.particleSize}\n// // // // // // // // // // // // //                      transparent opacity={0.7} blending={THREE.AdditiveBlending}\n// // // // // // // // // // // // //                      sizeAttenuation={true} // Keep true for distance scaling\n// // // // // // // // // // // // //                      map={null}\n// // // // // // // // // // // // //                  />\n// // // // // // // // // // // // //             </points>\n// // // // // // // // // // // // //         </>\n// // // // // // // // // // // // //     );\n// // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // --- Scene Component (Container - Added Hemisphere Light) ---\n// // // // // // // // // // // // // const TemporalResonatorScene: React.FC = () => (\n// // // // // // // // // // // // //     <>\n// // // // // // // // // // // // //         <Leva collapsed={false} titleBar={{ title: 'Controls' }} />\n// // // // // // // // // // // // //         <Canvas\n// // // // // // // // // // // // //              style={{ position: 'absolute', top: 0, left: 0, width: '100vw', height: '100vh', background: '#111122', zIndex: 0 }}\n// // // // // // // // // // // // //              camera={{ position: [3, 3, 5], fov: 75 }}\n// // // // // // // // // // // // //              gl={{ antialias: true }} shadows\n// // // // // // // // // // // // //         >\n// // // // // // // // // // // // //              <ambientLight intensity={0.2} /> {/* Lower ambient slightly */}\n// // // // // // // // // // // // //              {/* --- FIX: Add Hemisphere Light --- */}\n// // // // // // // // // // // // //              <hemisphereLight groundColor={0x404040} intensity={0.6} />\n// // // // // // // // // // // // //              <directionalLight\n// // // // // // // // // // // // //                  position={[5, 10, 7.5]} intensity={0.8} // Slightly lower directional\n// // // // // // // // // // // // //                  castShadow shadow-mapSize-width={1024} shadow-mapSize-height={1024}\n// // // // // // // // // // // // //                  shadow-camera-far={25} shadow-camera-left={-10} shadow-camera-right={10}\n// // // // // // // // // // // // //                  shadow-camera-top={10} shadow-camera-bottom={-10}\n// // // // // // // // // // // // //              />\n// // // // // // // // // // // // //              <ErrorBoundary>\n// // // // // // // // // // // // //                  <Suspense fallback={<LoadingPlaceholder />}>\n// // // // // // // // // // // // //                       <ResonatorSimulation />\n// // // // // // // // // // // // //                  </Suspense>\n// // // // // // // // // // // // //              </ErrorBoundary>\n// // // // // // // // // // // // //              <Controls />\n// // // // // // // // // // // // //         </Canvas>\n// // // // // // // // // // // // //     </>\n// // // // // // // // // // // // // );\n// // // // // // // // // // // // // const LoadingPlaceholder = () => { /* ... */ return (<mesh><boxGeometry args={[0.1, 0.1, 0.1]} /><meshBasicMaterial color=\"orange\" wireframe /></mesh>);};\n\n// // // // // // // // // // // // // export default TemporalResonatorScene;\n\n\n// // // // // // // // // // // // // // // TemporalResonatorScene_V2_CSG_Fixes_2.tsx\n// // // // // // // // // // // // // // import React, { useRef, useEffect, useMemo, Suspense } from 'react';\n// // // // // // // // // // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // // // // // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // // // // // // // // // // import * as THREE from 'three';\n// // // // // // // // // // // // // // import ErrorBoundary from './errorBoundary';\n// // // // // // // // // // // // // // import { useControls, Leva } from 'leva';\n// // // // // // // // // // // // // // import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\n// // // // // // // // // // // // // // import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n\n// // // // // // // // // // // // // // THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\n// // // // // // // // // // // // // // THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\n// // // // // // // // // // // // // // THREE.Mesh.prototype.raycast = acceleratedRaycast;\n\n// // // // // // // // // // // // // // const csgEvaluator = new Evaluator();\n// // // // // // // // // // // // // // csgEvaluator.useGroups = true;\n\n// // // // // // // // // // // // // // extend({ OrbitControls });\n\n// // // // // // // // // // // // // // // --- Controls Component (Unchanged) ---\n// // // // // // // // // // // // // // const Controls = () => { /* ... */\n// // // // // // // // // // // // // //     const { camera, gl } = useThree();\n// // // // // // // // // // // // // //     const controlsRef = useRef<OrbitControls>(null);\n// // // // // // // // // // // // // //     useEffect(() => { /* ... create and dispose controls ... */\n// // // // // // // // // // // // // //       const controls = new OrbitControls(camera, gl.domElement); controls.enableDamping = true;\n// // // // // // // // // // // // // //       (controlsRef as React.MutableRefObject<OrbitControls>).current = controls;\n// // // // // // // // // // // // // //       return () => { controls.dispose(); };\n// // // // // // // // // // // // // //      }, [camera, gl]);\n// // // // // // // // // // // // // //     useFrame(() => { controlsRef.current?.update(); });\n// // // // // // // // // // // // // //     return null;\n// // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // --- Roman Dodecahedron CSG Component (Unchanged from previous attempt) ---\n// // // // // // // // // // // // // // interface RomanDodecahedronProps { /* ... */\n// // // // // // // // // // // // // //     outerRadius: number; thickness: number; holeBaseDiameter: number;\n// // // // // // // // // // // // // //     holeRatio: number; noduleRadius: number; material: THREE.Material;\n// // // // // // // // // // // // // //     [key: string]: any;\n// // // // // // // // // // // // // //  }\n// // // // // // // // // // // // // // const RomanDodecahedron: React.FC<RomanDodecahedronProps> = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>(\n// // // // // // // // // // // // // //     ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, ...props }, ref) => {\n// // // // // // // // // // // // // //         const geometry = useMemo(() => { /* ... CSG logic ... */\n// // // // // // // // // // // // // //              console.log(\"Recalculating CSG Geometry...\");\n// // // // // // // // // // // // // //              const detailLevel = 1; // Stick to detail 1 for reliable face indexing for now\n// // // // // // // // // // // // // //              try {\n// // // // // // // // // // // // // //                 // Base shell\n// // // // // // // // // // // // // //                 const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, detailLevel);\n// // // // // // // // // // // // // //                 outerDodecGeo.computeBoundsTree();\n// // // // // // // // // // // // // //                 const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, detailLevel);\n// // // // // // // // // // // // // //                 innerDodecGeo.computeBoundsTree();\n// // // // // // // // // // // // // //                 let outerBrush = new Brush(outerDodecGeo); let innerBrush = new Brush(innerDodecGeo);\n// // // // // // // // // // // // // //                 innerBrush.updateMatrixWorld();\n// // // // // // // // // // // // // //                 let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n// // // // // // // // // // // // // //                 outerBrush.geometry.dispose(); innerBrush.geometry.dispose();\n\n// // // // // // // // // // // // // //                 // Holes\n// // // // // // // // // // // // // //                 const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * (holeRatio ** i));\n// // // // // // // // // // // // // //                 const cylinderHeight = thickness * 3;\n// // // // // // // // // // // // // //                 const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16);\n// // // // // // // // // // // // // //                 cylinderGeo.rotateX(Math.PI / 2); cylinderGeo.computeBoundsTree();\n// // // // // // // // // // // // // //                 const tempPos = new THREE.Vector3(); const tempQuat = new THREE.Quaternion();\n// // // // // // // // // // // // // //                 const vertices = outerDodecGeo.attributes.position.array;\n// // // // // // // // // // // // // //                 const indices = outerDodecGeo.index ? outerDodecGeo.index.array : null;\n// // // // // // // // // // // // // //                 let faceIndex = 0;\n// // // // // // // // // // // // // //                 if (!indices) throw new Error(\"Dodec lacks indices\");\n\n// // // // // // // // // // // // // //                 for (let i = 0; i < indices.length; i += 9) { // Step 9 for detail 1\n// // // // // // // // // // // // // //                     if (faceIndex >= 12) break;\n// // // // // // // // // // // // // //                     const vIndices = new Set<number>();\n// // // // // // // // // // // // // //                     for(let j=0; j<9; j++){ vIndices.add(indices[i+j]); }\n// // // // // // // // // // // // // //                     const center = new THREE.Vector3(0,0,0); let vertexCount = 0;\n// // // // // // // // // // // // // //                     vIndices.forEach((idx) => { /* ... get vertex, add to center ... */\n// // // // // // // // // // // // // //                          if (idx * 3 + 2 < vertices.length) {\n// // // // // // // // // // // // // //                              tempPos.set(vertices[idx * 3], vertices[idx * 3 + 1], vertices[idx * 3 + 2]);\n// // // // // // // // // // // // // //                              center.add(tempPos); vertexCount++;\n// // // // // // // // // // // // // //                          } });\n// // // // // // // // // // // // // //                     if (vertexCount === 0) { faceIndex++; continue; } center.divideScalar(vertexCount);\n// // // // // // // // // // // // // //                     const normal = center.clone().normalize(); const holeRadius = holeDiameters[faceIndex] / 2;\n// // // // // // // // // // // // // //                     if (!holeRadius || holeRadius <= 0) { faceIndex++; continue; }\n\n// // // // // // // // // // // // // //                     const holeBrush = new Brush(cylinderGeo); holeBrush.scale.set(holeRadius, holeRadius, 1);\n// // // // // // // // // // // // // //                     tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), normal);\n// // // // // // // // // // // // // //                     holeBrush.quaternion.copy(tempQuat); holeBrush.position.copy(center);\n// // // // // // // // // // // // // //                     holeBrush.updateMatrixWorld();\n// // // // // // // // // // // // // //                     shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION);\n// // // // // // // // // // // // // //                     faceIndex++;\n// // // // // // // // // // // // // //                 }\n// // // // // // // // // // // // // //                  cylinderGeo.dispose();\n\n// // // // // // // // // // // // // //                 // Nodules\n// // // // // // // // // // // // // //                  const noduleGeo = new THREE.SphereGeometry(noduleRadius, 6, 6); noduleGeo.computeBoundsTree();\n// // // // // // // // // // // // // //                  const uniqueVertices = new Map<string, THREE.Vector3>();\n// // // // // // // // // // // // // //                  for (let i = 0; i < outerDodecGeo.attributes.position.count; i++) { /* ... find unique vertices ... */\n// // // // // // // // // // // // // //                       tempPos.fromBufferAttribute(outerDodecGeo.attributes.position, i);\n// // // // // // // // // // // // // //                       const key = `${tempPos.x.toFixed(4)},${tempPos.y.toFixed(4)},${tempPos.z.toFixed(4)}`;\n// // // // // // // // // // // // // //                       if (!uniqueVertices.has(key)) { uniqueVertices.set(key, tempPos.clone()); }\n// // // // // // // // // // // // // //                  }\n// // // // // // // // // // // // // //                  uniqueVertices.forEach(vertexPos => { /* ... add nodule brushes ... */\n// // // // // // // // // // // // // //                      const noduleBrush = new Brush(noduleGeo); noduleBrush.position.copy(vertexPos);\n// // // // // // // // // // // // // //                      noduleBrush.updateMatrixWorld();\n// // // // // // // // // // // // // //                      shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION);\n// // // // // // // // // // // // // //                  });\n// // // // // // // // // // // // // //                  noduleGeo.dispose();\n\n// // // // // // // // // // // // // //                 const finalGeometry = shellBrush.geometry; finalGeometry.computeVertexNormals();\n// // // // // // // // // // // // // //                 outerDodecGeo.dispose(); // Dispose the temporary high-detail outer geo\n// // // // // // // // // // // // // //                 console.log(\"CSG Geometry Recalculation Complete.\");\n// // // // // // // // // // // // // //                 return finalGeometry;\n// // // // // // // // // // // // // //              } catch(error) {\n// // // // // // // // // // // // // //                  console.error(\"CSG Error:\", error);\n// // // // // // // // // // // // // //                  // Attempt cleanup on error\n// // // // // // // // // // // // // //                  // cylinderGeo?.dispose(); outerDodecGeo?.dispose(); innerDodecGeo?.dispose(); noduleGeo?.dispose();\n// // // // // // // // // // // // // //                  return new THREE.BufferGeometry(); // Return empty\n// // // // // // // // // // // // // //              }\n// // // // // // // // // // // // // //         }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]);\n\n// // // // // // // // // // // // // //         useEffect(() => { /* ... dispose effect ... */\n// // // // // // // // // // // // // //             return () => { if (geometry && typeof (geometry as THREE.BufferGeometry).dispose === 'function') { (geometry as THREE.BufferGeometry).dispose(); console.log(\"Disposed CSG geometry\"); } };\n// // // // // // // // // // // // // //         }, [geometry]);\n\n// // // // // // // // // // // // // //         return <mesh ref={ref} geometry={geometry} material={material} {...props} />;\n// // // // // // // // // // // // // // });\n\n\n// // // // // // // // // // // // // // // --- FIX 4: Define Physics State Interface ---\n// // // // // // // // // // // // // // interface PhysicsState {\n// // // // // // // // // // // // // //     shell_angular_velocity_scalar: number;\n// // // // // // // // // // // // // //     effective_field_velocity_scalar: number;\n// // // // // // // // // // // // // //     current_torque_scalar: number;\n// // // // // // // // // // // // // //     // Add V2 state later:\n// // // // // // // // // // // // // //     // shell_angular_velocity: THREE.Vector3;\n// // // // // // // // // // // // // //     // shell_orientation: THREE.Quaternion;\n// // // // // // // // // // // // // //     // current_torque: THREE.Vector3;\n// // // // // // // // // // // // // // }\n\n// // // // // // // // // // // // // // // --- Main Simulation Component ---\n// // // // // // // // // // // // // // const ResonatorSimulation = () => {\n// // // // // // // // // // // // // //     const dodecahedronRef = useRef<THREE.Mesh>(null!);\n// // // // // // // // // // // // // //     const particlesRef = useRef<THREE.Points>(null!);\n// // // // // // // // // // // // // //     const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // // // // // // // // // // // // //     // --- Leva Controls (Still potentially 'unknown' to TS, but access should work) ---\n// // // // // // // // // // // // // //     const params = useControls('Resonator Controls', { /* ... */\n// // // // // // // // // // // // // //         baseFieldSpeed: { value: 1.0, min: -5, max: 5, step: 0.1 },\n// // // // // // // // // // // // // //         fieldIntensity: { value: 1.0, min: 0.1, max: 5, step: 0.1 },\n// // // // // // // // // // // // // //         k_drag: { label: 'Induction Strength', value: 0.5, min: 0, max: 2, step: 0.05 },\n// // // // // // // // // // // // // //         inertiaScale: { label: 'Inertia Scale', value: 1.0, min: 0.1, max: 5, step: 0.1 },\n// // // // // // // // // // // // // //         damping: { value: 0.1, min: 0, max: 1, step: 0.01 },\n// // // // // // // // // // // // // //         k_feedback: { value: -0.2, min: -2, max: 2, step: 0.05 }, });\n// // // // // // // // // // // // // //     const shellParams = useControls('Shell Geometry', { /* ... */\n// // // // // // // // // // // // // //          outerRadius: { value: 1.0, min: 0.5, max: 2.0, step: 0.1 },\n// // // // // // // // // // // // // //          thickness: { value: 0.05, min: 0.01, max: 0.3, step: 0.01 },\n// // // // // // // // // // // // // //          holeBaseDiameter: { value: 0.1, min: 0.01, max: 0.3, step: 0.01 },\n// // // // // // // // // // // // // //          holeRatio: { value: 1.2, min: 1.0, max: 1.6, step: 0.01 },\n// // // // // // // // // // // // // //          noduleRadius: { value: 0.1, min: 0.01, max: 0.3, step: 0.01 }, });\n// // // // // // // // // // // // // //     const vizParams = useControls('Visualization', { /* ... */\n// // // // // // // // // // // // // //         particleCount: { value: 1000, min: 100, max: 5000, step: 100 },\n// // // // // // // // // // // // // //         particleSize: { value: 0.05, min: 0.01, max: 0.2, step: 0.01 },\n// // // // // // // // // // // // // //         torusMajorRadius: { value: 1.5, min: 0.5, max: 5, step: 0.1 },\n// // // // // // // // // // // // // //         torusMinorRadius: { value: 0.5, min: 0.1, max: 2, step: 0.05 }, });\n\n// // // // // // // // // // // // // //     // Explicit type assertion for leva results (Workaround for TS18046 if needed)\n// // // // // // // // // // // // // //     const typedParams = params as any;\n// // // // // // // // // // // // // //     const typedShellParams = shellParams as any;\n// // // // // // // // // // // // // //     const typedVizParams = vizParams as any;\n\n// // // // // // // // // // // // // //     const effectiveInertia = useMemo(() => typedParams.inertiaScale * (typedShellParams.outerRadius ** 5 - (typedShellParams.outerRadius - typedShellParams.thickness) ** 5) / typedShellParams.outerRadius ** 5,\n// // // // // // // // // // // // // //                                  [typedParams.inertiaScale, typedShellParams.outerRadius, typedShellParams.thickness]);\n\n// // // // // // // // // // // // // //     // --- FIX 4: Initialize physicsState ref with correct shape ---\n// // // // // // // // // // // // // //     const physicsState = useRef<PhysicsState>({\n// // // // // // // // // // // // // //         shell_angular_velocity_scalar: 0.0,\n// // // // // // // // // // // // // //         effective_field_velocity_scalar: typedParams.baseFieldSpeed, // Use initial value\n// // // // // // // // // // // // // //         current_torque_scalar: 0.0,\n// // // // // // // // // // // // // //     }); // No .current needed here for initialization\n\n// // // // // // // // // // // // // //     // --- FIX 1 & 3: Ensure particleData useMemo returns object ---\n// // // // // // // // // // // // // //     const particleData = useMemo(() => {\n// // // // // // // // // // // // // //         try { // Add try-catch within useMemo\n// // // // // // // // // // // // // //             const data = [];\n// // // // // // // // // // // // // //             const positions = new Float32Array(typedVizParams.particleCount * 3);\n// // // // // // // // // // // // // //             for (let i = 0; i < typedVizParams.particleCount; i++) {\n// // // // // // // // // // // // // //                 const u = Math.random() * Math.PI * 2; const v = Math.random() * Math.PI * 2;\n// // // // // // // // // // // // // //                 const R = typedVizParams.torusMajorRadius; const r = typedVizParams.torusMinorRadius;\n// // // // // // // // // // // // // //                 const randR = R + (Math.random() - 0.5) * 0.2;\n// // // // // // // // // // // // // //                 const randr = r * Math.sqrt(Math.random());\n// // // // // // // // // // // // // //                 positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u);\n// // // // // // // // // // // // // //                 positions[i * 3 + 1] = randr * Math.sin(v);\n// // // // // // // // // // // // // //                 positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u);\n// // // // // // // // // // // // // //                 data.push({ u, v, R, r: randr, fieldIndex: 0 });\n// // // // // // // // // // // // // //             }\n// // // // // // // // // // // // // //             // Always return the object\n// // // // // // // // // // // // // //             return { positions, data };\n// // // // // // // // // // // // // //         } catch (error) {\n// // // // // // // // // // // // // //             console.error(\"Error creating particle data:\", error);\n// // // // // // // // // // // // // //             // Return a default/empty state if error occurs\n// // // // // // // // // // // // // //             return { positions: new Float32Array(0), data: [] };\n// // // // // // // // // // // // // //         }\n// // // // // // // // // // // // // //      }, [typedVizParams.particleCount, typedVizParams.torusMajorRadius, typedVizParams.torusMinorRadius]); // Use typed params in dep array\n\n\n// // // // // // // // // // // // // //     useFrame((state, delta) => {\n// // // // // // // // // // // // // //         // Access physics state via .current\n// // // // // // // // // // // // // //         const currentPhysics = physicsState.current;\n\n// // // // // // // // // // // // // //         // V1 Physics Placeholder\n// // // // // // // // // // // // // //         const relative_speed = currentPhysics.effective_field_velocity_scalar - currentPhysics.shell_angular_velocity_scalar;\n// // // // // // // // // // // // // //         currentPhysics.current_torque_scalar = typedParams.k_drag * typedParams.fieldIntensity * relative_speed;\n// // // // // // // // // // // // // //         const angular_acceleration = currentPhysics.current_torque_scalar / effectiveInertia;\n// // // // // // // // // // // // // //         currentPhysics.shell_angular_velocity_scalar += angular_acceleration * delta;\n// // // // // // // // // // // // // //         currentPhysics.shell_angular_velocity_scalar *= (1 - typedParams.damping * delta);\n// // // // // // // // // // // // // //         currentPhysics.effective_field_velocity_scalar = typedParams.baseFieldSpeed + typedParams.k_feedback * currentPhysics.shell_angular_velocity_scalar;\n\n// // // // // // // // // // // // // //         // Visuals Update\n// // // // // // // // // // // // // //         if (dodecahedronRef.current) {\n// // // // // // // // // // // // // //              dodecahedronRef.current.rotation.y += currentPhysics.shell_angular_velocity_scalar * delta;\n// // // // // // // // // // // // // //             const material = dodecahedronRef.current.material as THREE.MeshStandardMaterial;\n// // // // // // // // // // // // // //             if (material.emissive) {\n// // // // // // // // // // // // // //                  const maxExpectedTorque = typedParams.k_drag * typedParams.fieldIntensity * (typedParams.baseFieldSpeed * 1.5);\n// // // // // // // // // // // // // //                  const emissionStrength = Math.min(Math.abs(currentPhysics.current_torque_scalar) / (maxExpectedTorque + 0.01), 1.0);\n// // // // // // // // // // // // // //                  material.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5);\n// // // // // // // // // // // // // //             }\n// // // // // // // // // // // // // //         }\n\n// // // // // // // // // // // // // //         // Particle Field Update\n// // // // // // // // // // // // // //         // --- FIX 1: Check if particleData and positions exist ---\n// // // // // // // // // // // // // //         if (particleGeoRef.current && particlesRef.current && particleData && particleData.positions) {\n// // // // // // // // // // // // // //             const positions = particleGeoRef.current.attributes.position.array as Float32Array;\n// // // // // // // // // // // // // //             // Check if buffer size matches expected size before updating\n// // // // // // // // // // // // // //             if (positions.length === typedVizParams.particleCount * 3) {\n// // // // // // // // // // // // // //                 const speed = currentPhysics.effective_field_velocity_scalar * typedParams.fieldIntensity;\n// // // // // // // // // // // // // //                 const pData = particleData.data; // Now safe to access .data\n// // // // // // // // // // // // // //                  (particlesRef.current.material as THREE.PointsMaterial).size = typedVizParams.particleSize * (1 + typedParams.fieldIntensity * 0.5);\n\n// // // // // // // // // // // // // //                 for (let i = 0; i < typedVizParams.particleCount; i++) {\n// // // // // // // // // // // // // //                     const data = pData[i]; data.u += speed * delta;\n// // // // // // // // // // // // // //                     const R = data.R; const r = data.r; const u = data.u; const v = data.v;\n// // // // // // // // // // // // // //                     positions[i * 3] = (R + r * Math.cos(v)) * Math.cos(u);\n// // // // // // // // // // // // // //                     positions[i * 3 + 1] = r * Math.sin(v);\n// // // // // // // // // // // // // //                     positions[i * 3 + 2] = (R + r * Math.cos(v)) * Math.sin(u);\n// // // // // // // // // // // // // //                 }\n// // // // // // // // // // // // // //                 particleGeoRef.current.attributes.position.needsUpdate = true;\n// // // // // // // // // // // // // //             } else if (particleGeoRef.current.attributes.position) {\n// // // // // // // // // // // // // //                  // If size mismatch, likely need to recreate buffer attribute (see below)\n// // // // // // // // // // // // // //                  console.warn(\"Particle buffer size mismatch. Expected:\", typedVizParams.particleCount * 3, \"Got:\", positions.length);\n// // // // // // // // // // // // // //                  // Force recreation by updating the attribute (though this is inefficient)\n// // // // // // // // // // // // // //                  particleGeoRef.current.setAttribute('position', new THREE.BufferAttribute(particleData.positions, 3));\n// // // // // // // // // // // // // //             }\n// // // // // // // // // // // // // //         }\n// // // // // // // // // // // // // //     });\n\n// // // // // // // // // // // // // //     const copperMaterial = useMemo(() => new THREE.MeshStandardMaterial({ /* ... */ color: 0xB87333, metalness: 0.8, roughness: 0.3, emissive: 0x000000, emissiveIntensity: 1.0, side: THREE.DoubleSide }), []);\n\n// // // // // // // // // // // // // //     // --- FIX 1 & 3: Effect to update buffer attribute when particleData changes ---\n// // // // // // // // // // // // // //     // This handles the case where particleCount changes and useMemo returns new arrays\n// // // // // // // // // // // // // //      useEffect(() => {\n// // // // // // // // // // // // // //          if (particleGeoRef.current && particleData && particleData.positions) {\n// // // // // // // // // // // // // //              particleGeoRef.current.setAttribute('position', new THREE.BufferAttribute(particleData.positions, 3));\n// // // // // // // // // // // // // //              console.log(\"Particle buffer attribute updated/created.\");\n// // // // // // // // // // // // // //          }\n// // // // // // // // // // // // // //      }, [particleData]); // Rerun when particleData object reference changes\n\n\n// // // // // // // // // // // // // //     return (\n// // // // // // // // // // // // // //         <>\n// // // // // // // // // // // // // //             {/* --- FIX 7: Pass shellParams props individually --- */}\n// // // // // // // // // // // // // //             <RomanDodecahedron\n// // // // // // // // // // // // // //                 ref={dodecahedronRef}\n// // // // // // // // // // // // // //                 outerRadius={typedShellParams.outerRadius}\n// // // // // // // // // // // // // //                 thickness={typedShellParams.thickness}\n// // // // // // // // // // // // // //                 holeBaseDiameter={typedShellParams.holeBaseDiameter}\n// // // // // // // // // // // // // //                 holeRatio={typedShellParams.holeRatio}\n// // // // // // // // // // // // // //                 noduleRadius={typedShellParams.noduleRadius}\n// // // // // // // // // // // // // //                 material={copperMaterial}\n// // // // // // // // // // // // // //                 castShadow receiveShadow\n// // // // // // // // // // // // // //             />\n\n// // // // // // // // // // // // // //             <points ref={particlesRef}>\n// // // // // // // // // // // // // //                  {/* Ensure geometry ref is set before attribute */}\n// // // // // // // // // // // // // //                  <bufferGeometry ref={particleGeoRef}>\n// // // // // // // // // // // // // //                      {/* --- FIX 1: Conditionally render attribute or use effect ---\n// // // // // // // // // // // // // //                          The useEffect above handles creating/updating the attribute now.\n// // // // // // // // // // // // // //                          We only need the attach=\"attributes-position\" if creating declaratively,\n// // // // // // // // // // // // // //                          which might race with useMemo. Let effect handle it.\n// // // // // // // // // // // // // //                      */}\n// // // // // // // // // // // // // //                      {/* <bufferAttribute attach=\"attributes-position\" ... /> */}\n// // // // // // // // // // // // // //                  </bufferGeometry>\n// // // // // // // // // // // // // //                  <pointsMaterial\n// // // // // // // // // // // // // //                      color={0x00ffff}\n// // // // // // // // // // // // // //                      size={typedVizParams.particleSize} // Use typed param\n// // // // // // // // // // // // // //                      transparent opacity={0.7}\n// // // // // // // // // // // // // //                      blending={THREE.AdditiveBlending} sizeAttenuation\n// // // // // // // // // // // // // //                      map={null}\n// // // // // // // // // // // // // //                  />\n// // // // // // // // // // // // // //             </points>\n// // // // // // // // // // // // // //         </>\n// // // // // // // // // // // // // //     );\n// // // // // // // // // // // // // // };\n\n\n// // // // // // // // // // // // // // // --- Scene Component (Container - unchanged) ---\n// // // // // // // // // // // // // // const TemporalResonatorScene: React.FC = () => { /* ... */ return (<>{/* Leva */}<Canvas>{/* Lights */}<ErrorBoundary><Suspense fallback={<LoadingPlaceholder />}><ResonatorSimulation /></Suspense></ErrorBoundary><Controls /></Canvas></>);};\n// // // // // // // // // // // // // // const LoadingPlaceholder = () => { /* ... */ return (<mesh><boxGeometry args={[0.1, 0.1, 0.1]} /><meshBasicMaterial color=\"orange\" wireframe /></mesh>);};\n\n// // // // // // // // // // // // // // export default TemporalResonatorScene;\n\n\n// // // // // // // // // // // // // // // // TemporalResonatorScene_V2_CSG_Fixed.tsx\n// // // // // // // // // // // // // // // import React, { useRef, useEffect, useMemo, Suspense } from 'react'; // Import Suspense\n// // // // // // // // // // // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // // // // // // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // // // // // // // // // // // import * as THREE from 'three';\n// // // // // // // // // // // // // // // import ErrorBoundary from './errorBoundary'; // Assuming path is correct\n// // // // // // // // // // // // // // // import { useControls, Leva } from 'leva';\n// // // // // // // // // // // // // // // import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg';\n\n// // // // // // // // // // // // // // // // --- FIX 1: Explicitly import and assign BVH functions ---\n// // // // // // // // // // // // // // // import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\n// // // // // // // // // // // // // // // THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\n// // // // // // // // // // // // // // // THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\n// // // // // // // // // // // // // // // THREE.Mesh.prototype.raycast = acceleratedRaycast; // Also recommended for performance\n\n// // // // // // // // // // // // // // // const csgEvaluator = new Evaluator();\n// // // // // // // // // // // // // // // csgEvaluator.useGroups = true;\n\n// // // // // // // // // // // // // // // extend({ OrbitControls });\n\n// // // // // // // // // // // // // // // // --- Controls Component (Unchanged) ---\n// // // // // // // // // // // // // // // const Controls = () => {\n// // // // // // // // // // // // // // //     const { camera, gl } = useThree();\n// // // // // // // // // // // // // // //     const controlsRef = useRef<OrbitControls>(null);\n\n// // // // // // // // // // // // // // //     useEffect(() => {\n// // // // // // // // // // // // // // //       const controls = new OrbitControls(camera, gl.domElement);\n// // // // // // // // // // // // // // //       controls.enableDamping = true;\n// // // // // // // // // // // // // // //       (controlsRef as React.MutableRefObject<OrbitControls>).current = controls;\n\n// // // // // // // // // // // // // // //       return () => {\n// // // // // // // // // // // // // // //         controls.dispose();\n// // // // // // // // // // // // // // //       };\n// // // // // // // // // // // // // // //     }, [camera, gl]);\n\n// // // // // // // // // // // // // // //     useFrame(() => {\n// // // // // // // // // // // // // // //       controlsRef.current?.update();\n// // // // // // // // // // // // // // //     });\n\n// // // // // // // // // // // // // // //     return null;\n// // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // --- Roman Dodecahedron CSG Component ---\n// // // // // // // // // // // // // // // interface RomanDodecahedronProps {\n// // // // // // // // // // // // // // //   outerRadius: number;\n// // // // // // // // // // // // // // //   thickness: number;\n// // // // // // // // // // // // // // //   holeBaseDiameter: number;\n// // // // // // // // // // // // // // //   holeRatio: number;\n// // // // // // // // // // // // // // //   noduleRadius: number;\n// // // // // // // // // // // // // // //   material: THREE.Material;\n// // // // // // // // // // // // // // //   [key: string]: any; // Allow other mesh props like position, rotation etc.\n// // // // // // // // // // // // // // // }\n\n// // // // // // // // // // // // // // // const RomanDodecahedron: React.FC<RomanDodecahedronProps> = React.forwardRef<THREE.Mesh, RomanDodecahedronProps>(\n// // // // // // // // // // // // // // //     ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, ...props }, ref) => {\n\n// // // // // // // // // // // // // // //     const geometry = useMemo(() => {\n// // // // // // // // // // // // // // //         console.log(\"Recalculating CSG Geometry...\");\n\n// // // // // // // // // // // // // // //         // 1. Base Shell Brushes\n// // // // // // // // // // // // // // //         // Use slightly higher detail maybe? 1->2 for smoother holes? Test performance.\n// // // // // // // // // // // // // // //         const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, 1);\n// // // // // // // // // // // // // // //         outerDodecGeo.computeBoundsTree(); // Now this should exist\n// // // // // // // // // // // // // // //         const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, 1);\n// // // // // // // // // // // // // // //         innerDodecGeo.computeBoundsTree();\n\n// // // // // // // // // // // // // // //         let outerBrush = new Brush(outerDodecGeo);\n// // // // // // // // // // // // // // //         let innerBrush = new Brush(innerDodecGeo);\n// // // // // // // // // // // // // // //         innerBrush.updateMatrixWorld();\n\n// // // // // // // // // // // // // // //         // Create Shell\n// // // // // // // // // // // // // // //         let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n// // // // // // // // // // // // // // //         outerBrush.geometry.dispose(); // Dispose intermediate geometries\n// // // // // // // // // // // // // // //         innerBrush.geometry.dispose();\n\n// // // // // // // // // // // // // // //         // 2. Holes (Cylinders)\n// // // // // // // // // // // // // // //         const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * (holeRatio ** i));\n// // // // // // // // // // // // // // //         const cylinderHeight = thickness * 3; // Ensure it goes through\n// // // // // // // // // // // // // // //         // Create ONE cylinder geometry, reuse it\n// // // // // // // // // // // // // // //         const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16);\n// // // // // // // // // // // // // // //         cylinderGeo.rotateX(Math.PI / 2); // Align along Z\n// // // // // // // // // // // // // // //         cylinderGeo.computeBoundsTree(); // Compute BVH once\n\n// // // // // // // // // // // // // // //         const tempMatrix = new THREE.Matrix4();\n// // // // // // // // // // // // // // //         const tempPos = new THREE.Vector3();\n// // // // // // // // // // // // // // //         const tempQuat = new THREE.Quaternion();\n\n// // // // // // // // // // // // // // //         const vertices = outerDodecGeo.attributes.position.array;\n// // // // // // // // // // // // // // //         const indices = outerDodecGeo.index ? outerDodecGeo.index.array : null; // Null check\n// // // // // // // // // // // // // // //         let faceIndex = 0;\n\n// // // // // // // // // // // // // // //         if (!indices) {\n// // // // // // // // // // // // // // //             console.error(\"Dodecahedron geometry lacks indices!\");\n// // // // // // // // // // // // // // //             // Dispose temporary geometry before returning empty\n// // // // // // // // // // // // // // //             cylinderGeo.dispose();\n// // // // // // // // // // // // // // //             return new THREE.BufferGeometry();\n// // // // // // // // // // // // // // //         }\n\n// // // // // // // // // // // // // // //         try { // Add try-catch around CSG operations\n// // // // // // // // // // // // // // //             for (let i = 0; i < indices.length; i += 9) { // Step by 9 indices (3 triangles per pent face)\n// // // // // // // // // // // // // // //                 if (faceIndex >= 12) break;\n\n// // // // // // // // // // // // // // //                 const vIndices = new Set<number>();\n// // // // // // // // // // // // // // //                 for(let j=0; j<9; j++){\n// // // // // // // // // // // // // // //                     vIndices.add(indices[i+j]);\n// // // // // // // // // // // // // // //                 }\n\n// // // // // // // // // // // // // // //                 const center = new THREE.Vector3(0,0,0);\n// // // // // // // // // // // // // // //                 let vertexCount = 0;\n// // // // // // // // // // // // // // //                 vIndices.forEach((idx) => {\n// // // // // // // // // // // // // // //                     if (idx * 3 + 2 < vertices.length) {\n// // // // // // // // // // // // // // //                         tempPos.set(vertices[idx * 3], vertices[idx * 3 + 1], vertices[idx * 3 + 2]);\n// // // // // // // // // // // // // // //                         center.add(tempPos);\n// // // // // // // // // // // // // // //                         vertexCount++;\n// // // // // // // // // // // // // // //                     } else {\n// // // // // // // // // // // // // // //                         console.warn(`Index ${idx} out of bounds for vertices array.`);\n// // // // // // // // // // // // // // //                     }\n// // // // // // // // // // // // // // //                 });\n\n// // // // // // // // // // // // // // //                 if (vertexCount === 0) {\n// // // // // // // // // // // // // // //                      console.warn(`No valid vertices found for face index ${faceIndex}`);\n// // // // // // // // // // // // // // //                      faceIndex++; // Increment even if skipped\n// // // // // // // // // // // // // // //                      continue; // Skip this face\n// // // // // // // // // // // // // // //                 }\n// // // // // // // // // // // // // // //                 center.divideScalar(vertexCount);\n\n// // // // // // // // // // // // // // //                 const normal = center.clone().normalize();\n// // // // // // // // // // // // // // //                 const holeRadius = holeDiameters[faceIndex] / 2;\n\n// // // // // // // // // // // // // // //                 // Check if hole radius is valid\n// // // // // // // // // // // // // // //                 if (!holeRadius || holeRadius <= 0) {\n// // // // // // // // // // // // // // //                     console.warn(`Invalid hole radius calculated for face ${faceIndex}: ${holeRadius}`);\n// // // // // // // // // // // // // // //                     faceIndex++;\n// // // // // // // // // // // // // // //                     continue;\n// // // // // // // // // // // // // // //                 }\n\n// // // // // // // // // // // // // // //                 const holeBrush = new Brush(cylinderGeo); // Reuse geometry\n// // // // // // // // // // // // // // //                 holeBrush.scale.set(holeRadius, holeRadius, 1);\n// // // // // // // // // // // // // // //                 tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), normal);\n// // // // // // // // // // // // // // //                 holeBrush.quaternion.copy(tempQuat);\n// // // // // // // // // // // // // // //                 holeBrush.position.copy(center);\n// // // // // // // // // // // // // // //                 holeBrush.updateMatrixWorld();\n\n// // // // // // // // // // // // // // //                 // Subtract hole\n// // // // // // // // // // // // // // //                 shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION);\n// // // // // // // // // // // // // // //                 faceIndex++;\n// // // // // // // // // // // // // // //             }\n\n// // // // // // // // // // // // // // //             // Dispose the template cylinder geometry (brushes hold references)\n// // // // // // // // // // // // // // //             cylinderGeo.dispose();\n\n// // // // // // // // // // // // // // //             // 3. Nodules (Spheres)\n// // // // // // // // // // // // // // //             // Lower detail nodules\n// // // // // // // // // // // // // // //             const noduleGeo = new THREE.SphereGeometry(noduleRadius, 6, 6);\n// // // // // // // // // // // // // // //             noduleGeo.computeBoundsTree();\n// // // // // // // // // // // // // // //             const uniqueVertices = new Map<string, THREE.Vector3>();\n\n// // // // // // // // // // // // // // //             // Use outerDodecGeo vertices directly\n// // // // // // // // // // // // // // //              for (let i = 0; i < outerDodecGeo.attributes.position.count; i++) {\n// // // // // // // // // // // // // // //                  tempPos.fromBufferAttribute(outerDodecGeo.attributes.position, i);\n// // // // // // // // // // // // // // //                  const key = `${tempPos.x.toFixed(4)},${tempPos.y.toFixed(4)},${tempPos.z.toFixed(4)}`;\n// // // // // // // // // // // // // // //                  if (!uniqueVertices.has(key)) {\n// // // // // // // // // // // // // // //                      uniqueVertices.set(key, tempPos.clone());\n// // // // // // // // // // // // // // //                  }\n// // // // // // // // // // // // // // //              }\n\n\n// // // // // // // // // // // // // // //             uniqueVertices.forEach(vertexPos => {\n// // // // // // // // // // // // // // //                 const noduleBrush = new Brush(noduleGeo);\n// // // // // // // // // // // // // // //                 noduleBrush.position.copy(vertexPos);\n// // // // // // // // // // // // // // //                 noduleBrush.updateMatrixWorld();\n// // // // // // // // // // // // // // //                 shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION);\n// // // // // // // // // // // // // // //             });\n\n// // // // // // // // // // // // // // //              // Dispose the template nodule geometry\n// // // // // // // // // // // // // // //              noduleGeo.dispose();\n\n\n// // // // // // // // // // // // // // //             // --- FIX 3: Get geometry directly from the final brush ---\n// // // // // // // // // // // // // // //             const finalGeometry = shellBrush.geometry;\n// // // // // // // // // // // // // // //             finalGeometry.computeVertexNormals(); // Recalculate normals\n// // // // // // // // // // // // // // //             // Clean up the original outer geometry used for vertices/indices\n// // // // // // // // // // // // // // //             outerDodecGeo.dispose();\n\n// // // // // // // // // // // // // // //             console.log(\"CSG Geometry Recalculation Complete.\");\n// // // // // // // // // // // // // // //             return finalGeometry;\n\n// // // // // // // // // // // // // // //         } catch (error) {\n// // // // // // // // // // // // // // //             console.error(\"Error during CSG evaluation:\", error);\n// // // // // // // // // // // // // // //             // Dispose geometries if error occurs\n// // // // // // // // // // // // // // //             cylinderGeo?.dispose();\n// // // // // // // // // // // // // // //             outerDodecGeo?.dispose();\n// // // // // // // // // // // // // // //             innerDodecGeo?.dispose();\n// // // // // // // // // // // // // // //             // noduleGeo?.dispose(); // Might already be disposed\n// // // // // // // // // // // // // // //             return new THREE.BufferGeometry(); // Return empty on error\n// // // // // // // // // // // // // // //         }\n\n// // // // // // // // // // // // // // //     }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]);\n\n// // // // // // // // // // // // // // //     // Need to dispose of the geometry when the component unmounts or params change\n// // // // // // // // // // // // // // //     useEffect(() => {\n// // // // // // // // // // // // // // //         return () => {\n// // // // // // // // // // // // // // //             // Check if geometry is a BufferGeometry and has a dispose method\n// // // // // // // // // // // // // // //             if (geometry && typeof (geometry as THREE.BufferGeometry).dispose === 'function') {\n// // // // // // // // // // // // // // //                 (geometry as THREE.BufferGeometry).dispose();\n// // // // // // // // // // // // // // //                 console.log(\"Disposed CSG geometry\");\n// // // // // // // // // // // // // // //             }\n// // // // // // // // // // // // // // //         };\n// // // // // // // // // // // // // // //     }, [geometry]); // Run effect when geometry changes (which happens on param change)\n\n\n// // // // // // // // // // // // // // //     return <mesh ref={ref} geometry={geometry} material={material} {...props} />;\n// // // // // // // // // // // // // // // });\n\n\n// // // // // // // // // // // // // // // // --- Main Simulation Component (Minor adjustments) ---\n// // // // // // // // // // // // // // // const ResonatorSimulation = () => {\n// // // // // // // // // // // // // // //     const dodecahedronRef = useRef<THREE.Mesh>(null!);\n// // // // // // // // // // // // // // //     const particlesRef = useRef<THREE.Points>(null!);\n// // // // // // // // // // // // // // //     const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // // // // // // // // // // // // // //     const params = useControls('Resonator Controls', { /* ... as before ... */\n// // // // // // // // // // // // // // //         baseFieldSpeed: { value: 1.0, min: -5, max: 5, step: 0.1 },\n// // // // // // // // // // // // // // //         fieldIntensity: { value: 1.0, min: 0.1, max: 5, step: 0.1 },\n// // // // // // // // // // // // // // //         k_drag: { label: 'Induction Strength', value: 0.5, min: 0, max: 2, step: 0.05 },\n// // // // // // // // // // // // // // //         inertiaScale: { label: 'Inertia Scale', value: 1.0, min: 0.1, max: 5, step: 0.1 },\n// // // // // // // // // // // // // // //         damping: { value: 0.1, min: 0, max: 1, step: 0.01 },\n// // // // // // // // // // // // // // //         k_feedback: { value: -0.2, min: -2, max: 2, step: 0.05 }, });\n// // // // // // // // // // // // // // //     const shellParams = useControls('Shell Geometry', { /* ... as before ... */\n// // // // // // // // // // // // // // //          outerRadius: { value: 1.0, min: 0.5, max: 2.0, step: 0.1, /* editable: false */ }, // Allow editing if desired\n// // // // // // // // // // // // // // //          thickness: { value: 0.05, min: 0.01, max: 0.3, step: 0.01 },\n// // // // // // // // // // // // // // //          holeBaseDiameter: { value: 0.1, min: 0.01, max: 0.3, step: 0.01 },\n// // // // // // // // // // // // // // //          holeRatio: { value: 1.2, min: 1.0, max: 1.6, step: 0.01 },\n// // // // // // // // // // // // // // //          noduleRadius: { value: 0.1, min: 0.01, max: 0.3, step: 0.01 }, });\n// // // // // // // // // // // // // // //     const vizParams = useControls('Visualization', { /* ... as before ... */\n// // // // // // // // // // // // // // //         particleCount: { value: 1000, min: 100, max: 5000, step: 100 },\n// // // // // // // // // // // // // // //         particleSize: { value: 0.05, min: 0.01, max: 0.2, step: 0.01 },\n// // // // // // // // // // // // // // //         torusMajorRadius: { value: 1.5, min: 0.5, max: 5, step: 0.1 },\n// // // // // // // // // // // // // // //         torusMinorRadius: { value: 0.5, min: 0.1, max: 2, step: 0.05 }, });\n\n// // // // // // // // // // // // // // //     const effectiveInertia = useMemo(() => params.inertiaScale * (shellParams.outerRadius ** 5 - (shellParams.outerRadius - shellParams.thickness) ** 5) / shellParams.outerRadius ** 5,\n// // // // // // // // // // // // // // //                                  [params.inertiaScale, shellParams.outerRadius, shellParams.thickness]);\n\n// // // // // // // // // // // // // // //     const physicsState = useRef({ shell_angular_velocity_scalar: 0.0, effective_field_velocity_scalar: params.baseFieldSpeed, current_torque_scalar: 0.0, }).current;\n\n// // // // // // // // // // // // // // //     const particleData = useMemo(() => { /* ... as before ... */\n// // // // // // // // // // // // // // //         const data = [];\n// // // // // // // // // // // // // // //         const positions = new Float32Array(vizParams.particleCount * 3);\n// // // // // // // // // // // // // // //         for (let i = 0; i < vizParams.particleCount; i++) {\n// // // // // // // // // // // // // // //             const u = Math.random() * Math.PI * 2; const v = Math.random() * Math.PI * 2;\n// // // // // // // // // // // // // // //             const R = vizParams.torusMajorRadius; const r = vizParams.torusMinorRadius;\n// // // // // // // // // // // // // // //             const randR = R + (Math.random() - 0.5) * 0.2;\n// // // // // // // // // // // // // // //             const randr = r * Math.sqrt(Math.random());\n// // // // // // // // // // // // // // //             positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u);\n// // // // // // // // // // // // // // //             positions[i * 3 + 1] = randr * Math.sin(v);\n// // // // // // // // // // // // // // //             positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u);\n// // // // // // // // // // // // // // //             data.push({ u, v, R, r: randr, fieldIndex: 0 });\n// // // // // // // // // // // // // // //         }\n// // // // // // // // // // // // // // //         return { positions, data };\n// // // // // // // // // // // // // // //      }, [vizParams.particleCount, vizParams.torusMajorRadius, vizParams.torusMinorRadius]);\n\n\n// // // // // // // // // // // // // // //     useFrame((state, delta) => {\n// // // // // // // // // // // // // // //         // V1 Physics Placeholder\n// // // // // // // // // // // // // // //         const relative_speed = physicsState.effective_field_velocity_scalar - physicsState.shell_angular_velocity_scalar;\n// // // // // // // // // // // // // // //         physicsState.current_torque_scalar = params.k_drag * params.fieldIntensity * relative_speed;\n// // // // // // // // // // // // // // //         const angular_acceleration = physicsState.current_torque_scalar / effectiveInertia;\n// // // // // // // // // // // // // // //         physicsState.shell_angular_velocity_scalar += angular_acceleration * delta;\n// // // // // // // // // // // // // // //         physicsState.shell_angular_velocity_scalar *= (1 - params.damping * delta);\n// // // // // // // // // // // // // // //         physicsState.effective_field_velocity_scalar = params.baseFieldSpeed + params.k_feedback * physicsState.shell_angular_velocity_scalar;\n\n// // // // // // // // // // // // // // //         // Visuals Update\n// // // // // // // // // // // // // // //         if (dodecahedronRef.current) {\n// // // // // // // // // // // // // // //              dodecahedronRef.current.rotation.y += physicsState.shell_angular_velocity_scalar * delta;\n// // // // // // // // // // // // // // //             const material = dodecahedronRef.current.material as THREE.MeshStandardMaterial;\n// // // // // // // // // // // // // // //             if (material.emissive) { // Check if emissive exists\n// // // // // // // // // // // // // // //                  const maxExpectedTorque = params.k_drag * params.fieldIntensity * (params.baseFieldSpeed * 1.5);\n// // // // // // // // // // // // // // //                  const emissionStrength = Math.min(Math.abs(physicsState.current_torque_scalar) / (maxExpectedTorque + 0.01), 1.0);\n// // // // // // // // // // // // // // //                  material.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5);\n// // // // // // // // // // // // // // //             }\n// // // // // // // // // // // // // // //         }\n\n// // // // // // // // // // // // // // //         // Particle Field Update Placeholder\n// // // // // // // // // // // // // // //         if (particleGeoRef.current && particlesRef.current) {\n// // // // // // // // // // // // // // //             const positions = particleGeoRef.current.attributes.position.array as Float32Array;\n// // // // // // // // // // // // // // //             const speed = physicsState.effective_field_velocity_scalar * params.fieldIntensity;\n// // // // // // // // // // // // // // //             const pData = particleData.data;\n// // // // // // // // // // // // // // //              (particlesRef.current.material as THREE.PointsMaterial).size = vizParams.particleSize * (1 + params.fieldIntensity * 0.5);\n\n// // // // // // // // // // // // // // //             for (let i = 0; i < vizParams.particleCount; i++) {\n// // // // // // // // // // // // // // //                 const data = pData[i]; data.u += speed * delta;\n// // // // // // // // // // // // // // //                 const R = data.R; const r = data.r; const u = data.u; const v = data.v;\n// // // // // // // // // // // // // // //                 positions[i * 3] = (R + r * Math.cos(v)) * Math.cos(u);\n// // // // // // // // // // // // // // //                 positions[i * 3 + 1] = r * Math.sin(v);\n// // // // // // // // // // // // // // //                 positions[i * 3 + 2] = (R + r * Math.cos(v)) * Math.sin(u);\n// // // // // // // // // // // // // // //             }\n// // // // // // // // // // // // // // //             particleGeoRef.current.attributes.position.needsUpdate = true;\n// // // // // // // // // // // // // // //         }\n// // // // // // // // // // // // // // //     });\n\n// // // // // // // // // // // // // // //     const copperMaterial = useMemo(() => new THREE.MeshStandardMaterial({\n// // // // // // // // // // // // // // //             color: 0xB87333, metalness: 0.8, roughness: 0.3,\n// // // // // // // // // // // // // // //             emissive: 0x000000, emissiveIntensity: 1.0,\n// // // // // // // // // // // // // // //             side: THREE.DoubleSide\n// // // // // // // // // // // // // // //         }), []);\n\n// // // // // // // // // // // // // // //     return (\n// // // // // // // // // // // // // // //         <>\n// // // // // // // // // // // // // // //             {/* Use forwardRef for the CSG Component */}\n// // // // // // // // // // // // // // //             <RomanDodecahedron\n// // // // // // // // // // // // // // //                 ref={dodecahedronRef} // Apply the ref here\n// // // // // // // // // // // // // // //                 outerRadius={shellParams.outerRadius}\n// // // // // // // // // // // // // // //                 thickness={shellParams.thickness}\n// // // // // // // // // // // // // // //                 holeBaseDiameter={shellParams.holeBaseDiameter}\n// // // // // // // // // // // // // // //                 holeRatio={shellParams.holeRatio}\n// // // // // // // // // // // // // // //                 noduleRadius={shellParams.noduleRadius}\n// // // // // // // // // // // // // // //                 material={copperMaterial}\n// // // // // // // // // // // // // // //                 castShadow // Allow the detailed mesh to cast shadows\n// // // // // // // // // // // // // // //                 receiveShadow // Allow it to receive shadows\n// // // // // // // // // // // // // // //             />\n\n// // // // // // // // // // // // // // //             {/* Particle Field */}\n// // // // // // // // // // // // // // //             <points ref={particlesRef}>\n// // // // // // // // // // // // // // //                  <bufferGeometry ref={particleGeoRef}>\n// // // // // // // // // // // // // // //                      <bufferAttribute\n// // // // // // // // // // // // // // //                          attach=\"attributes-position\"\n// // // // // // // // // // // // // // //                          count={vizParams.particleCount}\n// // // // // // // // // // // // // // //                          array={particleData.positions}\n// // // // // // // // // // // // // // //                          itemSize={3}\n// // // // // // // // // // // // // // //                          usage={THREE.DynamicDrawUsage} // Hint for frequent updates\n// // // // // // // // // // // // // // //                      />\n// // // // // // // // // // // // // // //                  </bufferGeometry>\n// // // // // // // // // // // // // // //                  <pointsMaterial\n// // // // // // // // // // // // // // //                      color={0x00ffff}\n// // // // // // // // // // // // // // //                      size={vizParams.particleSize}\n// // // // // // // // // // // // // // //                      transparent opacity={0.7}\n// // // // // // // // // // // // // // //                      blending={THREE.AdditiveBlending} sizeAttenuation\n// // // // // // // // // // // // // // //                  />\n// // // // // // // // // // // // // // //             </points>\n// // // // // // // // // // // // // // //         </>\n// // // // // // // // // // // // // // //     );\n// // // // // // // // // // // // // // // };\n\n\n// // // // // // // // // // // // // // // // --- Scene Component (Container) ---\n// // // // // // // // // // // // // // // const TemporalResonatorScene: React.FC = () => (\n// // // // // // // // // // // // // // //     <>\n// // // // // // // // // // // // // // //         <Leva collapsed={false} titleBar={{ title: 'Controls' }} />\n// // // // // // // // // // // // // // //         <Canvas\n// // // // // // // // // // // // // // //              style={{ position: 'absolute', top: 0, left: 0, width: '100vw', height: '100vh', background: '#111122', zIndex: 0 }}\n// // // // // // // // // // // // // // //              camera={{ position: [3, 3, 5], fov: 75 }}\n// // // // // // // // // // // // // // //              gl={{ antialias: true, /* alpha: false */ }} // Consider alpha false if no transparency needed behind canvas\n// // // // // // // // // // // // // // //              shadows\n// // // // // // // // // // // // // // //         >\n// // // // // // // // // // // // // // //              <ambientLight intensity={0.4} />\n// // // // // // // // // // // // // // //              <directionalLight\n// // // // // // // // // // // // // // //                  position={[5, 10, 7.5]}\n// // // // // // // // // // // // // // //                  intensity={1.0}\n// // // // // // // // // // // // // // //                  castShadow\n// // // // // // // // // // // // // // //                  shadow-mapSize-width={1024} shadow-mapSize-height={1024}\n// // // // // // // // // // // // // // //                  shadow-camera-far={25} // Adjust shadow camera if needed\n// // // // // // // // // // // // // // //                  shadow-camera-left={-10} shadow-camera-right={10}\n// // // // // // // // // // // // // // //                  shadow-camera-top={10} shadow-camera-bottom={-10}\n// // // // // // // // // // // // // // //              />\n// // // // // // // // // // // // // // //              <ErrorBoundary>\n// // // // // // // // // // // // // // //                  {/* Use Suspense directly around the component causing potential long calculation */}\n// // // // // // // // // // // // // // //                  <Suspense fallback={<LoadingPlaceholder />}>\n// // // // // // // // // // // // // // //                       <ResonatorSimulation />\n// // // // // // // // // // // // // // //                  </Suspense>\n// // // // // // // // // // // // // // //              </ErrorBoundary>\n// // // // // // // // // // // // // // //              <Controls />\n// // // // // // // // // // // // // // //         </Canvas>\n// // // // // // // // // // // // // // //     </>\n// // // // // // // // // // // // // // // );\n\n// // // // // // // // // // // // // // // // Simple placeholder for Suspense\n// // // // // // // // // // // // // // // const LoadingPlaceholder = () => {\n// // // // // // // // // // // // // // //     return (\n// // // // // // // // // // // // // // //         <mesh>\n// // // // // // // // // // // // // // //             <boxGeometry args={[0.1, 0.1, 0.1]} />\n// // // // // // // // // // // // // // //             <meshBasicMaterial color=\"orange\" wireframe />\n// // // // // // // // // // // // // // //         </mesh>\n// // // // // // // // // // // // // // //     );\n// // // // // // // // // // // // // // // };\n\n\n// // // // // // // // // // // // // // // export default TemporalResonatorScene;\n\n\n// // // // // // // // // // // // // // // // // TemporalResonatorScene_V2_CSG.tsx\n// // // // // // // // // // // // // // // // import React, { useRef, useEffect, useMemo } from 'react';\n// // // // // // // // // // // // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // // // // // // // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // // // // // // // // // // // // import * as THREE from 'three';\n\n// // // // // // // // // // // // // // // // import { useControls, Leva } from 'leva';\n// // // // // // // // // // // // // // // // import { Brush, Evaluator, SUBTRACTION, ADDITION } from 'three-bvh-csg'; // Import CSG\n// // // // // // // // // // // // // // // // import { MeshBVH } from 'three-mesh-bvh'; // Need BVH compute function\n// // // // // // // // // // // // // // // // import ErrorBoundary from './errorBoundary';\n\n// // // // // // // // // // // // // // // // // Required setup for three-bvh-csg (as per its docs)\n// // // // // // // // // // // // // // // // (THREE.BufferGeometry.prototype as any).computeBoundsTree = (MeshBVH as any).computeBoundsTree;\n// // // // // // // // // // // // // // // // (THREE.BufferGeometry.prototype as any).disposeBoundsTree = (MeshBVH as any).disposeBoundsTree;\n// // // // // // // // // // // // // // // // const csgEvaluator = new Evaluator();\n// // // // // // // // // // // // // // // // csgEvaluator.useGroups = true; // Important for multiple subtractions/additions\n\n// // // // // // // // // // // // // // // // extend({ OrbitControls });\n\n// // // // // // // // // // // // // // // // // --- Controls Component (Unchanged) ---\n// // // // // // // // // // // // // // // // const Controls = () => {\n// // // // // // // // // // // // // // // //      // ... (same as before)\n// // // // // // // // // // // // // // // //      const { camera, gl } = useThree();\n// // // // // // // // // // // // // // // //      const controlsRef = useRef<OrbitControls>(null); // Use OrbitControls type\n\n// // // // // // // // // // // // // // // //      useEffect(() => {\n// // // // // // // // // // // // // // // //        const controls = new OrbitControls(camera, gl.domElement);\n// // // // // // // // // // // // // // // //        controls.enableDamping = true;\n// // // // // // // // // // // // // // // //        (controlsRef as React.MutableRefObject<OrbitControls>).current = controls; // Assign to ref\n\n// // // // // // // // // // // // // // // //        return () => {\n// // // // // // // // // // // // // // // //          controls.dispose();\n// // // // // // // // // // // // // // // //        };\n// // // // // // // // // // // // // // // //      }, [camera, gl]);\n\n// // // // // // // // // // // // // // // //      useFrame(() => {\n// // // // // // // // // // // // // // // //        controlsRef.current?.update(); // Safely call update if controls exist\n// // // // // // // // // // // // // // // //      });\n\n// // // // // // // // // // // // // // // //      return null;\n// // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // --- Roman Dodecahedron CSG Component ---\n// // // // // // // // // // // // // // // // interface RomanDodecahedronProps {\n// // // // // // // // // // // // // // // //   outerRadius: number;\n// // // // // // // // // // // // // // // //   thickness: number;\n// // // // // // // // // // // // // // // //   holeBaseDiameter: number;\n// // // // // // // // // // // // // // // //   holeRatio: number;\n// // // // // // // // // // // // // // // //   noduleRadius: number;\n// // // // // // // // // // // // // // // //   material: THREE.Material;\n// // // // // // // // // // // // // // // //   [key: string]: any;\n// // // // // // // // // // // // // // // // }\n\n// // // // // // // // // // // // // // // // const RomanDodecahedron: React.FC<RomanDodecahedronProps> = ({ outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius, material, ...props }) => {\n\n// // // // // // // // // // // // // // // //     const geometry = useMemo(() => {\n// // // // // // // // // // // // // // // //         console.log(\"Recalculating CSG Geometry...\"); // Debug log\n\n// // // // // // // // // // // // // // // //         // 1. Base Shell Brushes\n// // // // // // // // // // // // // // // //         const outerDodecGeo = new THREE.DodecahedronGeometry(outerRadius, 1); // Detail 1 might be enough\n// // // // // // // // // // // // // // // //         outerDodecGeo.computeBoundsTree(); // Compute BVH for CSG base\n// // // // // // // // // // // // // // // //         const innerDodecGeo = new THREE.DodecahedronGeometry(outerRadius - thickness, 1);\n// // // // // // // // // // // // // // // //         innerDodecGeo.computeBoundsTree();\n\n// // // // // // // // // // // // // // // //         const outerBrush = new Brush(outerDodecGeo);\n// // // // // // // // // // // // // // // //         const innerBrush = new Brush(innerDodecGeo);\n// // // // // // // // // // // // // // // //         innerBrush.updateMatrixWorld(); // Ensure matrix is updated\n\n// // // // // // // // // // // // // // // //         // Create Shell\n// // // // // // // // // // // // // // // //         let shellBrush = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);\n\n// // // // // // // // // // // // // // // //         // 2. Holes (Cylinders)\n// // // // // // // // // // // // // // // //         const holeDiameters = Array.from({ length: 12 }, (_, i) => holeBaseDiameter * (holeRatio ** i));\n// // // // // // // // // // // // // // // //         // Create ONE cylinder geometry, reuse it for brushes\n// // // // // // // // // // // // // // // //         const cylinderHeight = thickness * 3; // Ensure it goes through the shell\n// // // // // // // // // // // // // // // //         const cylinderGeo = new THREE.CylinderGeometry(1, 1, cylinderHeight, 16); // Base radius 1\n// // // // // // // // // // // // // // // //         cylinderGeo.rotateX(Math.PI / 2); // Align along Z-axis\n// // // // // // // // // // // // // // // //         cylinderGeo.computeBoundsTree(); // Compute BVH once for the geometry\n\n// // // // // // // // // // // // // // // //         const tempMatrix = new THREE.Matrix4();\n// // // // // // // // // // // // // // // //         const tempPos = new THREE.Vector3();\n// // // // // // // // // // // // // // // //         const tempQuat = new THREE.Quaternion();\n// // // // // // // // // // // // // // // //         const up = new THREE.Vector3(0, 1, 0);\n\n// // // // // // // // // // // // // // // //         // Iterate through faces to get centers and normals (for DodecahedronGeometry)\n// // // // // // // // // // // // // // // //         // Vertices are ordered per face: 0,1,2,3,4 / 0,5,6,7,1 / 1,7,8,9,2 / ...\n// // // // // // // // // // // // // // // //         const vertices = outerDodecGeo.attributes.position.array;\n// // // // // // // // // // // // // // // //         const indices = outerDodecGeo.index ? outerDodecGeo.index.array : [];\n// // // // // // // // // // // // // // // //         let faceIndex = 0;\n\n// // // // // // // // // // // // // // // //         if (!indices) {\n// // // // // // // // // // // // // // // //             console.error(\"Dodecahedron geometry lacks indices for face processing!\");\n// // // // // // // // // // // // // // // //             return new THREE.BufferGeometry(); // Return empty on error\n// // // // // // // // // // // // // // // //         }\n\n// // // // // // // // // // // // // // // //         // Dodecahedron has 12 faces, 3 triangles per pentagonal face = 36 triangles\n// // // // // // // // // // // // // // // //         // Process 12 pentagonal faces\n// // // // // // // // // // // // // // // //         for (let i = 0; i < indices.length; i += 3 * 3) { // Step by 9 indices (3 triangles per pent face)\n// // // // // // // // // // // // // // // //              if (faceIndex >= 12) break; // Should not happen, but safety\n\n// // // // // // // // // // // // // // // //             const faceVertices = [];\n// // // // // // // // // // // // // // // //             // Get the 5 unique vertices for this pentagonal face\n// // // // // // // // // // // // // // // //             const vIndices = new Set();\n// // // // // // // // // // // // // // // //             for(let j=0; j<9; j++){ // Indices for the 3 triangles making the pentagon\n// // // // // // // // // // // // // // // //                  vIndices.add(indices[i+j]);\n// // // // // // // // // // // // // // // //             }\n// // // // // // // // // // // // // // // //             if (vIndices.size !== 5) {\n// // // // // // // // // // // // // // // //                  console.warn(\"Unexpected vertex count for face\", faceIndex, vIndices.size);\n// // // // // // // // // // // // // // // //                  // Simple fallback: use first vertex index? This is inaccurate.\n// // // // // // // // // // // // // // // //                  // Better: Calculate center from the 3 triangles' centers?\n// // // // // // // // // // // // // // // //                  // For now, we'll likely get misaligned holes if this happens.\n// // // // // // // // // // // // // // // //             }\n\n// // // // // // // // // // // // // // // //             const center = new THREE.Vector3(0,0,0);\n// // // // // // // // // // // // // // // //             vIndices.forEach((idx:any) => {\n// // // // // // // // // // // // // // // //                  tempPos.set(vertices[idx * 3], vertices[idx * 3 + 1], vertices[idx * 3 + 2]);\n// // // // // // // // // // // // // // // //                  faceVertices.push(tempPos.clone());\n// // // // // // // // // // // // // // // //                  center.add(tempPos);\n// // // // // // // // // // // // // // // //             });\n// // // // // // // // // // // // // // // //             center.divideScalar(faceVertices.length || 1); // Average position = face center\n\n// // // // // // // // // // // // // // // //              // Calculate face normal (average of triangle normals or cross product)\n// // // // // // // // // // // // // // // //              // Simplified: Vector from origin to center (works for convex shape centered at origin)\n// // // // // // // // // // // // // // // //              const normal = center.clone().normalize();\n\n// // // // // // // // // // // // // // // //             // Create and position Hole Brush\n// // // // // // // // // // // // // // // //             const holeRadius = holeDiameters[faceIndex] / 2;\n// // // // // // // // // // // // // // // //             const holeBrush = new Brush(cylinderGeo); // Reuse geometry\n// // // // // // // // // // // // // // // //             holeBrush.scale.set(holeRadius, holeRadius, 1); // Scale radius\n\n// // // // // // // // // // // // // // // //             // Align cylinder's Z-axis (after rotation) to the face normal\n// // // // // // // // // // // // // // // //             tempQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), normal);\n// // // // // // // // // // // // // // // //             holeBrush.quaternion.copy(tempQuat);\n// // // // // // // // // // // // // // // //             holeBrush.position.copy(center);\n// // // // // // // // // // // // // // // //             holeBrush.updateMatrixWorld();\n\n// // // // // // // // // // // // // // // //             // Subtract hole\n// // // // // // // // // // // // // // // //             shellBrush = csgEvaluator.evaluate(shellBrush, holeBrush, SUBTRACTION);\n// // // // // // // // // // // // // // // //             faceIndex++;\n// // // // // // // // // // // // // // // //         }\n\n\n// // // // // // // // // // // // // // // //         // 3. Nodules (Spheres)\n// // // // // // // // // // // // // // // //         const noduleGeo = new THREE.SphereGeometry(noduleRadius, 8, 8); // Lower detail for nodules\n// // // // // // // // // // // // // // // //         noduleGeo.computeBoundsTree();\n// // // // // // // // // // // // // // // //         const uniqueVertices = new Map(); // Store unique vertex positions\n\n// // // // // // // // // // // // // // // //         for (let i = 0; i < vertices.length; i += 3) {\n// // // // // // // // // // // // // // // //             const x = vertices[i];\n// // // // // // // // // // // // // // // //             const y = vertices[i+1];\n// // // // // // // // // // // // // // // //             const z = vertices[i+2];\n// // // // // // // // // // // // // // // //             const key = `${x.toFixed(4)},${y.toFixed(4)},${z.toFixed(4)}`; // Key to handle floating point inaccuracies\n// // // // // // // // // // // // // // // //             if (!uniqueVertices.has(key)) {\n// // // // // // // // // // // // // // // //                 uniqueVertices.set(key, new THREE.Vector3(x, y, z));\n// // // // // // // // // // // // // // // //             }\n// // // // // // // // // // // // // // // //         }\n\n// // // // // // // // // // // // // // // //         uniqueVertices.forEach(vertexPos => {\n// // // // // // // // // // // // // // // //             const noduleBrush = new Brush(noduleGeo);\n// // // // // // // // // // // // // // // //             noduleBrush.position.copy(vertexPos);\n// // // // // // // // // // // // // // // //             noduleBrush.updateMatrixWorld();\n// // // // // // // // // // // // // // // //             shellBrush = csgEvaluator.evaluate(shellBrush, noduleBrush, ADDITION);\n// // // // // // // // // // // // // // // //         });\n\n// // // // // // // // // // // // // // // //         // 4. Final Geometry\n// // // // // // // // // // // // // // // //         const finalMesh = csgEvaluator.evaluate(shellBrush, new Brush(new THREE.BufferGeometry()), ADDITION); // Result is a Mesh\n// // // // // // // // // // // // // // // //         finalMesh.geometry.computeVertexNormals(); // Recalculate normals for proper shading\n\n// // // // // // // // // // // // // // // //         console.log(\"CSG Geometry Recalculation Complete.\");\n// // // // // // // // // // // // // // // //         return finalMesh.geometry; // Return the final BufferGeometry\n\n// // // // // // // // // // // // // // // //     }, [outerRadius, thickness, holeBaseDiameter, holeRatio, noduleRadius]); // Dependencies for useMemo\n\n// // // // // // // // // // // // // // // //     // Pass material and any other mesh props down\n// // // // // // // // // // // // // // // //     return <mesh geometry={geometry} material={material} {...props} />;\n// // // // // // // // // // // // // // // // };\n\n\n// // // // // // // // // // // // // // // // // --- Main Simulation Component (Updated to use Leva and new component) ---\n// // // // // // // // // // // // // // // // const ResonatorSimulation = () => {\n// // // // // // // // // // // // // // // //     const dodecahedronRef = useRef<THREE.Mesh>(null!); // Ref for the CSG mesh\n// // // // // // // // // // // // // // // //     // ... (particle refs remain the same)\n// // // // // // // // // // // // // // // //     const particlesRef = useRef<THREE.Points>(null!);\n// // // // // // // // // // // // // // // //     const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // // // // // // // // // // // // // // //     // --- Leva Controls (Added Shell Thickness) ---\n// // // // // // // // // // // // // // // //     const params = useControls('Resonator Controls', {\n// // // // // // // // // // // // // // // //         // ... (previous controls)\n// // // // // // // // // // // // // // // //         baseFieldSpeed: { value: 1.0, min: -5, max: 5, step: 0.1 },\n// // // // // // // // // // // // // // // //         fieldIntensity: { value: 1.0, min: 0.1, max: 5, step: 0.1 },\n// // // // // // // // // // // // // // // //         k_drag: { label: 'Induction Strength', value: 0.5, min: 0, max: 2, step: 0.05 },\n// // // // // // // // // // // // // // // //         inertiaScale: { label: 'Inertia Scale', value: 1.0, min: 0.1, max: 5, step: 0.1 }, // Scaler for inertia\n// // // // // // // // // // // // // // // //         damping: { value: 0.1, min: 0, max: 1, step: 0.01 },\n// // // // // // // // // // // // // // // //         k_feedback: { value: -0.2, min: -2, max: 2, step: 0.05 },\n// // // // // // // // // // // // // // // //     });\n\n// // // // // // // // // // // // // // // //      const shellParams = useControls('Shell Geometry', {\n// // // // // // // // // // // // // // // //          outerRadius: { value: 1.0, min: 0.5, max: 2.0, step: 0.1, editable: false }, // Keep outer radius fixed for now?\n// // // // // // // // // // // // // // // //          thickness: { value: 0.05, min: 0.01, max: 0.3, step: 0.01 },\n// // // // // // // // // // // // // // // //          holeBaseDiameter: { value: 0.1, min: 0.01, max: 0.3, step: 0.01 },\n// // // // // // // // // // // // // // // //          holeRatio: { value: 1.2, min: 1.0, max: 1.6, step: 0.01 },\n// // // // // // // // // // // // // // // //          noduleRadius: { value: 0.1, min: 0.01, max: 0.3, step: 0.01 },\n// // // // // // // // // // // // // // // //      });\n\n// // // // // // // // // // // // // // // //     // Calculate derived inertia based on scale and thickness (simple model)\n// // // // // // // // // // // // // // // //     const effectiveInertia = useMemo(() => params.inertiaScale * (shellParams.outerRadius ** 5 - (shellParams.outerRadius - shellParams.thickness) ** 5) / shellParams.outerRadius ** 5, // Rough spherical shell inertia scaling\n// // // // // // // // // // // // // // // //                                  [params.inertiaScale, shellParams.outerRadius, shellParams.thickness]);\n\n\n// // // // // // // // // // // // // // // //     // --- Physics State (Still V1 placeholders) ---\n// // // // // // // // // // // // // // // //     const physicsState = useRef({\n// // // // // // // // // // // // // // // //         shell_angular_velocity_scalar: 0.0,\n// // // // // // // // // // // // // // // //         effective_field_velocity_scalar: params.baseFieldSpeed,\n// // // // // // // // // // // // // // // //         current_torque_scalar: 0.0,\n// // // // // // // // // // // // // // // //     }).current;\n\n// // // // // // // // // // // // // // // //     // --- Particle Data (Still V1 placeholders) ---\n// // // // // // // // // // // // // // // //     const vizParams = useControls('Visualization', { /* ... as before ... */\n// // // // // // // // // // // // // // // //         particleCount: { value: 1000, min: 100, max: 5000, step: 100 },\n// // // // // // // // // // // // // // // //         particleSize: { value: 0.05, min: 0.01, max: 0.2, step: 0.01 },\n// // // // // // // // // // // // // // // //         torusMajorRadius: { value: 1.5, min: 0.5, max: 5, step: 0.1 }, // Placeholder - will adapt for nested\n// // // // // // // // // // // // // // // //         torusMinorRadius: { value: 0.5, min: 0.1, max: 2, step: 0.05 }, // Placeholder\n// // // // // // // // // // // // // // // //     });\n// // // // // // // // // // // // // // // //      const particleData = useMemo(() => { /* ... as before ... */\n// // // // // // // // // // // // // // // //         const data = [];\n// // // // // // // // // // // // // // // //         const positions = new Float32Array(vizParams.particleCount * 3);\n// // // // // // // // // // // // // // // //         for (let i = 0; i < vizParams.particleCount; i++) {\n// // // // // // // // // // // // // // // //             const u = Math.random() * Math.PI * 2;\n// // // // // // // // // // // // // // // //             const v = Math.random() * Math.PI * 2;\n// // // // // // // // // // // // // // // //             const R = vizParams.torusMajorRadius;\n// // // // // // // // // // // // // // // //             const r = vizParams.torusMinorRadius;\n// // // // // // // // // // // // // // // //             const randR = R + (Math.random() - 0.5) * 0.2;\n// // // // // // // // // // // // // // // //             const randr = r * Math.sqrt(Math.random());\n\n// // // // // // // // // // // // // // // //             positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u);\n// // // // // // // // // // // // // // // //             positions[i * 3 + 1] = randr * Math.sin(v); // Y is the torus axis\n// // // // // // // // // // // // // // // //             positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u);\n\n// // // // // // // // // // // // // // // //             // V2: Need field index, different axes, offsets etc.\n// // // // // // // // // // // // // // // //             data.push({ u, v, R, r: randr, fieldIndex: 0 }); // Add fieldIndex\n// // // // // // // // // // // // // // // //         }\n// // // // // // // // // // // // // // // //         return { positions, data };\n// // // // // // // // // // // // // // // //      }, [vizParams.particleCount, vizParams.torusMajorRadius, vizParams.torusMinorRadius]);\n\n\n// // // // // // // // // // // // // // // //     // --- Animation and Physics Loop (Still V1 placeholders) ---\n// // // // // // // // // // // // // // // //     useFrame((state, delta) => {\n// // // // // // // // // // // // // // // //         // --- V1 Physics (Using effectiveInertia now) ---\n// // // // // // // // // // // // // // // //         const relative_speed = physicsState.effective_field_velocity_scalar - physicsState.shell_angular_velocity_scalar;\n// // // // // // // // // // // // // // // //         physicsState.current_torque_scalar = params.k_drag * params.fieldIntensity * relative_speed;\n// // // // // // // // // // // // // // // //         const angular_acceleration = physicsState.current_torque_scalar / effectiveInertia; // Use calculated inertia\n// // // // // // // // // // // // // // // //         physicsState.shell_angular_velocity_scalar += angular_acceleration * delta;\n// // // // // // // // // // // // // // // //         physicsState.shell_angular_velocity_scalar *= (1 - params.damping * delta);\n// // // // // // // // // // // // // // // //         physicsState.effective_field_velocity_scalar = params.baseFieldSpeed + params.k_feedback * physicsState.shell_angular_velocity_scalar;\n// // // // // // // // // // // // // // // //         // --- END V1 PHYSICS ---\n\n// // // // // // // // // // // // // // // //         // --- Visuals Update ---\n// // // // // // // // // // // // // // // //         if (dodecahedronRef.current) {\n// // // // // // // // // // // // // // // //              dodecahedronRef.current.rotation.y += physicsState.shell_angular_velocity_scalar * delta;\n// // // // // // // // // // // // // // // //             // ... emissive update ...\n// // // // // // // // // // // // // // // //             const material = dodecahedronRef.current.material as THREE.MeshStandardMaterial;\n// // // // // // // // // // // // // // // //             const maxExpectedTorque = params.k_drag * params.fieldIntensity * (params.baseFieldSpeed * 1.5); // Rough estimate\n// // // // // // // // // // // // // // // //             const emissionStrength = Math.min(Math.abs(physicsState.current_torque_scalar) / (maxExpectedTorque + 0.01), 1.0);\n// // // // // // // // // // // // // // // //             material.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5);\n// // // // // // // // // // // // // // // //         }\n\n// // // // // // // // // // // // // // // //         // --- Particle Field Update (V1 Placeholders) ---\n// // // // // // // // // // // // // // // //         // ... (same particle update logic as before for now) ...\n// // // // // // // // // // // // // // // //         if (particleGeoRef.current && particlesRef.current) {\n// // // // // // // // // // // // // // // //             const positions = particleGeoRef.current.attributes.position.array as Float32Array;\n// // // // // // // // // // // // // // // //             const speed = physicsState.effective_field_velocity_scalar * params.fieldIntensity; // Use scalar for now\n// // // // // // // // // // // // // // // //             const pData = particleData.data;\n\n// // // // // // // // // // // // // // // //              (particlesRef.current.material as THREE.PointsMaterial).size = vizParams.particleSize * (1 + params.fieldIntensity * 0.5);\n\n// // // // // // // // // // // // // // // //             for (let i = 0; i < vizParams.particleCount; i++) {\n// // // // // // // // // // // // // // // //                 const data = pData[i];\n// // // // // // // // // // // // // // // //                 data.u += speed * delta; // Update toroidal angle (V1 logic)\n\n// // // // // // // // // // // // // // // //                 const R = data.R; const r = data.r; const u = data.u; const v = data.v;\n// // // // // // // // // // // // // // // //                 positions[i * 3] = (R + r * Math.cos(v)) * Math.cos(u);\n// // // // // // // // // // // // // // // //                 positions[i * 3 + 1] = r * Math.sin(v);\n// // // // // // // // // // // // // // // //                 positions[i * 3 + 2] = (R + r * Math.cos(v)) * Math.sin(u);\n// // // // // // // // // // // // // // // //                 // V2: Needs different colors based on fieldIndex, different update logic per field\n// // // // // // // // // // // // // // // //             }\n// // // // // // // // // // // // // // // //             particleGeoRef.current.attributes.position.needsUpdate = true;\n// // // // // // // // // // // // // // // //         }\n\n// // // // // // // // // // // // // // // //     });\n\n// // // // // // // // // // // // // // // //     // --- Define the Copper Material Once ---\n// // // // // // // // // // // // // // // //      const copperMaterial = useMemo(() => new THREE.MeshStandardMaterial({\n// // // // // // // // // // // // // // // //             color: 0xB87333,\n// // // // // // // // // // // // // // // //             metalness: 0.8,\n// // // // // // // // // // // // // // // //             roughness: 0.3,\n// // // // // // // // // // // // // // // //             emissive: 0x000000,\n// // // // // // // // // // // // // // // //             emissiveIntensity: 1.0,\n// // // // // // // // // // // // // // // //             side: THREE.DoubleSide // Important for seeing inside through holes\n// // // // // // // // // // // // // // // //         }), []);\n\n\n// // // // // // // // // // // // // // // //     return (\n// // // // // // // // // // // // // // // //         <>\n// // // // // // // // // // // // // // // //             {/* Use the new CSG Component */}\n// // // // // // // // // // // // // // // //             <RomanDodecahedron\n// // // // // // // // // // // // // // // //                 ref={dodecahedronRef} // Forward the ref if needed, or manage rotation inside\n// // // // // // // // // // // // // // // //                 outerRadius={shellParams.outerRadius}\n// // // // // // // // // // // // // // // //                 thickness={shellParams.thickness}\n// // // // // // // // // // // // // // // //                 holeBaseDiameter={shellParams.holeBaseDiameter}\n// // // // // // // // // // // // // // // //                 holeRatio={shellParams.holeRatio}\n// // // // // // // // // // // // // // // //                 noduleRadius={shellParams.noduleRadius}\n// // // // // // // // // // // // // // // //                 material={copperMaterial} // Pass the material\n// // // // // // // // // // // // // // // //                 // Rotation is handled in useFrame for now\n// // // // // // // // // // // // // // // //             />\n\n// // // // // // // // // // // // // // // //             {/* Particle Field (Unchanged for now) */}\n// // // // // // // // // // // // // // // //             <points ref={particlesRef}>\n// // // // // // // // // // // // // // // //                  <bufferGeometry ref={particleGeoRef}>\n// // // // // // // // // // // // // // // //                      <bufferAttribute\n// // // // // // // // // // // // // // // //                          attach=\"attributes-position\"\n// // // // // // // // // // // // // // // //                          count={vizParams.particleCount}\n// // // // // // // // // // // // // // // //                          array={particleData.positions}\n// // // // // // // // // // // // // // // //                          itemSize={3}\n// // // // // // // // // // // // // // // //                      />\n// // // // // // // // // // // // // // // //                  </bufferGeometry>\n// // // // // // // // // // // // // // // //                  <pointsMaterial // Update dynamically? or use shader\n// // // // // // // // // // // // // // // //                      color={0x00ffff} // V2: Will be vertex colors\n// // // // // // // // // // // // // // // //                      size={vizParams.particleSize} // Updated dynamically in useFrame\n// // // // // // // // // // // // // // // //                      transparent opacity={0.7}\n// // // // // // // // // // // // // // // //                      blending={THREE.AdditiveBlending} sizeAttenuation\n// // // // // // // // // // // // // // // //                      // vertexColors={true} // Enable for V2\n// // // // // // // // // // // // // // // //                  />\n// // // // // // // // // // // // // // // //             </points>\n// // // // // // // // // // // // // // // //         </>\n// // // // // // // // // // // // // // // //     );\n// // // // // // // // // // // // // // // // };\n\n\n// // // // // // // // // // // // // // // // // --- Scene Component (Container - Unchanged) ---\n// // // // // // // // // // // // // // // // const TemporalResonatorScene: React.FC = () => (\n// // // // // // // // // // // // // // // //     <>\n// // // // // // // // // // // // // // // //         <Leva collapsed={false} />\n// // // // // // // // // // // // // // // //         <Canvas\n// // // // // // // // // // // // // // // //              style={{ position: 'absolute', top: 0, left: 0, width: '100vw', height: '100vh', background: '#111122', zIndex: 0 }}\n// // // // // // // // // // // // // // // //              camera={{ position: [3, 3, 5], fov: 75 }}\n// // // // // // // // // // // // // // // //              gl={{ antialias: true }}\n// // // // // // // // // // // // // // // //              shadows // Enable shadows if needed for directional light\n// // // // // // // // // // // // // // // //         >\n// // // // // // // // // // // // // // // //              <ambientLight intensity={0.4} /> {/* Slightly lower ambient */}\n// // // // // // // // // // // // // // // //              <directionalLight\n// // // // // // // // // // // // // // // //                  position={[5, 10, 7.5]}\n// // // // // // // // // // // // // // // //                  intensity={1.0} // Stronger directional\n// // // // // // // // // // // // // // // //                  castShadow // Enable shadow casting\n// // // // // // // // // // // // // // // //                  shadow-mapSize-width={1024}\n// // // // // // // // // // // // // // // //                  shadow-mapSize-height={1024}\n// // // // // // // // // // // // // // // //              />\n// // // // // // // // // // // // // // // //              <ErrorBoundary>\n// // // // // // // // // // // // // // // //                  <React.Suspense fallback={null}> {/* Suspense might be needed if CSG is slow or async */}\n// // // // // // // // // // // // // // // //                       <ResonatorSimulation />\n// // // // // // // // // // // // // // // //                  </React.Suspense>\n// // // // // // // // // // // // // // // //              </ErrorBoundary>\n// // // // // // // // // // // // // // // //              <Controls />\n// // // // // // // // // // // // // // // //         </Canvas>\n// // // // // // // // // // // // // // // //     </>\n// // // // // // // // // // // // // // // // );\n\n// // // // // // // // // // // // // // // // export default TemporalResonatorScene;\n\n// // // // // // // // // // // // // // // // // // TemporalResonatorScene_V2.tsx (Starting Point)\n// // // // // // // // // // // // // // // // // import React, { useRef, useEffect, useMemo } from 'react';\n// // // // // // // // // // // // // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // // // // // // // // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // // // // // // // // // // // // // import * as THREE from 'three';\n// // // // // // // // // // // // // // // // // import { useControls, Leva } from 'leva'; // Import leva\n// // // // // // // // // // // // // // // // // import ErrorBoundary from './errorBoundary';\n\n\n// // // // // // // // // // // // // // // // // extend({ OrbitControls });\n\n// // // // // // // // // // // // // // // // // // --- Controls Component (Unchanged) ---\n// // // // // // // // // // // // // // // // // const Controls = () => {\n// // // // // // // // // // // // // // // // //     // ... (same as before)\n// // // // // // // // // // // // // // // // //     const { camera, gl } = useThree();\n// // // // // // // // // // // // // // // // //     const controlsRef = useRef<OrbitControls>(null); // Use OrbitControls type\n\n// // // // // // // // // // // // // // // // //     useEffect(() => {\n// // // // // // // // // // // // // // // // //       const controls = new OrbitControls(camera, gl.domElement);\n// // // // // // // // // // // // // // // // //       controls.enableDamping = true;\n// // // // // // // // // // // // // // // // //       (controlsRef as React.MutableRefObject<OrbitControls>).current = controls; // Assign to ref\n\n// // // // // // // // // // // // // // // // //       return () => {\n// // // // // // // // // // // // // // // // //         controls.dispose();\n// // // // // // // // // // // // // // // // //       };\n// // // // // // // // // // // // // // // // //     }, [camera, gl]);\n\n// // // // // // // // // // // // // // // // //     useFrame(() => {\n// // // // // // // // // // // // // // // // //       controlsRef.current?.update(); // Safely call update if controls exist\n// // // // // // // // // // // // // // // // //     });\n\n// // // // // // // // // // // // // // // // //     return null;\n// // // // // // // // // // // // // // // // // };\n\n\n// // // // // // // // // // // // // // // // // // --- Main Simulation Component ---\n// // // // // // // // // // // // // // // // // const ResonatorSimulation = () => {\n// // // // // // // // // // // // // // // // //     const dodecahedronRef = useRef<THREE.Mesh>(null!);\n// // // // // // // // // // // // // // // // //     const particlesRef = useRef<THREE.Points>(null!);\n// // // // // // // // // // // // // // // // //     const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // // // // // // // // // // // // // // // //     // --- Leva Controls ---\n// // // // // // // // // // // // // // // // //     const params = useControls('Resonator Controls', {\n// // // // // // // // // // // // // // // // //         baseFieldSpeed: { value: 1.0, min: -5, max: 5, step: 0.1 },\n// // // // // // // // // // // // // // // // //         fieldIntensity: { value: 1.0, min: 0.1, max: 5, step: 0.1 },\n// // // // // // // // // // // // // // // // //         k_drag: { label: 'Induction Strength', value: 0.5, min: 0, max: 2, step: 0.05 },\n// // // // // // // // // // // // // // // // //         inertia: { value: 1.0, min: 0.1, max: 5, step: 0.1 }, // Will link to thickness later\n// // // // // // // // // // // // // // // // //         damping: { value: 0.1, min: 0, max: 1, step: 0.01 },\n// // // // // // // // // // // // // // // // //         k_feedback: { value: -0.2, min: -2, max: 2, step: 0.05 },\n// // // // // // // // // // // // // // // // //         // --- Placeholders for V2 ---\n// // // // // // // // // // // // // // // // //         // shellThickness: { value: 1.0, min: 0.1, max: 2.0, step: 0.1 }, // Add later\n// // // // // // // // // // // // // // // // //         // ... per-field controls ...\n// // // // // // // // // // // // // // // // //     });\n\n// // // // // // // // // // // // // // // // //      const vizParams = useControls('Visualization', {\n// // // // // // // // // // // // // // // // //         particleCount: { value: 1000, min: 100, max: 5000, step: 100 },\n// // // // // // // // // // // // // // // // //         particleSize: { value: 0.05, min: 0.01, max: 0.2, step: 0.01 },\n// // // // // // // // // // // // // // // // //         torusMajorRadius: { value: 1.5, min: 0.5, max: 5, step: 0.1 }, // Placeholder - will adapt for nested\n// // // // // // // // // // // // // // // // //         torusMinorRadius: { value: 0.5, min: 0.1, max: 2, step: 0.05 }, // Placeholder\n// // // // // // // // // // // // // // // // //      });\n\n\n// // // // // // // // // // // // // // // // //     // --- Physics State (Using refs for mutable state within useFrame) ---\n// // // // // // // // // // // // // // // // //     const physicsState = useRef({\n// // // // // // // // // // // // // // // // //         // --- V1 State (will be replaced/expanded) ---\n// // // // // // // // // // // // // // // // //         shell_angular_velocity_scalar: 0.0, // Will become Vector3\n// // // // // // // // // // // // // // // // //         effective_field_velocity_scalar: params.baseFieldSpeed, // Will become per-field\n// // // // // // // // // // // // // // // // //         current_torque_scalar: 0.0, // Will become Vector3\n// // // // // // // // // // // // // // // // //         // --- V2 State (Placeholders) ---\n// // // // // // // // // // // // // // // // //         // shell_angular_velocity: new THREE.Vector3(0,0,0),\n// // // // // // // // // // // // // // // // //         // shell_orientation: new THREE.Quaternion(),\n// // // // // // // // // // // // // // // // //         // effective_field_velocities: [params.baseFieldSpeed, ...], // Per field\n// // // // // // // // // // // // // // // // //         // current_torque: new THREE.Vector3(0,0,0),\n// // // // // // // // // // // // // // // // //     }).current;\n\n// // // // // // // // // // // // // // // // //     // --- Particle Data (Memoized - will need rework for nested fields) ---\n// // // // // // // // // // // // // // // // //      const particleData = useMemo(() => {\n// // // // // // // // // // // // // // // // //         const data = [];\n// // // // // // // // // // // // // // // // //         const positions = new Float32Array(vizParams.particleCount * 3);\n// // // // // // // // // // // // // // // // //         for (let i = 0; i < vizParams.particleCount; i++) {\n// // // // // // // // // // // // // // // // //             const u = Math.random() * Math.PI * 2;\n// // // // // // // // // // // // // // // // //             const v = Math.random() * Math.PI * 2;\n// // // // // // // // // // // // // // // // //             const R = vizParams.torusMajorRadius;\n// // // // // // // // // // // // // // // // //             const r = vizParams.torusMinorRadius;\n// // // // // // // // // // // // // // // // //             const randR = R + (Math.random() - 0.5) * 0.2;\n// // // // // // // // // // // // // // // // //             const randr = r * Math.sqrt(Math.random());\n\n// // // // // // // // // // // // // // // // //             positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u);\n// // // // // // // // // // // // // // // // //             positions[i * 3 + 1] = randr * Math.sin(v); // Y is the torus axis\n// // // // // // // // // // // // // // // // //             positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u);\n\n// // // // // // // // // // // // // // // // //             // V2: Need field index, different axes, offsets etc.\n// // // // // // // // // // // // // // // // //             //es-lint-disable-next-line\n// // // // // // // // // // // // // // // // //             data.push({ u: u, v: v, R: R, r: randr, fieldIndex: 0 }); // Add fieldIndex\n// // // // // // // // // // // // // // // // //         }\n// // // // // // // // // // // // // // // // //         return { positions, data };\n// // // // // // // // // // // // // // // // //      }, [vizParams.particleCount, vizParams.torusMajorRadius, vizParams.torusMinorRadius]);\n\n\n// // // // // // // // // // // // // // // // //     // --- Animation and Physics Loop ---\n// // // // // // // // // // // // // // // // //     useFrame((state, delta) => {\n// // // // // // // // // // // // // // // // //         // --- V1 Physics (PLACEHOLDER - TO BE REPLACED BY 3D) ---\n// // // // // // // // // // // // // // // // //         const relative_speed = physicsState.effective_field_velocity_scalar - physicsState.shell_angular_velocity_scalar;\n// // // // // // // // // // // // // // // // //         physicsState.current_torque_scalar = params.k_drag * params.fieldIntensity * relative_speed;\n// // // // // // // // // // // // // // // // //         const angular_acceleration = physicsState.current_torque_scalar / params.inertia;\n// // // // // // // // // // // // // // // // //         physicsState.shell_angular_velocity_scalar += angular_acceleration * delta;\n// // // // // // // // // // // // // // // // //         physicsState.shell_angular_velocity_scalar *= (1 - params.damping * delta);\n// // // // // // // // // // // // // // // // //         physicsState.effective_field_velocity_scalar = params.baseFieldSpeed + params.k_feedback * physicsState.shell_angular_velocity_scalar;\n// // // // // // // // // // // // // // // // //         // --- END V1 PHYSICS PLACEHOLDER ---\n\n// // // // // // // // // // // // // // // // //         // --- Visuals Update ---\n// // // // // // // // // // // // // // // // //         if (dodecahedronRef.current) {\n// // // // // // // // // // // // // // // // //              // V1 Rotation:\n// // // // // // // // // // // // // // // // //              dodecahedronRef.current.rotation.y += physicsState.shell_angular_velocity_scalar * delta;\n// // // // // // // // // // // // // // // // //              // V2 Rotation (using Quaternion - Placeholder):\n// // // // // // // // // // // // // // // // //              // dodecahedronRef.current.quaternion.multiply(...)\n\n// // // // // // // // // // // // // // // // //             // Induction Effect (Emissive - using scalar torque for now)\n// // // // // // // // // // // // // // // // //             const material = dodecahedronRef.current.material as THREE.MeshStandardMaterial;\n// // // // // // // // // // // // // // // // //             const maxExpectedTorque = params.k_drag * params.fieldIntensity * (params.baseFieldSpeed * 1.5); // Rough estimate\n// // // // // // // // // // // // // // // // //             const emissionStrength = Math.min(Math.abs(physicsState.current_torque_scalar) / (maxExpectedTorque + 0.01), 1.0);\n// // // // // // // // // // // // // // // // //             material.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5);\n// // // // // // // // // // // // // // // // //         }\n\n// // // // // // // // // // // // // // // // //         // --- Particle Field Update (V1 PLACEHOLDER - Needs major rework for V2) ---\n// // // // // // // // // // // // // // // // //         if (particleGeoRef.current && particlesRef.current) {\n// // // // // // // // // // // // // // // // //             const positions = particleGeoRef.current.attributes.position.array as Float32Array;\n// // // // // // // // // // // // // // // // //             const speed = physicsState.effective_field_velocity_scalar * params.fieldIntensity; // Use scalar for now\n// // // // // // // // // // // // // // // // //             const pData = particleData.data;\n\n// // // // // // // // // // // // // // // // //              (particlesRef.current.material as THREE.PointsMaterial).size = vizParams.particleSize * (1 + params.fieldIntensity * 0.5);\n\n// // // // // // // // // // // // // // // // //             for (let i = 0; i < vizParams.particleCount; i++) {\n// // // // // // // // // // // // // // // // //                 const data = pData[i];\n// // // // // // // // // // // // // // // // //                 data.u += speed * delta; // Update toroidal angle (V1 logic)\n\n// // // // // // // // // // // // // // // // //                 const R = data.R; const r = data.r; const u = data.u; const v = data.v;\n// // // // // // // // // // // // // // // // //                 positions[i * 3] = (R + r * Math.cos(v)) * Math.cos(u);\n// // // // // // // // // // // // // // // // //                 positions[i * 3 + 1] = r * Math.sin(v);\n// // // // // // // // // // // // // // // // //                 positions[i * 3 + 2] = (R + r * Math.cos(v)) * Math.sin(u);\n// // // // // // // // // // // // // // // // //                 // V2: Needs different colors based on fieldIndex, different update logic per field\n// // // // // // // // // // // // // // // // //             }\n// // // // // // // // // // // // // // // // //             particleGeoRef.current.attributes.position.needsUpdate = true;\n// // // // // // // // // // // // // // // // //         }\n// // // // // // // // // // // // // // // // //         // --- END PARTICLE UPDATE PLACEHOLDER ---\n// // // // // // // // // // // // // // // // //     });\n\n// // // // // // // // // // // // // // // // //     return (\n// // // // // // // // // // // // // // // // //         <>\n// // // // // // // // // // // // // // // // //             {/* Dodecahedron Mesh (Still using basic geometry) */}\n// // // // // // // // // // // // // // // // //             <mesh ref={dodecahedronRef} /* rotation/quaternion updated in useFrame */ >\n// // // // // // // // // // // // // // // // //                 <dodecahedronGeometry args={[1]} />\n// // // // // // // // // // // // // // // // //                 {/* V2: Replace with CSG or Loaded Model */}\n// // // // // // // // // // // // // // // // //                 <meshStandardMaterial\n// // // // // // // // // // // // // // // // //                     color={0xB87333} metalness={0.8} roughness={0.3}\n// // // // // // // // // // // // // // // // //                     emissive={0x000000} emissiveIntensity={1.0}\n// // // // // // // // // // // // // // // // //                 />\n// // // // // // // // // // // // // // // // //             </mesh>\n\n// // // // // // // // // // // // // // // // //             {/* Particle Field (Using basic geometry setup for now) */}\n// // // // // // // // // // // // // // // // //             <points ref={particlesRef}>\n// // // // // // // // // // // // // // // // //                 <bufferGeometry ref={particleGeoRef}>\n// // // // // // // // // // // // // // // // //                     <bufferAttribute\n// // // // // // // // // // // // // // // // //                         attach=\"attributes-position\"\n// // // // // // // // // // // // // // // // //                         count={vizParams.particleCount}\n// // // // // // // // // // // // // // // // //                         array={particleData.positions}\n// // // // // // // // // // // // // // // // //                         itemSize={3}\n// // // // // // // // // // // // // // // // //                     />\n// // // // // // // // // // // // // // // // //                     {/* V2: Need color attribute */}\n// // // // // // // // // // // // // // // // //                 </bufferGeometry>\n// // // // // // // // // // // // // // // // //                 <pointsMaterial // Update dynamically? or use shader\n// // // // // // // // // // // // // // // // //                     color={0x00ffff} // V2: Will be vertex colors\n// // // // // // // // // // // // // // // // //                     size={vizParams.particleSize} // Updated dynamically in useFrame\n// // // // // // // // // // // // // // // // //                     transparent opacity={0.7}\n// // // // // // // // // // // // // // // // //                     blending={THREE.AdditiveBlending} sizeAttenuation\n// // // // // // // // // // // // // // // // //                     vertexColors // Enable for V2\n// // // // // // // // // // // // // // // // //                 />\n// // // // // // // // // // // // // // // // //             </points>\n// // // // // // // // // // // // // // // // //         </>\n// // // // // // // // // // // // // // // // //     );\n// // // // // // // // // // // // // // // // // };\n\n\n// // // // // // // // // // // // // // // // // // --- Scene Component (Container) ---\n// // // // // // // // // // // // // // // // // const TemporalResonatorScene: React.FC = () => (\n// // // // // // // // // // // // // // // // //     <> {/* Need fragment to render Leva alongside Canvas */}\n// // // // // // // // // // // // // // // // //         {/* Leva GUI Panel - Positioned automatically */}\n// // // // // // // // // // // // // // // // //         <Leva collapsed={false} /* Optional: theme={...} */ />\n\n// // // // // // // // // // // // // // // // //         <Canvas\n// // // // // // // // // // // // // // // // //             style={{ position: 'absolute', top: 0, left: 0, width: '100vw', height: '100vh', background: '#111122', zIndex: 0 }} // Ensure canvas is behind leva\n// // // // // // // // // // // // // // // // //             camera={{ position: [3, 3, 5], fov: 75 }}\n// // // // // // // // // // // // // // // // //             gl={{ antialias: true }}\n// // // // // // // // // // // // // // // // //         >\n// // // // // // // // // // // // // // // // //             <ambientLight intensity={0.5} />\n// // // // // // // // // // // // // // // // //             <directionalLight position={[5, 10, 7.5]} intensity={0.8} />\n// // // // // // // // // // // // // // // // //             <ErrorBoundary>\n// // // // // // // // // // // // // // // // //                 <ResonatorSimulation />\n// // // // // // // // // // // // // // // // //             </ErrorBoundary>\n// // // // // // // // // // // // // // // // //             <Controls />\n// // // // // // // // // // // // // // // // //         </Canvas>\n// // // // // // // // // // // // // // // // //     </>\n// // // // // // // // // // // // // // // // // );\n\n// // // // // // // // // // // // // // // // // export default TemporalResonatorScene;\n\n// // // // // // // // // // // // // // // // // // // TemporalResonatorScene.tsx\n// // // // // // // // // // // // // // // // // // import React, { useRef, useEffect, useState, useMemo } from 'react';\n// // // // // // // // // // // // // // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // // // // // // // // // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'; // Using your import style\n// // // // // // // // // // // // // // // // // // import * as THREE from 'three';\n// // // // // // // // // // // // // // // // // // import ErrorBoundary from './errorBoundary'; // Assuming this path is correct\n\n// // // // // // // // // // // // // // // // // // // Extend Three.js components for R3F declarative use\n// // // // // // // // // // // // // // // // // // extend({ OrbitControls });\n\n// // // // // // // // // // // // // // // // // // // --- Reusable Controls Component (Adapted from your BlackHoleScene) ---\n// // // // // // // // // // // // // // // // // // const Controls = () => {\n// // // // // // // // // // // // // // // // // //   const { camera, gl } = useThree();\n// // // // // // // // // // // // // // // // // //   const controlsRef = useRef<OrbitControls>(null); // Use OrbitControls type\n\n// // // // // // // // // // // // // // // // // //   useEffect(() => {\n// // // // // // // // // // // // // // // // // //     // Ensure controlsRef.current is correctly typed if possible, or use 'any' if necessary\n// // // // // // // // // // // // // // // // // //     const controls = new OrbitControls(camera, gl.domElement);\n// // // // // // // // // // // // // // // // // //     controls.enableDamping = true;\n// // // // // // // // // // // // // // // // // //     (controlsRef as React.MutableRefObject<OrbitControls>).current = controls; // Assign to ref\n\n// // // // // // // // // // // // // // // // // //     return () => {\n// // // // // // // // // // // // // // // // // //       controls.dispose();\n// // // // // // // // // // // // // // // // // //     };\n// // // // // // // // // // // // // // // // // //   }, [camera, gl]);\n\n// // // // // // // // // // // // // // // // // //   useFrame(() => {\n// // // // // // // // // // // // // // // // // //     controlsRef.current?.update(); // Safely call update if controls exist\n// // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // //   return null;\n// // // // // // // // // // // // // // // // // // };\n\n\n// // // // // // // // // // // // // // // // // // // --- Main Simulation Component ---\n// // // // // // // // // // // // // // // // // // const ResonatorSimulation = () => {\n// // // // // // // // // // // // // // // // // //   const dodecahedronRef = useRef<THREE.Mesh>(null!);\n// // // // // // // // // // // // // // // // // //   const particlesRef = useRef<THREE.Points>(null!);\n// // // // // // // // // // // // // // // // // //   const particleGeoRef = useRef<THREE.BufferGeometry>(null!);\n\n// // // // // // // // // // // // // // // // // //   // --- State for Controllable Parameters (Replaces lil-gui) ---\n// // // // // // // // // // // // // // // // // //   const [params] = useState({ // Use useState if you plan to add UI controls later\n// // // // // // // // // // // // // // // // // //       baseFieldSpeed: 1.0,\n// // // // // // // // // // // // // // // // // //       fieldIntensity: 1.0,\n// // // // // // // // // // // // // // // // // //       k_drag: 0.5,\n// // // // // // // // // // // // // // // // // //       inertia: 1.0,\n// // // // // // // // // // // // // // // // // //       damping: 0.1,\n// // // // // // // // // // // // // // // // // //       k_feedback: -0.2,\n// // // // // // // // // // // // // // // // // //       particleCount: 1000,\n// // // // // // // // // // // // // // // // // //       particleSize: 0.05,\n// // // // // // // // // // // // // // // // // //       torusMajorRadius: 1.5,\n// // // // // // // // // // // // // // // // // //       torusMinorRadius: 0.5,\n// // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // //   // --- Physics State (Using refs for mutable state within useFrame) ---\n// // // // // // // // // // // // // // // // // //   const physicsState = useRef({\n// // // // // // // // // // // // // // // // // //       shell_angular_velocity: 0.0,\n// // // // // // // // // // // // // // // // // //       effective_field_velocity: params.baseFieldSpeed,\n// // // // // // // // // // // // // // // // // //       current_torque: 0.0,\n// // // // // // // // // // // // // // // // // //   }).current; // .current makes it directly accessible\n\n// // // // // // // // // // // // // // // // // //   // --- Particle Data (Memoized to avoid recalculation) ---\n// // // // // // // // // // // // // // // // // //   const particleData = useMemo(() => {\n// // // // // // // // // // // // // // // // // //       const data = [];\n// // // // // // // // // // // // // // // // // //       const positions = new Float32Array(params.particleCount * 3);\n// // // // // // // // // // // // // // // // // //       for (let i = 0; i < params.particleCount; i++) {\n// // // // // // // // // // // // // // // // // //           const u = Math.random() * Math.PI * 2;\n// // // // // // // // // // // // // // // // // //           const v = Math.random() * Math.PI * 2;\n// // // // // // // // // // // // // // // // // //           const R = params.torusMajorRadius;\n// // // // // // // // // // // // // // // // // //           const r = params.torusMinorRadius;\n// // // // // // // // // // // // // // // // // //           const randR = R + (Math.random() - 0.5) * 0.2;\n// // // // // // // // // // // // // // // // // //           const randr = r * Math.sqrt(Math.random());\n\n// // // // // // // // // // // // // // // // // //           positions[i * 3] = (randR + randr * Math.cos(v)) * Math.cos(u);\n// // // // // // // // // // // // // // // // // //           positions[i * 3 + 1] = randr * Math.sin(v); // Y is the torus axis\n// // // // // // // // // // // // // // // // // //           positions[i * 3 + 2] = (randR + randr * Math.cos(v)) * Math.sin(u);\n// // // // // // // // // // // // // // // // // //           // eslint-disable-next-line\n// // // // // // // // // // // // // // // // // //           data.push({ u: u, v: v, R: R, r: randr }); // Store initial angles/radii\n// // // // // // // // // // // // // // // // // //       }\n// // // // // // // // // // // // // // // // // //       return { positions, data };\n// // // // // // // // // // // // // // // // // //   }, [params.particleCount, params.torusMajorRadius, params.torusMinorRadius]); // Recalculate only if these change\n\n\n// // // // // // // // // // // // // // // // // //   // --- Animation and Physics Loop ---\n// // // // // // // // // // // // // // // // // //   useFrame((state, delta) => {\n// // // // // // // // // // // // // // // // // //     // --- Physics Update ---\n// // // // // // // // // // // // // // // // // //     const relative_speed = physicsState.effective_field_velocity - physicsState.shell_angular_velocity;\n// // // // // // // // // // // // // // // // // //     physicsState.current_torque = params.k_drag * params.fieldIntensity * relative_speed;\n// // // // // // // // // // // // // // // // // //     const angular_acceleration = physicsState.current_torque / params.inertia;\n// // // // // // // // // // // // // // // // // //     physicsState.shell_angular_velocity += angular_acceleration * delta;\n// // // // // // // // // // // // // // // // // //     physicsState.shell_angular_velocity *= (1 - params.damping * delta);\n// // // // // // // // // // // // // // // // // //     physicsState.effective_field_velocity = params.baseFieldSpeed + params.k_feedback * physicsState.shell_angular_velocity;\n\n// // // // // // // // // // // // // // // // // //     // --- Visuals Update ---\n// // // // // // // // // // // // // // // // // //     // Dodecahedron Rotation\n// // // // // // // // // // // // // // // // // //     if (dodecahedronRef.current) {\n// // // // // // // // // // // // // // // // // //       dodecahedronRef.current.rotation.y += physicsState.shell_angular_velocity * delta;\n\n// // // // // // // // // // // // // // // // // //       // Induction Effect (Emissive)\n// // // // // // // // // // // // // // // // // //       const material = dodecahedronRef.current.material as THREE.MeshStandardMaterial;\n// // // // // // // // // // // // // // // // // //       const maxExpectedTorque = params.k_drag * params.fieldIntensity * (params.baseFieldSpeed * 1.5);\n// // // // // // // // // // // // // // // // // //       const emissionStrength = Math.min(Math.abs(physicsState.current_torque) / (maxExpectedTorque + 0.01), 1.0);\n// // // // // // // // // // // // // // // // // //       material.emissive.setHSL(0.1, 1.0, emissionStrength * 0.5); // Glow orange/yellow\n// // // // // // // // // // // // // // // // // //     }\n\n// // // // // // // // // // // // // // // // // //     // Particle Field Update\n// // // // // // // // // // // // // // // // // //     if (particleGeoRef.current && particlesRef.current) {\n// // // // // // // // // // // // // // // // // //         const positions = particleGeoRef.current.attributes.position.array as Float32Array;\n// // // // // // // // // // // // // // // // // //         const speed = physicsState.effective_field_velocity * params.fieldIntensity;\n// // // // // // // // // // // // // // // // // //         const pData = particleData.data; // Access memoized data\n\n// // // // // // // // // // // // // // // // // //         // Update particle size based on intensity via material ref\n// // // // // // // // // // // // // // // // // //         (particlesRef.current.material as THREE.PointsMaterial).size = params.particleSize * (1 + params.fieldIntensity * 0.5);\n\n// // // // // // // // // // // // // // // // // //         for (let i = 0; i < params.particleCount; i++) {\n// // // // // // // // // // // // // // // // // //             const data = pData[i];\n// // // // // // // // // // // // // // // // // //             data.u += speed * delta; // Update toroidal angle\n\n// // // // // // // // // // // // // // // // // //             const R = data.R;\n// // // // // // // // // // // // // // // // // //             const r = data.r;\n// // // // // // // // // // // // // // // // // //             const u = data.u;\n// // // // // // // // // // // // // // // // // //             const v = data.v;\n\n// // // // // // // // // // // // // // // // // //             positions[i * 3] = (R + r * Math.cos(v)) * Math.cos(u);\n// // // // // // // // // // // // // // // // // //             positions[i * 3 + 1] = r * Math.sin(v);\n// // // // // // // // // // // // // // // // // //             positions[i * 3 + 2] = (R + r * Math.cos(v)) * Math.sin(u);\n// // // // // // // // // // // // // // // // // //         }\n// // // // // // // // // // // // // // // // // //         particleGeoRef.current.attributes.position.needsUpdate = true; // IMPORTANT!\n// // // // // // // // // // // // // // // // // //     }\n// // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // //   // --- Reset Logic (Example - could be triggered by a button) ---\n// // // // // // // // // // // // // // // // // //   // const resetSimulation = () => {\n// // // // // // // // // // // // // // // // // //   //     physicsState.shell_angular_velocity = 0;\n// // // // // // // // // // // // // // // // // //   //     if (dodecahedronRef.current) dodecahedronRef.current.rotation.y = 0;\n// // // // // // // // // // // // // // // // // //   //     // Reset particle positions if needed\n// // // // // // // // // // // // // // // // // //   // };\n\n// // // // // // // // // // // // // // // // // //   return (\n// // // // // // // // // // // // // // // // // //     <>\n// // // // // // // // // // // // // // // // // //       {/* Dodecahedron Mesh */}\n// // // // // // // // // // // // // // // // // //       <mesh ref={dodecahedronRef}>\n// // // // // // // // // // // // // // // // // //         <dodecahedronGeometry args={[1]} />\n// // // // // // // // // // // // // // // // // //         <meshStandardMaterial\n// // // // // // // // // // // // // // // // // //           color={0xB87333}\n// // // // // // // // // // // // // // // // // //           metalness={0.8}\n// // // // // // // // // // // // // // // // // //           roughness={0.3}\n// // // // // // // // // // // // // // // // // //           emissive={0x000000} // Initial emissive state\n// // // // // // // // // // // // // // // // // //           emissiveIntensity={1.0}\n// // // // // // // // // // // // // // // // // //         />\n// // // // // // // // // // // // // // // // // //       </mesh>\n\n// // // // // // // // // // // // // // // // // //       {/* Particle Field */}\n// // // // // // // // // // // // // // // // // //       <points ref={particlesRef}>\n// // // // // // // // // // // // // // // // // //         <bufferGeometry ref={particleGeoRef}>\n// // // // // // // // // // // // // // // // // //             {/* Use attach to set the attribute */}\n// // // // // // // // // // // // // // // // // //             <bufferAttribute\n// // // // // // // // // // // // // // // // // //                 attach=\"attributes-position\"\n// // // // // // // // // // // // // // // // // //                 count={params.particleCount}\n// // // // // // // // // // // // // // // // // //                 array={particleData.positions} // Use memoized initial positions\n// // // // // // // // // // // // // // // // // //                 itemSize={3}\n// // // // // // // // // // // // // // // // // //             />\n// // // // // // // // // // // // // // // // // //         </bufferGeometry>\n// // // // // // // // // // // // // // // // // //         <pointsMaterial\n// // // // // // // // // // // // // // // // // //             color={0x00ffff}\n// // // // // // // // // // // // // // // // // //             size={params.particleSize}\n// // // // // // // // // // // // // // // // // //             transparent\n// // // // // // // // // // // // // // // // // //             opacity={0.7}\n// // // // // // // // // // // // // // // // // //             blending={THREE.AdditiveBlending}\n// // // // // // // // // // // // // // // // // //             sizeAttenuation\n// // // // // // // // // // // // // // // // // //         />\n// // // // // // // // // // // // // // // // // //       </points>\n// // // // // // // // // // // // // // // // // //     </>\n// // // // // // // // // // // // // // // // // //   );\n// // // // // // // // // // // // // // // // // // };\n\n\n// // // // // // // // // // // // // // // // // // // --- Scene Component (Container) ---\n// // // // // // // // // // // // // // // // // // const TemporalResonatorScene: React.FC = () => (\n// // // // // // // // // // // // // // // // // //   <Canvas\n// // // // // // // // // // // // // // // // // //     style={{ width: '100vw', height: '100vh', background: '#111122' }} // Match background\n// // // // // // // // // // // // // // // // // //     camera={{ position: [3, 3, 5], fov: 75 }} // Match camera setup\n// // // // // // // // // // // // // // // // // //     gl={{ antialias: true }} // Match renderer option\n// // // // // // // // // // // // // // // // // //   >\n// // // // // // // // // // // // // // // // // //     {/* Lighting */}\n// // // // // // // // // // // // // // // // // //     <ambientLight intensity={0.5} />\n// // // // // // // // // // // // // // // // // //     <directionalLight position={[5, 10, 7.5]} intensity={0.8} />\n\n// // // // // // // // // // // // // // // // // //     {/* Error Boundary wrapping the simulation */}\n// // // // // // // // // // // // // // // // // //     <ErrorBoundary>\n// // // // // // // // // // // // // // // // // //       <ResonatorSimulation />\n// // // // // // // // // // // // // // // // // //     </ErrorBoundary>\n\n// // // // // // // // // // // // // // // // // //     {/* Controls */}\n// // // // // // // // // // // // // // // // // //     <Controls />\n// // // // // // // // // // // // // // // // // //   </Canvas>\n// // // // // // // // // // // // // // // // // // );\n\n// // // // // // // // // // // // // // // // // // export default TemporalResonatorScene;\n\n// // // // // // // // // // // // // // // // // // // // BlackHoleScene.tsx\n\n// // // // // // // // // // // // // // // // // // // // import React, { useState, useEffect, useRef, useMemo } from 'react';\n// // // // // // // // // // // // // // // // // // // // import {\n// // // // // // // // // // // // // // // // // // // //   ShaderMaterial,\n// // // // // // // // // // // // // // // // // // // //   Vector2,\n// // // // // // // // // // // // // // // // // // // //   AdditiveBlending,\n// // // // // // // // // // // // // // // // // // // //   Mesh,\n// // // // // // // // // // // // // // // // // // // //   Points,\n// // // // // // // // // // // // // // // // // // // //   BufferGeometry,\n// // // // // // // // // // // // // // // // // // // //   BufferAttribute,\n// // // // // // // // // // // // // // // // // // // //   PointsMaterial,\n// // // // // // // // // // // // // // // // // // // //   Color,\n// // // // // // // // // // // // // // // // // // // //   Vector3,\n// // // // // // // // // // // // // // // // // // // //   DoubleSide,\n// // // // // // // // // // // // // // // // // // // // } from 'three';\n// // // // // // // // // // // // // // // // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // // // // // // // // // // // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // // // // // // // // // // // // // // // // import { EffectComposer, Bloom } from '@react-three/postprocessing';\n// // // // // // // // // // // // // // // // // // // // import ErrorBoundary from './errorBoundary';\n\n// // // // // // // // // // // // // // // // // // // // extend({ OrbitControls });\n\n// // // // // // // // // // // // // // // // // // // // const Controls = () => {\n// // // // // // // // // // // // // // // // // // // //   const { camera, gl } = useThree();\n// // // // // // // // // // // // // // // // // // // //   const controlsRef = useRef<any>(null);\n\n// // // // // // // // // // // // // // // // // // // //   useEffect(() => {\n// // // // // // // // // // // // // // // // // // // //     controlsRef.current = new OrbitControls(camera, gl.domElement);\n// // // // // // // // // // // // // // // // // // // //     controlsRef.current.enableDamping = true;\n// // // // // // // // // // // // // // // // // // // //     return () => {\n// // // // // // // // // // // // // // // // // // // //       controlsRef.current.dispose();\n// // // // // // // // // // // // // // // // // // // //     };\n// // // // // // // // // // // // // // // // // // // //   }, [camera, gl]);\n\n// // // // // // // // // // // // // // // // // // // //   useFrame(() => {\n// // // // // // // // // // // // // // // // // // // //     controlsRef.current.update();\n// // // // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // // // //   return null;\n// // // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // // const BlackHole = () => {\n// // // // // // // // // // // // // // // // // // // //   const meshRef = useRef<Mesh>(null);\n\n// // // // // // // // // // // // // // // // // // // //   // Custom shader material for the black hole with gravitational lensing\n// // // // // // // // // // // // // // // // // // // //   const blackHoleMaterial = useMemo(\n// // // // // // // // // // // // // // // // // // // //     () =>\n// // // // // // // // // // // // // // // // // // // //       new ShaderMaterial({\n// // // // // // // // // // // // // // // // // // // //         uniforms: {\n// // // // // // // // // // // // // // // // // // // //           u_time: { value: 0 },\n// // // // // // // // // // // // // // // // // // // //           u_resolution: { value: new Vector2(window.innerWidth, window.innerHeight) },\n// // // // // // // // // // // // // // // // // // // //           u_cameraPos: { value: new Vector3() },\n// // // // // // // // // // // // // // // // // // // //           u_blackHolePos: { value: new Vector3(0, 0, 0) },\n// // // // // // // // // // // // // // // // // // // //         },\n// // // // // // // // // // // // // // // // // // // //         vertexShader: `\n// // // // // // // // // // // // // // // // // // // //           varying vec3 vWorldPosition;\n// // // // // // // // // // // // // // // // // // // //           void main() {\n// // // // // // // // // // // // // // // // // // // //             vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n// // // // // // // // // // // // // // // // // // // //             gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n// // // // // // // // // // // // // // // // // // // //           }\n// // // // // // // // // // // // // // // // // // // //         `,\n// // // // // // // // // // // // // // // // // // // //         fragmentShader: `\n// // // // // // // // // // // // // // // // // // // //           varying vec3 vWorldPosition;\n// // // // // // // // // // // // // // // // // // // //           uniform vec3 u_cameraPos;\n// // // // // // // // // // // // // // // // // // // //           uniform vec3 u_blackHolePos;\n// // // // // // // // // // // // // // // // // // // //           void main() {\n// // // // // // // // // // // // // // // // // // // //             // Simplified gravitational lensing effect\n// // // // // // // // // // // // // // // // // // // //             vec3 dir = normalize(vWorldPosition - u_cameraPos);\n// // // // // // // // // // // // // // // // // // // //             float dist = length(vWorldPosition - u_blackHolePos);\n// // // // // // // // // // // // // // // // // // // //             float lensing = clamp(1.0 / (dist * dist * 100.0), 0.0, 1.0);\n// // // // // // // // // // // // // // // // // // // //             gl_FragColor = vec4(vec3(0.0), 1.0 - lensing);\n// // // // // // // // // // // // // // // // // // // //           }\n// // // // // // // // // // // // // // // // // // // //         `,\n// // // // // // // // // // // // // // // // // // // //         side: DoubleSide,\n// // // // // // // // // // // // // // // // // // // //       }),\n// // // // // // // // // // // // // // // // // // // //     []\n// // // // // // // // // // // // // // // // // // // //   );\n\n// // // // // // // // // // // // // // // // // // // //   useFrame(({ clock, camera }) => {\n// // // // // // // // // // // // // // // // // // // //     blackHoleMaterial.uniforms.u_time.value = clock.getElapsedTime();\n// // // // // // // // // // // // // // // // // // // //     blackHoleMaterial.uniforms.u_cameraPos.value.copy(camera.position);\n// // // // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // // // //   return (\n// // // // // // // // // // // // // // // // // // // //     <mesh ref={meshRef} material={blackHoleMaterial}>\n// // // // // // // // // // // // // // // // // // // //       <sphereGeometry args={[2, 64, 64]} />\n// // // // // // // // // // // // // // // // // // // //     </mesh>\n// // // // // // // // // // // // // // // // // // // //   );\n// // // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // // interface AccretionDiskProps {\n// // // // // // // // // // // // // // // // // // // //   blackHoleRadius: number;\n// // // // // // // // // // // // // // // // // // // //   capturedParticles: Float32Array;\n// // // // // // // // // // // // // // // // // // // //   capturedColors: Float32Array;\n// // // // // // // // // // // // // // // // // // // // }\n\n// // // // // // // // // // // // // // // // // // // // const AccretionDisk: React.FC<AccretionDiskProps> = ({ blackHoleRadius, capturedParticles, capturedColors }) => {\n// // // // // // // // // // // // // // // // // // // //   const particlesRef = useRef<Points>(null);\n// // // // // // // // // // // // // // // // // // // //   const initialParticleCount = 20000;\n\n// // // // // // // // // // // // // // // // // // // //   // Generate initial particles for the accretion disk\n// // // // // // // // // // // // // // // // // // // //   const { positions, colors } = useMemo(() => {\n// // // // // // // // // // // // // // // // // // // //     const positionsArray = new Float32Array(initialParticleCount * 3);\n// // // // // // // // // // // // // // // // // // // //     const colorsArray = new Float32Array(initialParticleCount * 3);\n\n// // // // // // // // // // // // // // // // // // // //     const innerRadius = blackHoleRadius + 0.2;\n// // // // // // // // // // // // // // // // // // // //     const outerRadius = blackHoleRadius + 5;\n\n// // // // // // // // // // // // // // // // // // // //     for (let i = 0; i < initialParticleCount; i++) {\n// // // // // // // // // // // // // // // // // // // //       // Generate a radius with higher density closer to the EH\n// // // // // // // // // // // // // // // // // // // //       const t = Math.random();\n// // // // // // // // // // // // // // // // // // // //       const radius = innerRadius + (1 - Math.pow(t, 2)) * (outerRadius - innerRadius);\n\n// // // // // // // // // // // // // // // // // // // //       const angle = Math.random() * 2 * Math.PI;\n\n// // // // // // // // // // // // // // // // // // // //       positionsArray[i * 3] = radius * Math.cos(angle);\n// // // // // // // // // // // // // // // // // // // //       positionsArray[i * 3 + 1] = (Math.random() - 0.5) * 0.2;\n// // // // // // // // // // // // // // // // // // // //       positionsArray[i * 3 + 2] = radius * Math.sin(angle);\n\n// // // // // // // // // // // // // // // // // // // //       // Color gradient\n// // // // // // // // // // // // // // // // // // // //       const normalizedRadius = (radius - innerRadius) / (outerRadius - innerRadius);\n// // // // // // // // // // // // // // // // // // // //       const color = new Color().setHSL(0.1 * (1 - normalizedRadius), 1.0, 0.5 + 0.5 * (1 - normalizedRadius));\n// // // // // // // // // // // // // // // // // // // //       colorsArray[i * 3] = color.r;\n// // // // // // // // // // // // // // // // // // // //       colorsArray[i * 3 + 1] = color.g;\n// // // // // // // // // // // // // // // // // // // //       colorsArray[i * 3 + 2] = color.b;\n// // // // // // // // // // // // // // // // // // // //     }\n\n// // // // // // // // // // // // // // // // // // // //     return { positions: positionsArray, colors: colorsArray };\n// // // // // // // // // // // // // // // // // // // //   }, [initialParticleCount, blackHoleRadius]);\n\n// // // // // // // // // // // // // // // // // // // //   // Combine initial particles with captured particles\n// // // // // // // // // // // // // // // // // // // //   const [particleGeometry] = useState(() => {\n// // // // // // // // // // // // // // // // // // // //     const geom = new BufferGeometry();\n// // // // // // // // // // // // // // // // // // // //     geom.setAttribute('position', new BufferAttribute(positions, 3));\n// // // // // // // // // // // // // // // // // // // //     geom.setAttribute('color', new BufferAttribute(colors, 3));\n// // // // // // // // // // // // // // // // // // // //     return geom;\n// // // // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // // // //   useFrame(() => {\n// // // // // // // // // // // // // // // // // // // //     if (capturedParticles.length > 0) {\n// // // // // // // // // // // // // // // // // // // //       // Merge captured particles into the accretion disk\n// // // // // // // // // // // // // // // // // // // //       const currentPositions = particleGeometry.attributes.position.array as Float32Array;\n// // // // // // // // // // // // // // // // // // // //       const currentColors = particleGeometry.attributes.color.array as Float32Array;\n\n// // // // // // // // // // // // // // // // // // // //       const newParticleCount = capturedParticles.length / 3;\n// // // // // // // // // // // // // // // // // // // //       const totalParticles = currentPositions.length / 3 + newParticleCount;\n\n// // // // // // // // // // // // // // // // // // // //       const mergedPositions = new Float32Array(totalParticles * 3);\n// // // // // // // // // // // // // // // // // // // //       const mergedColors = new Float32Array(totalParticles * 3);\n\n// // // // // // // // // // // // // // // // // // // //       mergedPositions.set(currentPositions);\n// // // // // // // // // // // // // // // // // // // //       mergedPositions.set(capturedParticles, currentPositions.length);\n// // // // // // // // // // // // // // // // // // // //       mergedColors.set(currentColors);\n// // // // // // // // // // // // // // // // // // // //       mergedColors.set(capturedColors, currentColors.length);\n\n// // // // // // // // // // // // // // // // // // // //       particleGeometry.setAttribute('position', new BufferAttribute(mergedPositions, 3));\n// // // // // // // // // // // // // // // // // // // //       particleGeometry.setAttribute('color', new BufferAttribute(mergedColors, 3));\n\n// // // // // // // // // // // // // // // // // // // //       // Clear captured particles\n// // // // // // // // // // // // // // // // // // // //       capturedParticles.length = 0;\n// // // // // // // // // // // // // // // // // // // //       capturedColors.length = 0;\n// // // // // // // // // // // // // // // // // // // //     }\n\n// // // // // // // // // // // // // // // // // // // //     if (particlesRef.current) {\n// // // // // // // // // // // // // // // // // // // //       particlesRef.current.rotation.y += 0.002; // Slow rotation\n// // // // // // // // // // // // // // // // // // // //     }\n// // // // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // // // //   const particleMaterial = useMemo(\n// // // // // // // // // // // // // // // // // // // //     () =>\n// // // // // // // // // // // // // // // // // // // //       new PointsMaterial({\n// // // // // // // // // // // // // // // // // // // //         size: 0.05,\n// // // // // // // // // // // // // // // // // // // //         vertexColors: true,\n// // // // // // // // // // // // // // // // // // // //         blending: AdditiveBlending,\n// // // // // // // // // // // // // // // // // // // //         transparent: true,\n// // // // // // // // // // // // // // // // // // // //       }),\n// // // // // // // // // // // // // // // // // // // //     []\n// // // // // // // // // // // // // // // // // // // //   );\n\n// // // // // // // // // // // // // // // // // // // //   return <points ref={particlesRef} geometry={particleGeometry} material={particleMaterial} />;\n// // // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // // interface StarProps {\n// // // // // // // // // // // // // // // // // // // //   positionRef: React.MutableRefObject<Vector3>;\n// // // // // // // // // // // // // // // // // // // //   blackHoleRadius: number;\n// // // // // // // // // // // // // // // // // // // // }\n\n// // // // // // // // // // // // // // // // // // // // const Star: React.FC<StarProps> = ({ positionRef, blackHoleRadius }) => {\n// // // // // // // // // // // // // // // // // // // //   const starRef = useRef<Mesh>(null);\n\n// // // // // // // // // // // // // // // // // // // //   useFrame(({ clock }) => {\n// // // // // // // // // // // // // // // // // // // //     if (starRef.current) {\n// // // // // // // // // // // // // // // // // // // //       const t = clock.getElapsedTime();\n\n// // // // // // // // // // // // // // // // // // // //       // Decaying orbit parameters\n// // // // // // // // // // // // // // // // // // // //       const initialRadius = 10;\n// // // // // // // // // // // // // // // // // // // //       const decayRate = 0.05;\n\n// // // // // // // // // // // // // // // // // // // //       const radius = Math.max(blackHoleRadius, initialRadius - decayRate * t);\n// // // // // // // // // // // // // // // // // // // //       const angularSpeed = 0.8;\n\n// // // // // // // // // // // // // // // // // // // //       const angle = angularSpeed * t;\n\n// // // // // // // // // // // // // // // // // // // //       // Convert polar to Cartesian coordinates\n// // // // // // // // // // // // // // // // // // // //       const x = radius * Math.cos(angle);\n// // // // // // // // // // // // // // // // // // // //       const z = radius * Math.sin(angle);\n\n// // // // // // // // // // // // // // // // // // // //       starRef.current.position.set(x, 0, z);\n\n// // // // // // // // // // // // // // // // // // // //       // Update the shared positionRef\n// // // // // // // // // // // // // // // // // // // //       positionRef.current.copy(starRef.current.position);\n\n// // // // // // // // // // // // // // // // // // // //       // Calculate scale based on distance to black hole\n// // // // // // // // // // // // // // // // // // // //       const distanceToBH = radius - blackHoleRadius;\n// // // // // // // // // // // // // // // // // // // //       const initialScale = 1.0;\n// // // // // // // // // // // // // // // // // // // //       const scale = (distanceToBH / (initialRadius - blackHoleRadius)) * initialScale;\n// // // // // // // // // // // // // // // // // // // //       starRef.current.scale.set(scale, scale, scale);\n// // // // // // // // // // // // // // // // // // // //     }\n// // // // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // // // //   return (\n// // // // // // // // // // // // // // // // // // // //     <mesh ref={starRef}>\n// // // // // // // // // // // // // // // // // // // //       <sphereGeometry args={[1.5, 32, 32]} />\n// // // // // // // // // // // // // // // // // // // //       <meshStandardMaterial\n// // // // // // // // // // // // // // // // // // // //         color=\"#ffff00\"\n// // // // // // // // // // // // // // // // // // // //         emissive=\"#ffff00\"\n// // // // // // // // // // // // // // // // // // // //         emissiveIntensity={2}\n// // // // // // // // // // // // // // // // // // // //       />\n// // // // // // // // // // // // // // // // // // // //     </mesh>\n// // // // // // // // // // // // // // // // // // // //   );\n// // // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // // interface ParticleSystemProps {\n// // // // // // // // // // // // // // // // // // // //   starPositionRef: React.MutableRefObject<Vector3>;\n// // // // // // // // // // // // // // // // // // // //   blackHoleRadius: number;\n// // // // // // // // // // // // // // // // // // // //   capturedParticlesRef: React.MutableRefObject<Float32Array>;\n// // // // // // // // // // // // // // // // // // // //   capturedColorsRef: React.MutableRefObject<Float32Array>;\n// // // // // // // // // // // // // // // // // // // // }\n\n// // // // // // // // // // // // // // // // // // // // const ParticleSystem: React.FC<ParticleSystemProps> = ({\n// // // // // // // // // // // // // // // // // // // //   starPositionRef,\n// // // // // // // // // // // // // // // // // // // //   blackHoleRadius,\n// // // // // // // // // // // // // // // // // // // //   capturedParticlesRef,\n// // // // // // // // // // // // // // // // // // // //   capturedColorsRef,\n// // // // // // // // // // // // // // // // // // // // }) => {\n// // // // // // // // // // // // // // // // // // // //   const particlesRef = useRef<Points>(null);\n\n// // // // // // // // // // // // // // // // // // // //   const particleCount = 5000;\n// // // // // // // // // // // // // // // // // // // //   const positions = useRef<Float32Array>(new Float32Array(particleCount * 3));\n// // // // // // // // // // // // // // // // // // // //   const velocities = useRef<Float32Array>(new Float32Array(particleCount * 3));\n\n// // // // // // // // // // // // // // // // // // // //   // Initialize particles only once\n// // // // // // // // // // // // // // // // // // // //   // eslint-disable-next-line react-hooks/exhaustive-deps\n// // // // // // // // // // // // // // // // // // // //   useEffect(() => {\n// // // // // // // // // // // // // // // // // // // //     for (let i = 0; i < particleCount; i += 1) {\n// // // // // // // // // // // // // // // // // // // //       positions.current[i * 3] = starPositionRef.current.x;\n// // // // // // // // // // // // // // // // // // // //       positions.current[i * 3 + 1] = starPositionRef.current.y;\n// // // // // // // // // // // // // // // // // // // //       positions.current[i * 3 + 2] = starPositionRef.current.z;\n\n// // // // // // // // // // // // // // // // // // // //       velocities.current[i * 3] = -(Math.random() * 0.02 + 0.01);\n// // // // // // // // // // // // // // // // // // // //       velocities.current[i * 3 + 1] = (Math.random() - 0.5) * 0.02;\n// // // // // // // // // // // // // // // // // // // //       velocities.current[i * 3 + 2] = (Math.random() - 0.5) * 0.02;\n// // // // // // // // // // // // // // // // // // // //     }\n// // // // // // // // // // // // // // // // // // // //   }, []);\n\n// // // // // // // // // // // // // // // // // // // //   const particleGeometry = useMemo(() => {\n// // // // // // // // // // // // // // // // // // // //     const geom = new BufferGeometry();\n// // // // // // // // // // // // // // // // // // // //     geom.setAttribute('position', new BufferAttribute(positions.current, 3));\n// // // // // // // // // // // // // // // // // // // //     return geom;\n// // // // // // // // // // // // // // // // // // // //   }, []);\n\n// // // // // // // // // // // // // // // // // // // //   const particleMaterial = useMemo(\n// // // // // // // // // // // // // // // // // // // //     () =>\n// // // // // // // // // // // // // // // // // // // //       new PointsMaterial({\n// // // // // // // // // // // // // // // // // // // //         color: '#ffa500',\n// // // // // // // // // // // // // // // // // // // //         size: 0.1,\n// // // // // // // // // // // // // // // // // // // //         blending: AdditiveBlending,\n// // // // // // // // // // // // // // // // // // // //         transparent: true,\n// // // // // // // // // // // // // // // // // // // //       }),\n// // // // // // // // // // // // // // // // // // // //     []\n// // // // // // // // // // // // // // // // // // // //   );\n\n// // // // // // // // // // // // // // // // // // // //   useFrame(() => {\n// // // // // // // // // // // // // // // // // // // //     const posArray = particleGeometry.attributes.position.array as Float32Array;\n\n// // // // // // // // // // // // // // // // // // // //     for (let i = 0; i < particleCount; i += 1) {\n// // // // // // // // // // // // // // // // // // // //       // Update positions based on velocities\n// // // // // // // // // // // // // // // // // // // //       posArray[i * 3] += velocities.current[i * 3];\n// // // // // // // // // // // // // // // // // // // //       posArray[i * 3 + 1] += velocities.current[i * 3 + 1];\n// // // // // // // // // // // // // // // // // // // //       posArray[i * 3 + 2] += velocities.current[i * 3 + 2];\n\n// // // // // // // // // // // // // // // // // // // //       // Compute distance to black hole\n// // // // // // // // // // // // // // // // // // // //       const dx = posArray[i * 3];\n// // // // // // // // // // // // // // // // // // // //       const dy = posArray[i * 3 + 1];\n// // // // // // // // // // // // // // // // // // // //       const dz = posArray[i * 3 + 2];\n// // // // // // // // // // // // // // // // // // // //       const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n// // // // // // // // // // // // // // // // // // // //       // Simple gravity towards the black hole\n// // // // // // // // // // // // // // // // // // // //       const force = (0.02 / dist) * 0.1;\n// // // // // // // // // // // // // // // // // // // //       velocities.current[i * 3] += (-dx / dist) * force;\n// // // // // // // // // // // // // // // // // // // //       velocities.current[i * 3 + 1] += (-dy / dist) * force;\n// // // // // // // // // // // // // // // // // // // //       velocities.current[i * 3 + 2] += (-dz / dist) * force;\n\n// // // // // // // // // // // // // // // // // // // //       // Check if particle should be captured into accretion disk\n// // // // // // // // // // // // // // // // // // // //       if (dist < blackHoleRadius + 5 && dist > blackHoleRadius + 0.2) {\n// // // // // // // // // // // // // // // // // // // //         // Particle is in the accretion disk zone\n// // // // // // // // // // // // // // // // // // // //         const captureChance = 0.02; // Adjust this value to control capture rate\n// // // // // // // // // // // // // // // // // // // //         if (Math.random() < captureChance) {\n// // // // // // // // // // // // // // // // // // // //           // Capture particle\n// // // // // // // // // // // // // // // // // // // //           const capturedPosition = new Float32Array(3);\n// // // // // // // // // // // // // // // // // // // //           capturedPosition[0] = posArray[i * 3];\n// // // // // // // // // // // // // // // // // // // //           capturedPosition[1] = posArray[i * 3 + 1];\n// // // // // // // // // // // // // // // // // // // //           capturedPosition[2] = posArray[i * 3 + 2];\n// // // // // // // // // // // // // // // // // // // //           capturedParticlesRef.current = Float32Array.from([\n// // // // // // // // // // // // // // // // // // // //             ...capturedParticlesRef.current,\n// // // // // // // // // // // // // // // // // // // //             ...capturedPosition,\n// // // // // // // // // // // // // // // // // // // //           ]);\n\n// // // // // // // // // // // // // // // // // // // //           // Assign color based on position\n// // // // // // // // // // // // // // // // // // // //           const normalizedRadius = (dist - (blackHoleRadius + 0.2)) / (5 - 0.2);\n// // // // // // // // // // // // // // // // // // // //           const color = new Color().setHSL(0.1 * (1 - normalizedRadius), 1.0, 0.5 + 0.5 * (1 - normalizedRadius));\n// // // // // // // // // // // // // // // // // // // //           const capturedColor = new Float32Array([color.r, color.g, color.b]);\n// // // // // // // // // // // // // // // // // // // //           capturedColorsRef.current = Float32Array.from([\n// // // // // // // // // // // // // // // // // // // //             ...capturedColorsRef.current,\n// // // // // // // // // // // // // // // // // // // //             ...capturedColor,\n// // // // // // // // // // // // // // // // // // // //           ]);\n\n// // // // // // // // // // // // // // // // // // // //           // Remove particle from particle system by resetting it\n// // // // // // // // // // // // // // // // // // // //           posArray[i * 3] = starPositionRef.current.x;\n// // // // // // // // // // // // // // // // // // // //           posArray[i * 3 + 1] = starPositionRef.current.y;\n// // // // // // // // // // // // // // // // // // // //           posArray[i * 3 + 2] = starPositionRef.current.z;\n\n// // // // // // // // // // // // // // // // // // // //           velocities.current[i * 3] = -(Math.random() * 0.02 + 0.01);\n// // // // // // // // // // // // // // // // // // // //           velocities.current[i * 3 + 1] = (Math.random() - 0.5) * 0.02;\n// // // // // // // // // // // // // // // // // // // //           velocities.current[i * 3 + 2] = (Math.random() - 0.5) * 0.02;\n\n// // // // // // // // // // // // // // // // // // // //           continue; // Skip further processing for this particle\n// // // // // // // // // // // // // // // // // // // //         }\n// // // // // // // // // // // // // // // // // // // //       }\n\n// // // // // // // // // // // // // // // // // // // //       // Reset particle if it's too close to the black hole\n// // // // // // // // // // // // // // // // // // // //       if (dist < blackHoleRadius) {\n// // // // // // // // // // // // // // // // // // // //         posArray[i * 3] = starPositionRef.current.x;\n// // // // // // // // // // // // // // // // // // // //         posArray[i * 3 + 1] = starPositionRef.current.y;\n// // // // // // // // // // // // // // // // // // // //         posArray[i * 3 + 2] = starPositionRef.current.z;\n\n// // // // // // // // // // // // // // // // // // // //         velocities.current[i * 3] = -(Math.random() * 0.02 + 0.01);\n// // // // // // // // // // // // // // // // // // // //         velocities.current[i * 3 + 1] = (Math.random() - 0.5) * 0.02;\n// // // // // // // // // // // // // // // // // // // //         velocities.current[i * 3 + 2] = (Math.random() - 0.5) * 0.02;\n// // // // // // // // // // // // // // // // // // // //       }\n// // // // // // // // // // // // // // // // // // // //     }\n\n// // // // // // // // // // // // // // // // // // // //     particleGeometry.attributes.position.needsUpdate = true;\n// // // // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // // // //   return <points ref={particlesRef} geometry={particleGeometry} material={particleMaterial} />;\n// // // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // // const BlackHoleScene: React.FC = () => {\n// // // // // // // // // // // // // // // // // // // //   const starPositionRef = useRef<Vector3>(new Vector3(10, 0, 0));\n// // // // // // // // // // // // // // // // // // // //   const blackHoleRadius = 2;\n\n// // // // // // // // // // // // // // // // // // // //   const capturedParticlesRef = useRef<Float32Array>(new Float32Array());\n// // // // // // // // // // // // // // // // // // // //   const capturedColorsRef = useRef<Float32Array>(new Float32Array());\n\n// // // // // // // // // // // // // // // // // // // //   return (\n// // // // // // // // // // // // // // // // // // // //     <Canvas\n// // // // // // // // // // // // // // // // // // // //       style={{ width: '100vw', height: '100vh', background: '#000000' }}\n// // // // // // // // // // // // // // // // // // // //       camera={{ position: [0, 5, 25], fov: 60 }}\n// // // // // // // // // // // // // // // // // // // //     >\n// // // // // // // // // // // // // // // // // // // //       <ambientLight intensity={0.2} />\n// // // // // // // // // // // // // // // // // // // //       <pointLight position={[0, 0, 0]} intensity={1} color=\"#ffffff\" />\n// // // // // // // // // // // // // // // // // // // //       <ErrorBoundary>\n// // // // // // // // // // // // // // // // // // // //         <BlackHole />\n// // // // // // // // // // // // // // // // // // // //         <AccretionDisk\n// // // // // // // // // // // // // // // // // // // //           blackHoleRadius={blackHoleRadius}\n// // // // // // // // // // // // // // // // // // // //           capturedParticles={capturedParticlesRef.current}\n// // // // // // // // // // // // // // // // // // // //           capturedColors={capturedColorsRef.current}\n// // // // // // // // // // // // // // // // // // // //         />\n// // // // // // // // // // // // // // // // // // // //         <Star positionRef={starPositionRef} blackHoleRadius={blackHoleRadius} />\n// // // // // // // // // // // // // // // // // // // //         <ParticleSystem\n// // // // // // // // // // // // // // // // // // // //           starPositionRef={starPositionRef}\n// // // // // // // // // // // // // // // // // // // //           blackHoleRadius={blackHoleRadius}\n// // // // // // // // // // // // // // // // // // // //           capturedParticlesRef={capturedParticlesRef}\n// // // // // // // // // // // // // // // // // // // //           capturedColorsRef={capturedColorsRef}\n// // // // // // // // // // // // // // // // // // // //         />\n// // // // // // // // // // // // // // // // // // // //       </ErrorBoundary>\n// // // // // // // // // // // // // // // // // // // //       <EffectComposer>\n// // // // // // // // // // // // // // // // // // // //         <Bloom\n// // // // // // // // // // // // // // // // // // // //           luminanceThreshold={0.5}\n// // // // // // // // // // // // // // // // // // // //           luminanceSmoothing={0.1}\n// // // // // // // // // // // // // // // // // // // //           intensity={1.5}\n// // // // // // // // // // // // // // // // // // // //           height={300}\n// // // // // // // // // // // // // // // // // // // //         />\n// // // // // // // // // // // // // // // // // // // //       </EffectComposer>\n// // // // // // // // // // // // // // // // // // // //       <Controls />\n// // // // // // // // // // // // // // // // // // // //     </Canvas>\n// // // // // // // // // // // // // // // // // // // //   );\n// // // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // // export default BlackHoleScene;\n\n\n// // // // // // // // // // // // // // // // // // // // BlackHoleScene.tsx\n\n// // // // // // // // // // // // // // // // // // // import React, { useState, useEffect, useRef, useMemo } from 'react';\n// // // // // // // // // // // // // // // // // // // import {\n// // // // // // // // // // // // // // // // // // //   ShaderMaterial,\n// // // // // // // // // // // // // // // // // // //   Vector2,\n// // // // // // // // // // // // // // // // // // //   AdditiveBlending,\n// // // // // // // // // // // // // // // // // // //   Mesh,\n// // // // // // // // // // // // // // // // // // //   Points,\n// // // // // // // // // // // // // // // // // // //   BufferGeometry,\n// // // // // // // // // // // // // // // // // // //   BufferAttribute,\n// // // // // // // // // // // // // // // // // // //   PointsMaterial,\n// // // // // // // // // // // // // // // // // // //   Color,\n// // // // // // // // // // // // // // // // // // //   Vector3,\n// // // // // // // // // // // // // // // // // // //   DoubleSide,\n// // // // // // // // // // // // // // // // // // // } from 'three';\n// // // // // // // // // // // // // // // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // // // // // // // // // // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // // // // // // // // // // // // // // // import { EffectComposer, Bloom } from '@react-three/postprocessing';\n// // // // // // // // // // // // // // // // // // // import ErrorBoundary from './errorBoundary';\n\n// // // // // // // // // // // // // // // // // // // extend({ OrbitControls });\n\n// // // // // // // // // // // // // // // // // // // const Controls = () => {\n// // // // // // // // // // // // // // // // // // //   const { camera, gl } = useThree();\n// // // // // // // // // // // // // // // // // // //   const controlsRef = useRef<any>(null);\n\n// // // // // // // // // // // // // // // // // // //   useEffect(() => {\n// // // // // // // // // // // // // // // // // // //     controlsRef.current = new OrbitControls(camera, gl.domElement);\n// // // // // // // // // // // // // // // // // // //     controlsRef.current.enableDamping = true;\n// // // // // // // // // // // // // // // // // // //     return () => {\n// // // // // // // // // // // // // // // // // // //       controlsRef.current.dispose();\n// // // // // // // // // // // // // // // // // // //     };\n// // // // // // // // // // // // // // // // // // //   }, [camera, gl]);\n\n// // // // // // // // // // // // // // // // // // //   useFrame(() => {\n// // // // // // // // // // // // // // // // // // //     controlsRef.current.update();\n// // // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // // //   return null;\n// // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // const BlackHole = () => {\n// // // // // // // // // // // // // // // // // // //   const meshRef = useRef<Mesh>(null);\n\n// // // // // // // // // // // // // // // // // // //   // Custom shader material for the black hole with gravitational lensing\n// // // // // // // // // // // // // // // // // // //   const blackHoleMaterial = useMemo(\n// // // // // // // // // // // // // // // // // // //     () =>\n// // // // // // // // // // // // // // // // // // //       new ShaderMaterial({\n// // // // // // // // // // // // // // // // // // //         uniforms: {\n// // // // // // // // // // // // // // // // // // //           u_time: { value: 0 },\n// // // // // // // // // // // // // // // // // // //           u_resolution: { value: new Vector2(window.innerWidth, window.innerHeight) },\n// // // // // // // // // // // // // // // // // // //           u_cameraPos: { value: new Vector3() }, // Initialize with default value\n// // // // // // // // // // // // // // // // // // //           u_blackHolePos: { value: new Vector3(0, 0, 0) },\n// // // // // // // // // // // // // // // // // // //         },\n// // // // // // // // // // // // // // // // // // //         vertexShader: `\n// // // // // // // // // // // // // // // // // // //           varying vec3 vWorldPosition;\n// // // // // // // // // // // // // // // // // // //           void main() {\n// // // // // // // // // // // // // // // // // // //             vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n// // // // // // // // // // // // // // // // // // //             gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n// // // // // // // // // // // // // // // // // // //           }\n// // // // // // // // // // // // // // // // // // //         `,\n// // // // // // // // // // // // // // // // // // //         fragmentShader: `\n// // // // // // // // // // // // // // // // // // //           varying vec3 vWorldPosition;\n// // // // // // // // // // // // // // // // // // //           uniform vec3 u_cameraPos;\n// // // // // // // // // // // // // // // // // // //           uniform vec3 u_blackHolePos;\n// // // // // // // // // // // // // // // // // // //           void main() {\n// // // // // // // // // // // // // // // // // // //             // Simplified gravitational lensing effect\n// // // // // // // // // // // // // // // // // // //             vec3 dir = normalize(vWorldPosition - u_cameraPos);\n// // // // // // // // // // // // // // // // // // //             float dist = length(vWorldPosition - u_blackHolePos);\n// // // // // // // // // // // // // // // // // // //             float lensing = clamp(1.0 / (dist * dist * 100.0), 0.0, 1.0);\n// // // // // // // // // // // // // // // // // // //             gl_FragColor = vec4(vec3(0.0), 1.0 - lensing);\n// // // // // // // // // // // // // // // // // // //           }\n// // // // // // // // // // // // // // // // // // //         `,\n// // // // // // // // // // // // // // // // // // //         side: DoubleSide,\n// // // // // // // // // // // // // // // // // // //       }),\n// // // // // // // // // // // // // // // // // // //     []\n// // // // // // // // // // // // // // // // // // //   );\n\n// // // // // // // // // // // // // // // // // // //   useFrame(({ clock, camera }) => {\n// // // // // // // // // // // // // // // // // // //     blackHoleMaterial.uniforms.u_time.value = clock.getElapsedTime();\n// // // // // // // // // // // // // // // // // // //     blackHoleMaterial.uniforms.u_cameraPos.value.copy(camera.position);\n// // // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // // //   return (\n// // // // // // // // // // // // // // // // // // //     <mesh ref={meshRef} material={blackHoleMaterial}>\n// // // // // // // // // // // // // // // // // // //       <sphereGeometry args={[2, 64, 64]} />\n// // // // // // // // // // // // // // // // // // //     </mesh>\n// // // // // // // // // // // // // // // // // // //   );\n// // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // interface AccretionDiskProps {\n// // // // // // // // // // // // // // // // // // //   blackHoleRadius: number;\n// // // // // // // // // // // // // // // // // // // }\n\n// // // // // // // // // // // // // // // // // // // const AccretionDisk: React.FC<AccretionDiskProps> = ({ blackHoleRadius }) => {\n// // // // // // // // // // // // // // // // // // //   const particlesRef = useRef<Points>(null);\n// // // // // // // // // // // // // // // // // // //   const particleCount = 20000; // Increased for smoother density gradient\n\n// // // // // // // // // // // // // // // // // // //   // Generate positions, colors, and activation times for particles in a disk shape\n// // // // // // // // // // // // // // // // // // //   const { positions, colors, activationTimes } = useMemo(() => {\n// // // // // // // // // // // // // // // // // // //     const positionsArray = new Float32Array(particleCount * 3);\n// // // // // // // // // // // // // // // // // // //     const colorsArray = new Float32Array(particleCount * 3);\n// // // // // // // // // // // // // // // // // // //     const activationTimesArray = new Float32Array(particleCount);\n\n// // // // // // // // // // // // // // // // // // //     const innerRadius = blackHoleRadius + 0.2;\n// // // // // // // // // // // // // // // // // // //     const outerRadius = blackHoleRadius + 5;\n\n// // // // // // // // // // // // // // // // // // //     for (let i = 0; i < particleCount; i++) {\n// // // // // // // // // // // // // // // // // // //       // Generate a radius with higher density closer to the EH\n// // // // // // // // // // // // // // // // // // //       const t = Math.random();\n// // // // // // // // // // // // // // // // // // //       const radius = innerRadius + (1 - t ** 2) * (outerRadius - innerRadius);\n\n// // // // // // // // // // // // // // // // // // //       const angle = Math.random() * 2 * Math.PI;\n\n// // // // // // // // // // // // // // // // // // //       positionsArray[i * 3] = radius * Math.cos(angle);\n// // // // // // // // // // // // // // // // // // //       positionsArray[i * 3 + 1] = (Math.random() - 0.5) * 0.2; // Slight vertical spread\n// // // // // // // // // // // // // // // // // // //       positionsArray[i * 3 + 2] = radius * Math.sin(angle);\n\n// // // // // // // // // // // // // // // // // // //       // Color gradient from white (hot) near black hole to orange (cooler) outward\n// // // // // // // // // // // // // // // // // // //       const normalizedRadius = (radius - innerRadius) / (outerRadius - innerRadius);\n// // // // // // // // // // // // // // // // // // //       const color = new Color().setHSL(0.1 * (1 - normalizedRadius), 1.0, 0.5 + 0.5 * (1 - normalizedRadius));\n// // // // // // // // // // // // // // // // // // //       colorsArray[i * 3] = color.r;\n// // // // // // // // // // // // // // // // // // //       colorsArray[i * 3 + 1] = color.g;\n// // // // // // // // // // // // // // // // // // //       colorsArray[i * 3 + 2] = color.b;\n\n// // // // // // // // // // // // // // // // // // //       // Assign activation times to build up the disk over time\n// // // // // // // // // // // // // // // // // // //       activationTimesArray[i] = normalizedRadius * 10; // Particles closer to EH activate earlier\n// // // // // // // // // // // // // // // // // // //     }\n\n// // // // // // // // // // // // // // // // // // //     return { positions: positionsArray, colors: colorsArray, activationTimes: activationTimesArray };\n// // // // // // // // // // // // // // // // // // //   }, [particleCount, blackHoleRadius]);\n\n// // // // // // // // // // // // // // // // // // //   const particleGeometry = useMemo(() => {\n// // // // // // // // // // // // // // // // // // //     const geom = new BufferGeometry();\n// // // // // // // // // // // // // // // // // // //     geom.setAttribute('position', new BufferAttribute(positions, 3));\n// // // // // // // // // // // // // // // // // // //     geom.setAttribute('color', new BufferAttribute(colors, 3));\n// // // // // // // // // // // // // // // // // // //     geom.setAttribute('activationTime', new BufferAttribute(activationTimes, 1));\n// // // // // // // // // // // // // // // // // // //     return geom;\n// // // // // // // // // // // // // // // // // // //   }, [positions, colors, activationTimes]);\n\n// // // // // // // // // // // // // // // // // // //   const particleMaterial = useMemo(\n// // // // // // // // // // // // // // // // // // //     () =>\n// // // // // // // // // // // // // // // // // // //       new ShaderMaterial({\n// // // // // // // // // // // // // // // // // // //         uniforms: {\n// // // // // // // // // // // // // // // // // // //           u_time: { value: 0 },\n// // // // // // // // // // // // // // // // // // //         },\n// // // // // // // // // // // // // // // // // // //         vertexShader: `\n// // // // // // // // // // // // // // // // // // //           attribute float activationTime;\n// // // // // // // // // // // // // // // // // // //           varying float vOpacity;\n// // // // // // // // // // // // // // // // // // //           void main() {\n// // // // // // // // // // // // // // // // // // //             if (activationTime <= u_time) {\n// // // // // // // // // // // // // // // // // // //               vOpacity = 1.0;\n// // // // // // // // // // // // // // // // // // //             } else {\n// // // // // // // // // // // // // // // // // // //               vOpacity = 0.0;\n// // // // // // // // // // // // // // // // // // //             }\n// // // // // // // // // // // // // // // // // // //             gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n// // // // // // // // // // // // // // // // // // //             gl_PointSize = ${window.devicePixelRatio} * 0.5;\n// // // // // // // // // // // // // // // // // // //           }\n// // // // // // // // // // // // // // // // // // //         `,\n// // // // // // // // // // // // // // // // // // //         fragmentShader: `\n// // // // // // // // // // // // // // // // // // //           varying float vOpacity;\n// // // // // // // // // // // // // // // // // // //           varying vec3 vColor;\n// // // // // // // // // // // // // // // // // // //           void main() {\n// // // // // // // // // // // // // // // // // // //             gl_FragColor = vec4(vColor, vOpacity);\n// // // // // // // // // // // // // // // // // // //           }\n// // // // // // // // // // // // // // // // // // //         `,\n// // // // // // // // // // // // // // // // // // //         transparent: true,\n// // // // // // // // // // // // // // // // // // //         vertexColors: true,\n// // // // // // // // // // // // // // // // // // //         blending: AdditiveBlending,\n// // // // // // // // // // // // // // // // // // //       }),\n// // // // // // // // // // // // // // // // // // //     []\n// // // // // // // // // // // // // // // // // // //   );\n\n// // // // // // // // // // // // // // // // // // //   useFrame(({ clock }) => {\n// // // // // // // // // // // // // // // // // // //     particleMaterial.uniforms.u_time.value = clock.getElapsedTime();\n// // // // // // // // // // // // // // // // // // //     if (particlesRef.current) {\n// // // // // // // // // // // // // // // // // // //       particlesRef.current.rotation.y += 0.002; // Slow rotation\n// // // // // // // // // // // // // // // // // // //     }\n// // // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // // //   return (\n// // // // // // // // // // // // // // // // // // //     <points ref={particlesRef} geometry={particleGeometry} material={particleMaterial} />\n// // // // // // // // // // // // // // // // // // //   );\n// // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // interface StarProps {\n// // // // // // // // // // // // // // // // // // //   positionRef: React.MutableRefObject<Vector3>;\n// // // // // // // // // // // // // // // // // // //   blackHoleRadius: number;\n// // // // // // // // // // // // // // // // // // // }\n\n// // // // // // // // // // // // // // // // // // // const Star: React.FC<StarProps> = ({ positionRef, blackHoleRadius }) => {\n// // // // // // // // // // // // // // // // // // //   const starRef = useRef<Mesh>(null);\n\n// // // // // // // // // // // // // // // // // // //   useFrame(({ clock }) => {\n// // // // // // // // // // // // // // // // // // //     if (starRef.current) {\n// // // // // // // // // // // // // // // // // // //       const t = clock.getElapsedTime();\n\n// // // // // // // // // // // // // // // // // // //       // Decaying orbit parameters\n// // // // // // // // // // // // // // // // // // //       const initialRadius = 10;\n// // // // // // // // // // // // // // // // // // //       const decayRate = 0.05; // Adjust for slower decay\n\n// // // // // // // // // // // // // // // // // // //       const radius = Math.max(blackHoleRadius, initialRadius - decayRate * t);\n// // // // // // // // // // // // // // // // // // //       const angularSpeed = 0.8; // Adjust for slower orbit\n\n// // // // // // // // // // // // // // // // // // //       const angle = angularSpeed * t;\n\n// // // // // // // // // // // // // // // // // // //       // Convert polar to Cartesian coordinates\n// // // // // // // // // // // // // // // // // // //       const x = radius * Math.cos(angle);\n// // // // // // // // // // // // // // // // // // //       const z = radius * Math.sin(angle);\n\n// // // // // // // // // // // // // // // // // // //       starRef.current.position.set(x, 0, z);\n\n// // // // // // // // // // // // // // // // // // //       // Update the shared positionRef\n// // // // // // // // // // // // // // // // // // //       positionRef.current.copy(starRef.current.position);\n\n// // // // // // // // // // // // // // // // // // //       // Calculate scale based on distance to black hole\n// // // // // // // // // // // // // // // // // // //       const distanceToBH = radius - blackHoleRadius;\n// // // // // // // // // // // // // // // // // // //       const initialScale = 1.0;\n// // // // // // // // // // // // // // // // // // //       const scale = (distanceToBH / (initialRadius - blackHoleRadius)) * initialScale;\n// // // // // // // // // // // // // // // // // // //       starRef.current.scale.set(scale, scale, scale);\n// // // // // // // // // // // // // // // // // // //     }\n// // // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // // //   return (\n// // // // // // // // // // // // // // // // // // //     <mesh ref={starRef}>\n// // // // // // // // // // // // // // // // // // //       <sphereGeometry args={[1.5, 32, 32]} />\n// // // // // // // // // // // // // // // // // // //       <meshStandardMaterial\n// // // // // // // // // // // // // // // // // // //         color=\"#ffff00\"\n// // // // // // // // // // // // // // // // // // //         emissive=\"#ffff00\"\n// // // // // // // // // // // // // // // // // // //         emissiveIntensity={2} // Increased intensity for bloom effect\n// // // // // // // // // // // // // // // // // // //       />\n// // // // // // // // // // // // // // // // // // //     </mesh>\n// // // // // // // // // // // // // // // // // // //   );\n// // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // interface ParticleSystemProps {\n// // // // // // // // // // // // // // // // // // //   starPositionRef: React.MutableRefObject<Vector3>;\n// // // // // // // // // // // // // // // // // // // }\n\n// // // // // // // // // // // // // // // // // // // const ParticleSystem: React.FC<ParticleSystemProps> = ({ starPositionRef }) => {\n// // // // // // // // // // // // // // // // // // //   const particlesRef = useRef<Points>(null);\n\n// // // // // // // // // // // // // // // // // // //   const particleCount = 5000;\n// // // // // // // // // // // // // // // // // // //   const positions = useRef<Float32Array>(new Float32Array(particleCount * 3));\n// // // // // // // // // // // // // // // // // // //   const velocities = useRef<Float32Array>(new Float32Array(particleCount * 3));\n\n// // // // // // // // // // // // // // // // // // //   // Initialize particles only once\n// // // // // // // // // // // // // // // // // // //   // eslint-disable-next-line react-hooks/exhaustive-deps\n// // // // // // // // // // // // // // // // // // //   useEffect(() => {\n// // // // // // // // // // // // // // // // // // //     for (let i = 0; i < particleCount; i += 1) {\n// // // // // // // // // // // // // // // // // // //       positions.current[i * 3] = starPositionRef.current.x;\n// // // // // // // // // // // // // // // // // // //       positions.current[i * 3 + 1] = starPositionRef.current.y;\n// // // // // // // // // // // // // // // // // // //       positions.current[i * 3 + 2] = starPositionRef.current.z;\n\n// // // // // // // // // // // // // // // // // // //       velocities.current[i * 3] = -(Math.random() * 0.02 + 0.01);\n// // // // // // // // // // // // // // // // // // //       velocities.current[i * 3 + 1] = (Math.random() - 0.5) * 0.02;\n// // // // // // // // // // // // // // // // // // //       velocities.current[i * 3 + 2] = (Math.random() - 0.5) * 0.02;\n// // // // // // // // // // // // // // // // // // //     }\n// // // // // // // // // // // // // // // // // // //   }); // Empty dependency array to run only once\n\n// // // // // // // // // // // // // // // // // // //   const particleGeometry = useMemo(() => {\n// // // // // // // // // // // // // // // // // // //     const geom = new BufferGeometry();\n// // // // // // // // // // // // // // // // // // //     geom.setAttribute('position', new BufferAttribute(positions.current, 3));\n// // // // // // // // // // // // // // // // // // //     return geom;\n// // // // // // // // // // // // // // // // // // //   }, []);\n\n// // // // // // // // // // // // // // // // // // //   const particleMaterial = useMemo(\n// // // // // // // // // // // // // // // // // // //     () =>\n// // // // // // // // // // // // // // // // // // //       new PointsMaterial({\n// // // // // // // // // // // // // // // // // // //         color: '#ffa500',\n// // // // // // // // // // // // // // // // // // //         size: 0.1,\n// // // // // // // // // // // // // // // // // // //         blending: AdditiveBlending,\n// // // // // // // // // // // // // // // // // // //         transparent: true,\n// // // // // // // // // // // // // // // // // // //       }),\n// // // // // // // // // // // // // // // // // // //     []\n// // // // // // // // // // // // // // // // // // //   );\n\n// // // // // // // // // // // // // // // // // // //   useFrame(() => {\n// // // // // // // // // // // // // // // // // // //     const posArray = particleGeometry.attributes.position.array as Float32Array;\n\n// // // // // // // // // // // // // // // // // // //     for (let i = 0; i < particleCount; i += 1) {\n// // // // // // // // // // // // // // // // // // //       // Update positions based on velocities\n// // // // // // // // // // // // // // // // // // //       posArray[i * 3] += velocities.current[i * 3];\n// // // // // // // // // // // // // // // // // // //       posArray[i * 3 + 1] += velocities.current[i * 3 + 1];\n// // // // // // // // // // // // // // // // // // //       posArray[i * 3 + 2] += velocities.current[i * 3 + 2];\n\n// // // // // // // // // // // // // // // // // // //       // Simple gravity towards the black hole\n// // // // // // // // // // // // // // // // // // //       const dx = posArray[i * 3];\n// // // // // // // // // // // // // // // // // // //       const dy = posArray[i * 3 + 1];\n// // // // // // // // // // // // // // // // // // //       const dz = posArray[i * 3 + 2];\n// // // // // // // // // // // // // // // // // // //       const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n// // // // // // // // // // // // // // // // // // //       const force = (0.02 / dist) * 0.1;\n\n// // // // // // // // // // // // // // // // // // //       velocities.current[i * 3] += (-dx / dist) * force;\n// // // // // // // // // // // // // // // // // // //       velocities.current[i * 3 + 1] += (-dy / dist) * force;\n// // // // // // // // // // // // // // // // // // //       velocities.current[i * 3 + 2] += (-dz / dist) * force;\n\n// // // // // // // // // // // // // // // // // // //       // Reset particle if it's too close to the black hole\n// // // // // // // // // // // // // // // // // // //       if (dist < 2) {\n// // // // // // // // // // // // // // // // // // //         posArray[i * 3] = starPositionRef.current.x;\n// // // // // // // // // // // // // // // // // // //         posArray[i * 3 + 1] = starPositionRef.current.y;\n// // // // // // // // // // // // // // // // // // //         posArray[i * 3 + 2] = starPositionRef.current.z;\n\n// // // // // // // // // // // // // // // // // // //         velocities.current[i * 3] = -(Math.random() * 0.02 + 0.01);\n// // // // // // // // // // // // // // // // // // //         velocities.current[i * 3 + 1] = (Math.random() - 0.5) * 0.02;\n// // // // // // // // // // // // // // // // // // //         velocities.current[i * 3 + 2] = (Math.random() - 0.5) * 0.02;\n// // // // // // // // // // // // // // // // // // //       }\n// // // // // // // // // // // // // // // // // // //     }\n\n// // // // // // // // // // // // // // // // // // //     particleGeometry.attributes.position.needsUpdate = true;\n// // // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // // //   return (\n// // // // // // // // // // // // // // // // // // //     <points ref={particlesRef} geometry={particleGeometry} material={particleMaterial} />\n// // // // // // // // // // // // // // // // // // //   );\n// // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // const BlackHoleScene: React.FC = () => {\n// // // // // // // // // // // // // // // // // // //   const starPositionRef = useRef<Vector3>(new Vector3(10, 0, 0));\n// // // // // // // // // // // // // // // // // // //   const blackHoleRadius = 2;\n\n// // // // // // // // // // // // // // // // // // //   return (\n// // // // // // // // // // // // // // // // // // //     <Canvas\n// // // // // // // // // // // // // // // // // // //       style={{ width: '100vw', height: '100vh', background: '#000000' }}\n// // // // // // // // // // // // // // // // // // //       camera={{ position: [20, 55, 25], fov: 60 }}\n// // // // // // // // // // // // // // // // // // //     >\n// // // // // // // // // // // // // // // // // // //       <ambientLight intensity={0.2} />\n// // // // // // // // // // // // // // // // // // //       <pointLight position={[0, 0, 0]} intensity={1} color=\"#ffffff\" />\n// // // // // // // // // // // // // // // // // // //       <ErrorBoundary>\n// // // // // // // // // // // // // // // // // // //         <BlackHole />\n// // // // // // // // // // // // // // // // // // //         <AccretionDisk blackHoleRadius={blackHoleRadius} />\n// // // // // // // // // // // // // // // // // // //         <Star positionRef={starPositionRef} blackHoleRadius={blackHoleRadius} />\n// // // // // // // // // // // // // // // // // // //         <ParticleSystem starPositionRef={starPositionRef} />\n// // // // // // // // // // // // // // // // // // //       </ErrorBoundary>\n// // // // // // // // // // // // // // // // // // //       <EffectComposer>\n// // // // // // // // // // // // // // // // // // //         <Bloom\n// // // // // // // // // // // // // // // // // // //           luminanceThreshold={0.5}\n// // // // // // // // // // // // // // // // // // //           luminanceSmoothing={0.1}\n// // // // // // // // // // // // // // // // // // //           intensity={1.5}\n// // // // // // // // // // // // // // // // // // //           height={300}\n// // // // // // // // // // // // // // // // // // //         />\n// // // // // // // // // // // // // // // // // // //       </EffectComposer>\n// // // // // // // // // // // // // // // // // // //       <Controls />\n// // // // // // // // // // // // // // // // // // //     </Canvas>\n// // // // // // // // // // // // // // // // // // //   );\n// // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // export default BlackHoleScene;\n\n\n// // // // // // // // // // // // // // // // // // // // // BlackHoleScene.tsx\n\n// // // // // // // // // // // // // // // // // // // // import React, { useState, useEffect, useRef, useMemo } from 'react';\n// // // // // // // // // // // // // // // // // // // // import {\n// // // // // // // // // // // // // // // // // // // //   ShaderMaterial,\n// // // // // // // // // // // // // // // // // // // //   Vector2,\n// // // // // // // // // // // // // // // // // // // //   AdditiveBlending,\n// // // // // // // // // // // // // // // // // // // //   Mesh,\n// // // // // // // // // // // // // // // // // // // //   Points,\n// // // // // // // // // // // // // // // // // // // //   BufferGeometry,\n// // // // // // // // // // // // // // // // // // // //   BufferAttribute,\n// // // // // // // // // // // // // // // // // // // //   PointsMaterial,\n// // // // // // // // // // // // // // // // // // // //   Color,\n// // // // // // // // // // // // // // // // // // // //   Vector3,\n// // // // // // // // // // // // // // // // // // // //   DoubleSide,\n// // // // // // // // // // // // // // // // // // // // } from 'three';\n// // // // // // // // // // // // // // // // // // // // import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';\n// // // // // // // // // // // // // // // // // // // // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n// // // // // // // // // // // // // // // // // // // // import { EffectComposer, Bloom } from '@react-three/postprocessing';\n// // // // // // // // // // // // // // // // // // // // import ErrorBoundary from './errorBoundary';\n\n// // // // // // // // // // // // // // // // // // // // extend({ OrbitControls });\n\n// // // // // // // // // // // // // // // // // // // // const Controls = () => {\n// // // // // // // // // // // // // // // // // // // //   const { camera, gl } = useThree();\n// // // // // // // // // // // // // // // // // // // //   const controlsRef = useRef<any>(null);\n\n// // // // // // // // // // // // // // // // // // // //   useEffect(() => {\n// // // // // // // // // // // // // // // // // // // //     controlsRef.current = new OrbitControls(camera, gl.domElement);\n// // // // // // // // // // // // // // // // // // // //     controlsRef.current.enableDamping = true;\n// // // // // // // // // // // // // // // // // // // //     return () => {\n// // // // // // // // // // // // // // // // // // // //       controlsRef.current.dispose();\n// // // // // // // // // // // // // // // // // // // //     };\n// // // // // // // // // // // // // // // // // // // //   }, [camera, gl]);\n\n// // // // // // // // // // // // // // // // // // // //   useFrame(() => {\n// // // // // // // // // // // // // // // // // // // //     controlsRef.current.update();\n// // // // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // // // //   return null;\n// // // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // // const BlackHole = () => {\n// // // // // // // // // // // // // // // // // // // //   const meshRef = useRef<Mesh>(null);\n\n// // // // // // // // // // // // // // // // // // // //   // Custom shader material for the black hole with gravitational lensing\n// // // // // // // // // // // // // // // // // // // //   const blackHoleMaterial = useMemo(\n// // // // // // // // // // // // // // // // // // // //     () =>\n// // // // // // // // // // // // // // // // // // // //       new ShaderMaterial({\n// // // // // // // // // // // // // // // // // // // //         uniforms: {\n// // // // // // // // // // // // // // // // // // // //           u_time: { value: 0 },\n// // // // // // // // // // // // // // // // // // // //           u_resolution: { value: new Vector2(window.innerWidth, window.innerHeight) },\n// // // // // // // // // // // // // // // // // // // //           u_cameraPos: { value: new Vector3() }, // Initialize with default value\n// // // // // // // // // // // // // // // // // // // //           u_blackHolePos: { value: new Vector3(0, 0, 0) },\n// // // // // // // // // // // // // // // // // // // //         },\n// // // // // // // // // // // // // // // // // // // //         vertexShader: `\n// // // // // // // // // // // // // // // // // // // //           varying vec3 vWorldPosition;\n// // // // // // // // // // // // // // // // // // // //           void main() {\n// // // // // // // // // // // // // // // // // // // //             vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n// // // // // // // // // // // // // // // // // // // //             gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n// // // // // // // // // // // // // // // // // // // //           }\n// // // // // // // // // // // // // // // // // // // //         `,\n// // // // // // // // // // // // // // // // // // // //         fragmentShader: `\n// // // // // // // // // // // // // // // // // // // //           varying vec3 vWorldPosition;\n// // // // // // // // // // // // // // // // // // // //           uniform vec3 u_cameraPos;\n// // // // // // // // // // // // // // // // // // // //           uniform vec3 u_blackHolePos;\n// // // // // // // // // // // // // // // // // // // //           void main() {\n// // // // // // // // // // // // // // // // // // // //             // Simplified gravitational lensing effect\n// // // // // // // // // // // // // // // // // // // //             vec3 dir = normalize(vWorldPosition - u_cameraPos);\n// // // // // // // // // // // // // // // // // // // //             float dist = length(vWorldPosition - u_blackHolePos);\n// // // // // // // // // // // // // // // // // // // //             float lensing = clamp(1.0 / (dist * dist * 100.0), 0.0, 1.0);\n// // // // // // // // // // // // // // // // // // // //             gl_FragColor = vec4(vec3(0.0), 1.0 - lensing);\n// // // // // // // // // // // // // // // // // // // //           }\n// // // // // // // // // // // // // // // // // // // //         `,\n// // // // // // // // // // // // // // // // // // // //         side: DoubleSide,\n// // // // // // // // // // // // // // // // // // // //       }),\n// // // // // // // // // // // // // // // // // // // //     []\n// // // // // // // // // // // // // // // // // // // //   );\n\n// // // // // // // // // // // // // // // // // // // //   useFrame(({ clock, camera }) => {\n// // // // // // // // // // // // // // // // // // // //     blackHoleMaterial.uniforms.u_time.value = clock.getElapsedTime();\n// // // // // // // // // // // // // // // // // // // //     blackHoleMaterial.uniforms.u_cameraPos.value.copy(camera.position);\n// // // // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // // // //   return (\n// // // // // // // // // // // // // // // // // // // //     <mesh ref={meshRef} material={blackHoleMaterial}>\n// // // // // // // // // // // // // // // // // // // //       <sphereGeometry args={[2, 64, 64]} />\n// // // // // // // // // // // // // // // // // // // //     </mesh>\n// // // // // // // // // // // // // // // // // // // //   );\n// // // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // // interface AccretionDiskProps {\n// // // // // // // // // // // // // // // // // // // //   blackHoleRadius: number;\n// // // // // // // // // // // // // // // // // // // // }\n\n// // // // // // // // // // // // // // // // // // // // const AccretionDisk: React.FC<AccretionDiskProps> = ({ blackHoleRadius }) => {\n// // // // // // // // // // // // // // // // // // // //   const particlesRef = useRef<Points>(null);\n// // // // // // // // // // // // // // // // // // // //   const particleCount = 10000;\n\n// // // // // // // // // // // // // // // // // // // //   // Generate positions and colors for particles in a disk shape\n// // // // // // // // // // // // // // // // // // // //   const positionColorData = useMemo(() => {\n// // // // // // // // // // // // // // // // // // // //     const positionsArray = new Float32Array(particleCount * 3);\n// // // // // // // // // // // // // // // // // // // //     const colorsArray = new Float32Array(particleCount * 3);\n\n// // // // // // // // // // // // // // // // // // // //     const innerRadius = blackHoleRadius + 0.2;\n// // // // // // // // // // // // // // // // // // // //     const outerRadius = blackHoleRadius + 5;\n\n// // // // // // // // // // // // // // // // // // // //     for (let i = 0; i < particleCount; i++) {\n// // // // // // // // // // // // // // // // // // // //       const angle = Math.random() * 2 * Math.PI;\n// // // // // // // // // // // // // // // // // // // //       const radius = Math.sqrt(\n// // // // // // // // // // // // // // // // // // // //         Math.random() * (outerRadius ** 2 - innerRadius ** 2) + innerRadius ** 2\n// // // // // // // // // // // // // // // // // // // //       );\n\n// // // // // // // // // // // // // // // // // // // //       positionsArray[i * 3] = radius * Math.cos(angle);\n// // // // // // // // // // // // // // // // // // // //       positionsArray[i * 3 + 1] = (Math.random() - 0.5) * 0.2; // Slight vertical spread\n// // // // // // // // // // // // // // // // // // // //       positionsArray[i * 3 + 2] = radius * Math.sin(angle);\n\n// // // // // // // // // // // // // // // // // // // //       // Color gradient from white (hot) near black hole to orange (cooler) outward\n// // // // // // // // // // // // // // // // // // // //       const t = (radius - innerRadius) / (outerRadius - innerRadius);\n// // // // // // // // // // // // // // // // // // // //       const color = new Color().setHSL(0.1 * (1 - t), 1.0, 0.5 + 0.5 * (1 - t));\n// // // // // // // // // // // // // // // // // // // //       colorsArray[i * 3] = color.r;\n// // // // // // // // // // // // // // // // // // // //       colorsArray[i * 3 + 1] = color.g;\n// // // // // // // // // // // // // // // // // // // //       colorsArray[i * 3 + 2] = color.b;\n// // // // // // // // // // // // // // // // // // // //     }\n\n// // // // // // // // // // // // // // // // // // // //     return { positions: positionsArray, colors: colorsArray };\n// // // // // // // // // // // // // // // // // // // //   }, [particleCount, blackHoleRadius]);\n\n// // // // // // // // // // // // // // // // // // // //   const positions = positionColorData.positions;\n// // // // // // // // // // // // // // // // // // // //   const colors = positionColorData.colors;\n\n// // // // // // // // // // // // // // // // // // // //   const particleGeometry = useMemo(() => {\n// // // // // // // // // // // // // // // // // // // //     const geom = new BufferGeometry();\n// // // // // // // // // // // // // // // // // // // //     geom.setAttribute('position', new BufferAttribute(positions, 3));\n// // // // // // // // // // // // // // // // // // // //     geom.setAttribute('color', new BufferAttribute(colors, 3));\n// // // // // // // // // // // // // // // // // // // //     return geom;\n// // // // // // // // // // // // // // // // // // // //   }, [positions, colors]);\n\n// // // // // // // // // // // // // // // // // // // //   const particleMaterial = useMemo(\n// // // // // // // // // // // // // // // // // // // //     () =>\n// // // // // // // // // // // // // // // // // // // //       new PointsMaterial({\n// // // // // // // // // // // // // // // // // // // //         size: 0.05,\n// // // // // // // // // // // // // // // // // // // //         vertexColors: true,\n// // // // // // // // // // // // // // // // // // // //         blending: AdditiveBlending,\n// // // // // // // // // // // // // // // // // // // //         transparent: true,\n// // // // // // // // // // // // // // // // // // // //       }),\n// // // // // // // // // // // // // // // // // // // //     []\n// // // // // // // // // // // // // // // // // // // //   );\n\n// // // // // // // // // // // // // // // // // // // //   useFrame(() => {\n// // // // // // // // // // // // // // // // // // // //     if (particlesRef.current) {\n// // // // // // // // // // // // // // // // // // // //       particlesRef.current.rotation.y += 0.002; // Slow rotation\n// // // // // // // // // // // // // // // // // // // //     }\n// // // // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // // // //   return (\n// // // // // // // // // // // // // // // // // // // //     <points ref={particlesRef} geometry={particleGeometry} material={particleMaterial} />\n// // // // // // // // // // // // // // // // // // // //   );\n// // // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // // interface StarProps {\n// // // // // // // // // // // // // // // // // // // //   positionRef: React.MutableRefObject<Vector3>;\n// // // // // // // // // // // // // // // // // // // // }\n\n// // // // // // // // // // // // // // // // // // // // const Star: React.FC<StarProps> = ({ positionRef }) => {\n// // // // // // // // // // // // // // // // // // // //   const starRef = useRef<Mesh>(null);\n\n// // // // // // // // // // // // // // // // // // // //   useFrame(({ clock }) => {\n// // // // // // // // // // // // // // // // // // // //     if (starRef.current) {\n// // // // // // // // // // // // // // // // // // // //       const t = clock.getElapsedTime();\n\n// // // // // // // // // // // // // // // // // // // //       // Decaying orbit parameters\n// // // // // // // // // // // // // // // // // // // //       const initialRadius = 10;\n// // // // // // // // // // // // // // // // // // // //       const decayRate = 0.05; // Adjust for slower decay\n\n// // // // // // // // // // // // // // // // // // // //       const radius = Math.max(2.5, initialRadius - decayRate * t);\n// // // // // // // // // // // // // // // // // // // //       const angularSpeed = 0.8; // Adjust for slower orbit\n\n// // // // // // // // // // // // // // // // // // // //       const angle = angularSpeed * t;\n\n// // // // // // // // // // // // // // // // // // // //       // Convert polar to Cartesian coordinates\n// // // // // // // // // // // // // // // // // // // //       const x = radius * Math.cos(angle);\n// // // // // // // // // // // // // // // // // // // //       const z = radius * Math.sin(angle);\n\n// // // // // // // // // // // // // // // // // // // //       starRef.current.position.set(x, 0, z);\n\n// // // // // // // // // // // // // // // // // // // //       // Update the shared positionRef\n// // // // // // // // // // // // // // // // // // // //       positionRef.current.copy(starRef.current.position);\n\n// // // // // // // // // // // // // // // // // // // //       // Simple pulsating effect\n// // // // // // // // // // // // // // // // // // // //       const scale = 1 + Math.sin(t * 5) * 0.1;\n// // // // // // // // // // // // // // // // // // // //       starRef.current.scale.set(scale, scale, scale);\n// // // // // // // // // // // // // // // // // // // //     }\n// // // // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // // // //   return (\n// // // // // // // // // // // // // // // // // // // //     <mesh ref={starRef}>\n// // // // // // // // // // // // // // // // // // // //       <sphereGeometry args={[1.5, 32, 32]} />\n// // // // // // // // // // // // // // // // // // // //       <meshStandardMaterial\n// // // // // // // // // // // // // // // // // // // //         color=\"#ffff00\"\n// // // // // // // // // // // // // // // // // // // //         emissive=\"#ffff00\"\n// // // // // // // // // // // // // // // // // // // //         emissiveIntensity={2} // Increased intensity for bloom effect\n// // // // // // // // // // // // // // // // // // // //       />\n// // // // // // // // // // // // // // // // // // // //     </mesh>\n// // // // // // // // // // // // // // // // // // // //   );\n// // // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // // interface ParticleSystemProps {\n// // // // // // // // // // // // // // // // // // // //   starPositionRef: React.MutableRefObject<Vector3>;\n// // // // // // // // // // // // // // // // // // // // }\n\n// // // // // // // // // // // // // // // // // // // // const ParticleSystem: React.FC<ParticleSystemProps> = ({ starPositionRef }) => {\n// // // // // // // // // // // // // // // // // // // //   const particlesRef = useRef<Points>(null);\n\n// // // // // // // // // // // // // // // // // // // //   const particleCount = 5000;\n// // // // // // // // // // // // // // // // // // // //   const positions = useRef<Float32Array>(new Float32Array(particleCount * 3));\n// // // // // // // // // // // // // // // // // // // //   const velocities = useRef<Float32Array>(new Float32Array(particleCount * 3));\n\n// // // // // // // // // // // // // // // // // // // //   // Initialize particles only once\n// // // // // // // // // // // // // // // // // // // //   // eslint-disable-next-line react-hooks/exhaustive-deps\n// // // // // // // // // // // // // // // // // // // //   useEffect(() => {\n// // // // // // // // // // // // // // // // // // // //     for (let i = 0; i < particleCount; i += 1) {\n// // // // // // // // // // // // // // // // // // // //       positions.current[i * 3] = starPositionRef.current.x;\n// // // // // // // // // // // // // // // // // // // //       positions.current[i * 3 + 1] = starPositionRef.current.y;\n// // // // // // // // // // // // // // // // // // // //       positions.current[i * 3 + 2] = starPositionRef.current.z;\n\n// // // // // // // // // // // // // // // // // // // //       velocities.current[i * 3] = -(Math.random() * 0.02 + 0.01);\n// // // // // // // // // // // // // // // // // // // //       velocities.current[i * 3 + 1] = (Math.random() - 0.5) * 0.02;\n// // // // // // // // // // // // // // // // // // // //       velocities.current[i * 3 + 2] = (Math.random() - 0.5) * 0.02;\n// // // // // // // // // // // // // // // // // // // //     }\n// // // // // // // // // // // // // // // // // // // //   }); // Empty dependency array to run only once\n\n// // // // // // // // // // // // // // // // // // // //   const particleGeometry = useMemo(() => {\n// // // // // // // // // // // // // // // // // // // //     const geom = new BufferGeometry();\n// // // // // // // // // // // // // // // // // // // //     geom.setAttribute('position', new BufferAttribute(positions.current, 3));\n// // // // // // // // // // // // // // // // // // // //     return geom;\n// // // // // // // // // // // // // // // // // // // //   }, []);\n\n// // // // // // // // // // // // // // // // // // // //   const particleMaterial = useMemo(\n// // // // // // // // // // // // // // // // // // // //     () =>\n// // // // // // // // // // // // // // // // // // // //       new PointsMaterial({\n// // // // // // // // // // // // // // // // // // // //         color: '#ffa500',\n// // // // // // // // // // // // // // // // // // // //         size: 0.1,\n// // // // // // // // // // // // // // // // // // // //         blending: AdditiveBlending,\n// // // // // // // // // // // // // // // // // // // //         transparent: true,\n// // // // // // // // // // // // // // // // // // // //       }),\n// // // // // // // // // // // // // // // // // // // //     []\n// // // // // // // // // // // // // // // // // // // //   );\n\n// // // // // // // // // // // // // // // // // // // //   useFrame(() => {\n// // // // // // // // // // // // // // // // // // // //     const posArray = particleGeometry.attributes.position.array as Float32Array;\n\n// // // // // // // // // // // // // // // // // // // //     for (let i = 0; i < particleCount; i += 1) {\n// // // // // // // // // // // // // // // // // // // //       // Update positions based on velocities\n// // // // // // // // // // // // // // // // // // // //       posArray[i * 3] += velocities.current[i * 3];\n// // // // // // // // // // // // // // // // // // // //       posArray[i * 3 + 1] += velocities.current[i * 3 + 1];\n// // // // // // // // // // // // // // // // // // // //       posArray[i * 3 + 2] += velocities.current[i * 3 + 2];\n\n// // // // // // // // // // // // // // // // // // // //       // Simple gravity towards the black hole\n// // // // // // // // // // // // // // // // // // // //       const dx = posArray[i * 3];\n// // // // // // // // // // // // // // // // // // // //       const dy = posArray[i * 3 + 1];\n// // // // // // // // // // // // // // // // // // // //       const dz = posArray[i * 3 + 2];\n// // // // // // // // // // // // // // // // // // // //       const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n// // // // // // // // // // // // // // // // // // // //       const force = (0.02 / dist) * 0.1;\n\n// // // // // // // // // // // // // // // // // // // //       velocities.current[i * 3] += (-dx / dist) * force;\n// // // // // // // // // // // // // // // // // // // //       velocities.current[i * 3 + 1] += (-dy / dist) * force;\n// // // // // // // // // // // // // // // // // // // //       velocities.current[i * 3 + 2] += (-dz / dist) * force;\n\n// // // // // // // // // // // // // // // // // // // //       // Reset particle if it's too close to the black hole\n// // // // // // // // // // // // // // // // // // // //       if (dist < 2) {\n// // // // // // // // // // // // // // // // // // // //         posArray[i * 3] = starPositionRef.current.x;\n// // // // // // // // // // // // // // // // // // // //         posArray[i * 3 + 1] = starPositionRef.current.y;\n// // // // // // // // // // // // // // // // // // // //         posArray[i * 3 + 2] = starPositionRef.current.z;\n\n// // // // // // // // // // // // // // // // // // // //         velocities.current[i * 3] = -(Math.random() * 0.02 + 0.01);\n// // // // // // // // // // // // // // // // // // // //         velocities.current[i * 3 + 1] = (Math.random() - 0.5) * 0.02;\n// // // // // // // // // // // // // // // // // // // //         velocities.current[i * 3 + 2] = (Math.random() - 0.5) * 0.02;\n// // // // // // // // // // // // // // // // // // // //       }\n// // // // // // // // // // // // // // // // // // // //     }\n\n// // // // // // // // // // // // // // // // // // // //     particleGeometry.attributes.position.needsUpdate = true;\n// // // // // // // // // // // // // // // // // // // //   });\n\n// // // // // // // // // // // // // // // // // // // //   return (\n// // // // // // // // // // // // // // // // // // // //     <points ref={particlesRef} geometry={particleGeometry} material={particleMaterial} />\n// // // // // // // // // // // // // // // // // // // //   );\n// // // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // // const BlackHoleScene: React.FC = () => {\n// // // // // // // // // // // // // // // // // // // //   const starPositionRef = useRef<Vector3>(new Vector3(10, 0, 0));\n// // // // // // // // // // // // // // // // // // // //   const blackHoleRadius = 2;\n\n// // // // // // // // // // // // // // // // // // // //   return (\n// // // // // // // // // // // // // // // // // // // //     <Canvas\n// // // // // // // // // // // // // // // // // // // //       style={{ width: '100vw', height: '100vh', background: '#000000' }}\n// // // // // // // // // // // // // // // // // // // //       camera={{ position: [0, 5, 25], fov: 60 }}\n// // // // // // // // // // // // // // // // // // // //     >\n// // // // // // // // // // // // // // // // // // // //       <ambientLight intensity={0.2} />\n// // // // // // // // // // // // // // // // // // // //       <pointLight position={[0, 0, 0]} intensity={1} color=\"#ffffff\" />\n// // // // // // // // // // // // // // // // // // // //       <ErrorBoundary>\n// // // // // // // // // // // // // // // // // // // //         <BlackHole />\n// // // // // // // // // // // // // // // // // // // //         <AccretionDisk blackHoleRadius={blackHoleRadius} />\n// // // // // // // // // // // // // // // // // // // //         <Star positionRef={starPositionRef} />\n// // // // // // // // // // // // // // // // // // // //         <ParticleSystem starPositionRef={starPositionRef} />\n// // // // // // // // // // // // // // // // // // // //       </ErrorBoundary>\n// // // // // // // // // // // // // // // // // // // //       <EffectComposer>\n// // // // // // // // // // // // // // // // // // // //         <Bloom\n// // // // // // // // // // // // // // // // // // // //           luminanceThreshold={0.5}\n// // // // // // // // // // // // // // // // // // // //           luminanceSmoothing={0.1}\n// // // // // // // // // // // // // // // // // // // //           intensity={1.5}\n// // // // // // // // // // // // // // // // // // // //           height={300}\n// // // // // // // // // // // // // // // // // // // //         />\n// // // // // // // // // // // // // // // // // // // //       </EffectComposer>\n// // // // // // // // // // // // // // // // // // // //       <Controls />\n// // // // // // // // // // // // // // // // // // // //     </Canvas>\n// // // // // // // // // // // // // // // // // // // //   );\n// // // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // // export default BlackHoleScene;\n\n\n// // // // // // // // // // // // // // // // // // // const SolarView: React.FC = () => {\n// // // // // // // // // // // // // // // // // // //   const [timeSpeed, setTimeSpeed] = useState<number>(1);\n\n// // // // // // // // // // // // // // // // // // //   return (\n// // // // // // // // // // // // // // // // // // //     <>\n// // // // // // // // // // // // // // // // // // //       <Canvas\n// // // // // // // // // // // // // // // // // // //         shadows\n// // // // // // // // // // // // // // // // // // //         style={{ width: '100vw', height: '100vh', background: '#21272f' }}\n// // // // // // // // // // // // // // // // // // //         camera={{ position: [0, 20, 40], fov: 60 }}\n// // // // // // // // // // // // // // // // // // //       >\n// // // // // // // // // // // // // // // // // // //         <ambientLight intensity={0.4} />\n\n// // // // // // // // // // // // // // // // // // //         <pointLight\n// // // // // // // // // // // // // // // // // // //           position={[0, 0, 0]}\n// // // // // // // // // // // // // // // // // // //           intensity={2}\n// // // // // // // // // // // // // // // // // // //           color=\"white\"\n// // // // // // // // // // // // // // // // // // //           castShadow\n// // // // // // // // // // // // // // // // // // //           shadow-mapSize-width={2048}\n// // // // // // // // // // // // // // // // // // //           shadow-mapSize-height={2048}\n// // // // // // // // // // // // // // // // // // //           shadow-camera-near={0.1}\n// // // // // // // // // // // // // // // // // // //           shadow-camera-far={500}\n// // // // // // // // // // // // // // // // // // //         />\n\n// // // // // // // // // // // // // // // // // // //         <ErrorBoundary>\n// // // // // // // // // // // // // // // // // // //           {/* <SolarSystem timeSpeed={timeSpeed} /> */}\n// // // // // // // // // // // // // // // // // // //         </ErrorBoundary>\n\n// // // // // // // // // // // // // // // // // // //         <Controls />\n// // // // // // // // // // // // // // // // // // //       </Canvas>\n// // // // // // // // // // // // // // // // // // //       {/* <Slider\n// // // // // // // // // // // // // // // // // // //         value={timeSpeed}\n// // // // // // // // // // // // // // // // // // //         onChange={(e, newValue) => setTimeSpeed(newValue as number)}\n// // // // // // // // // // // // // // // // // // //         min={0.1}\n// // // // // // // // // // // // // // // // // // //         max={10}\n// // // // // // // // // // // // // // // // // // //         step={0.1}\n// // // // // // // // // // // // // // // // // // //         aria-labelledby=\"time-speed-slider\"\n// // // // // // // // // // // // // // // // // // //       /> */}\n// // // // // // // // // // // // // // // // // // //     </>\n// // // // // // // // // // // // // // // // // // //   );\n// // // // // // // // // // // // // // // // // // // };\n\n// // // // // // // // // // // // // // // // // // // // export default SolarView;\n\n\n// // // // // // // // // // // // // // // // // // // // const Controls = () => {\n// // // // // // // // // // // // // // // // // // // //   const { camera, gl } = useThree();\n// // // // // // // // // // // // // // // // // // // //   const controlsRef = useRef<OrbitControls | null>(null);\n\n// // // // // // // // // // // // // // // // // // // //   useEffect(() => {\n// // // // // // // // // // // // // // // // // // // //     controlsRef.current = new OrbitControls(camera, gl.domElement);\n\n// // // // // // // // // // // // // // // // // // // //     return () => {\n// // // // // // // // // // // // // // // // // // // //       controlsRef.current?.dispose();\n// // // // // // // // // // // // // // // // // // // //     };\n// // // // // // // // // // // // // // // // // // // //   }, [camera, gl]);\n\n// // // // // // // // // // // // // // // // // // // //   return null;\n// // // // // // // // // // // // // // // // // // // // };","// @ts-ignore\n\nimport { m, useScroll, Transition } from 'framer-motion';\nimport { useEffect, useRef, useState, useCallback } from 'react';\n// @mui\nimport { styled, alpha, useTheme, SxProps, Theme } from '@mui/material/styles';\nimport Box from '@mui/material/Box';\nimport Link from '@mui/material/Link';\nimport Stack from '@mui/material/Stack';\nimport Rating from '@mui/material/Rating';\nimport Button from '@mui/material/Button';\nimport Container from '@mui/material/Container';\nimport Grid from '@mui/material/Unstable_Grid2';\nimport { Typography, List, ListItem, ListItemText } from '@mui/material';\n// routes\nimport { paths } from 'src/routes/paths';\n// hooks\nimport { useResponsive } from 'src/hooks/use-responsive';\n// theme\nimport { textGradient, bgGradient, bgBlur } from 'src/theme/css';\n// layouts\nimport { HEADER } from 'src/layouts/config-layout';\n// components\nimport Iconify from 'src/components/iconify';\nimport { RouterLink } from 'src/routes/components';\nimport { MotionContainer, varFade } from 'src/components/animate';\nimport { TemporalResonatorScene } from 'src/components/three';\n\n// ----------------------------------------------------------------------\n\nconst StyledRoot = styled('div')(({ theme }) => ({\n  ...bgGradient({\n    color: alpha(theme.palette.background.default, theme.palette.mode === 'light' ? 0.9 : 0.94),\n    imgUrl: '/assets/background/overlay_3.jpg',\n  }),\n  width: '100%',\n  height: '100vh',\n  position: 'relative',\n  [theme.breakpoints.up('md')]: {\n    top: 0,\n    left: 0,\n    position: 'fixed',\n  },\n}));\n\nconst StyledWrapper = styled('div')(({ theme }) => ({\n  height: '100%',\n  width: '100%',\n  // overflow: 'hidden',\n  position: 'relative',\n  [theme.breakpoints.up('md')]: {\n    marginTop: HEADER.H_DESKTOP_OFFSET,\n  },\n}));\n\nconst StyledTextGradient = styled(m.h1)(({ theme }) => ({\n  ...textGradient(\n    `300deg, ${theme.palette.primary.main} 0%, ${theme.palette.warning.main} 25%, ${theme.palette.primary.main} 50%, ${theme.palette.warning.main} 75%, ${theme.palette.primary.main} 100%`\n  ),\n  padding: 0,\n  marginTop: 8,\n  lineHeight: 1,\n  marginBottom: 24,\n  letterSpacing: 8,\n  textAlign: 'center',\n  backgroundSize: '400%',\n  fontSize: `${64 / 16}rem`,\n  fontFamily: \"'Barlow', sans-serif\",\n  [theme.breakpoints.up('md')]: {\n    fontSize: `${96 / 16}rem`,\n  },\n}));\n\nconst StyledEllipseTop = styled('div')(({ theme }) => ({\n  top: -80,\n  width: 480,\n  right: -80,\n  height: 480,\n  borderRadius: '50%',\n  position: 'absolute',\n  filter: 'blur(100px)',\n  WebkitFilter: 'blur(100px)',\n  backgroundColor: alpha(theme.palette.primary.darker, 0.12),\n}));\n\nconst StyledEllipseBottom = styled('div')(({ theme }) => ({\n  height: 400,\n  bottom: -200,\n  left: '10%',\n  right: '10%',\n  borderRadius: '50%',\n  position: 'absolute',\n  filter: 'blur(100px)',\n  WebkitFilter: 'blur(100px)',\n  backgroundColor: alpha(theme.palette.primary.darker, 0.12),\n}));\n\ntype StyledPolygonProps = {\n  opacity?: number;\n  anchor?: 'left' | 'right';\n};\n\nconst StyledPolygon = styled('div')<StyledPolygonProps>(\n  ({ opacity = 1, anchor = 'left', theme }) => ({\n    ...bgBlur({\n      opacity,\n      color: theme.palette.background.default,\n    }),\n    zIndex: 9,\n    bottom: 0,\n    height: 80,\n    width: '50%',\n    position: 'absolute',\n    clipPath: 'polygon(0% 0%, 100% 100%, 0% 100%)',\n    ...(anchor === 'left' && {\n      left: 0,\n      ...(theme.direction === 'rtl' && {\n        transform: 'scale(-1, 1)',\n      }),\n    }),\n    ...(anchor === 'right' && {\n      right: 0,\n      transform: 'scaleX(-1)',\n      ...(theme.direction === 'rtl' && {\n        transform: 'scaleX(1)',\n      }),\n    }),\n  })\n);\n\n// ----------------------------------------------------------------------\n\nexport default function HomeHero() {\n  const mdUp = useResponsive('up', 'md');\n\n  const theme = useTheme();\n\n  const heroRef = useRef<HTMLDivElement | null>(null);\n\n  const { scrollY } = useScroll();\n\n  const [percent, setPercent] = useState(0.1);\n\n  const isLight = theme.palette.mode === 'light';\n\n  const getScroll = useCallback(() => {\n    let heroHeight = 0;\n\n    if (heroRef.current) {\n      heroHeight = heroRef.current.offsetHeight;\n    }\n\n    scrollY.on('change', (scrollHeight) => {\n      const scrollPercent = (scrollHeight * 100) / heroHeight;\n\n      setPercent(Math.floor(scrollPercent)+0.1);\n    });\n  }, [scrollY]);\n\n  useEffect(() => {\n    getScroll();\n  }, [getScroll]);\n\n  const transition: Transition = {\n    repeatType: 'loop',\n    ease: 'linear',\n    duration: 60 * 4,\n    repeat: Infinity,\n  };\n\n  const opacity = 1 - percent / 100;\n\n  const hide = percent > 120;\n\n  const renderDescription = (\n    <Stack\n      alignItems=\"center\"\n      justifyContent=\"center\"\n      sx={{\n        height: 1,\n        mx: 'auto',\n        maxWidth: 780,\n        opacity: opacity > 0 ? opacity : 1,\n        mt: {\n          md: `-${HEADER.H_DESKTOP + percent * 2.5}px`,\n        },\n      }}\n    >\n      <m.div variants={varFade().in}>\n       <Typography variant=\"h5\" sx={{ textAlign: 'center' }}>\n          Discover the Universe on Your Terms with\n        </Typography>\n      </m.div>\n\n      <m.div variants={varFade().in}>\n        <StyledTextGradient\n          animate={{ backgroundPosition: '200% center' }}\n          transition={{\n            repeatType: 'reverse',\n            ease: 'linear',\n            duration: 20,\n            repeat: Infinity,\n          }}\n        >\n          ð„† Shell of Time\n        </StyledTextGradient>\n      </m.div>\n\n      <m.div variants={varFade().in}>\n        <List>\n          <ListItem>\n            <ListItemText\n            sx={{ fontWeight: 'bold', textAlign: 'center' }}\n              primary=\"A Simulation of Collapse and Emergence\"\n              secondary=\"A temporal field toy based on the Time Density framework by Kristian Magda & Rikaisho.\"\n            />\n          </ListItem>\n          {/* <ListItem>\n            <ListItemText\n            sx={{ fontWeight: 'bold', textAlign: 'center' }}\n              primary=\"Design your universe, test your theories, and reshape reality\"\n              secondary=\"Experiment with established physics or break new ground as you create a universe that reflects your imagination.\"\n            />\n          </ListItem>\n          <ListItem>\n            <ListItemText\n            sx={{ fontWeight: 'bold', textAlign: 'center' }}\n              primary=\"Your playground for discovery, creation, and cosmic curiosity\"\n              secondary=\"Start with known physics or dive into the unknownâ€”every element of the universe is yours to explore and reshape.\"\n            />\n          </ListItem> */}\n        </List>\n      </m.div>\n\n      {/* <m.div variants={varFade().in}>\n        <Stack\n          spacing={0.75}\n          direction=\"row\"\n          alignItems=\"center\"\n          justifyContent=\"center\"\n          sx={{ my: 3 }}\n        >\n          <Rating readOnly value={4.95} precision={0.1} max={5} />\n          <Typography variant=\"caption\" sx={{ color: 'text.secondary' }}>\n            <Box component=\"strong\" sx={{ mr: 0.5, color: 'text.primary' }}>\n              4.96/5\n            </Box>\n            (999+ not fake reviews)\n          </Typography>\n        </Stack>\n      </m.div> */}\n\n      <m.div variants={varFade().in}>\n        <Stack spacing={1.5} direction={{ xs: 'column-reverse', sm: 'row' }} sx={{ mb: 10 }}>\n          <Stack alignItems=\"center\" spacing={2}>\n            <Button\n              component={RouterLink}\n              href=\"https://github.com/syqs/time-density\"\n              target='_blank'\n              color=\"inherit\"\n              size=\"large\"\n              variant=\"contained\"\n              startIcon={<Iconify icon=\"eva:flash-fill\" width={24} />}\n            >\n              Read the Full Theory\n            </Button><br/><br/><br/>\n            \n          </Stack>\n        </Stack>\n      </m.div>\n    </Stack>\n  );\n\n  const renderSlides2 = (\n    <Stack\n      direction=\"row\"\n      alignItems=\"flex-start\"\n      sx={{\n        height: '100%',\n        width: '200%',\n        position: 'absolute',\n        left: 0,\n        opacity: opacity > 0 ? opacity : 0,\n        }}\n    >\n      <TemporalResonatorScene  />\n    </Stack>\n  )\n\n  const renderSlides = (\n    <Stack\n      direction=\"row\"\n      alignItems=\"flex-start\"\n      sx={{\n        height: '150%',\n        position: 'absolute',\n        opacity: opacity > 0 ? opacity : 0,\n        transform: `skew(${-16 - percent / 24}deg, ${4 - percent / 16}deg)`,\n        ...(theme.direction === 'rtl' && {\n          transform: `skew(${16 + percent / 24}deg, ${4 + percent / 16}deg)`,\n        }),\n      }}\n    >\n      <Stack\n        component={m.div}\n        variants={varFade().in}\n        sx={{\n          width: 344,\n          position: 'relative',\n        }}\n      >\n        <Box\n          component={m.img}\n          animate={{ y: ['0%', '100%'] }}\n          transition={transition}\n          alt={isLight ? 'light_1' : 'dark_1'}\n          src={\n            isLight\n              ? `/assets/images/home/hero/light_1.webp`\n              : `/assets/images/home/hero/dark_1.webp`\n          }\n          sx={{ position: 'absolute', mt: -5 }}\n        />\n        <Box\n          component={m.img}\n          animate={{ y: ['-100%', '0%'] }}\n          transition={transition}\n          alt={isLight ? 'light_1' : 'dark_1'}\n          src={\n            isLight\n              ? `/assets/images/home/hero/light_1.webp`\n              : `/assets/images/home/hero/dark_1.webp`\n          }\n          sx={{ position: 'absolute' }}\n        />\n      </Stack>\n\n      <Stack\n        component={m.div}\n        variants={varFade().in}\n        sx={{ width: 720, position: 'relative', ml: -5 }}\n      >\n        <Box\n          component={m.img}\n          animate={{ y: ['100%', '0%'] }}\n          transition={transition}\n          alt={isLight ? 'light_2' : 'dark_2'}\n          src={\n            isLight\n              ? `/assets/images/home/hero/light_2.webp`\n              : `/assets/images/home/hero/dark_2.webp`\n          }\n          sx={{ position: 'absolute', mt: -5 }}\n        />\n        <Box\n          component={m.img}\n          animate={{ y: ['0%', '-100%'] }}\n          transition={transition}\n          alt={isLight ? 'light_2' : 'dark_2'}\n          src={\n            isLight\n              ? `/assets/images/home/hero/light_2.webp`\n              : `/assets/images/home/hero/dark_2.webp`\n          }\n          sx={{ position: 'absolute' }}\n        />\n      </Stack>\n    </Stack>\n  );\n\n  const renderPolygons = (\n    <>\n      <StyledPolygon />\n      <StyledPolygon anchor=\"right\" opacity={0.48} />\n      <StyledPolygon anchor=\"right\" opacity={0.48} sx={{ height: 48, zIndex: 10 }} />\n      <StyledPolygon anchor=\"right\" sx={{ zIndex: 11, height: 24 }} />\n    </>\n  );\n\n  const renderEllipses = (\n    <>\n      {mdUp && <StyledEllipseTop />}\n      <StyledEllipseBottom />\n    </>\n  );\n\n  return (\n    <>\n      <StyledRoot\n        ref={heroRef}\n        sx={{\n          \n          ...(hide && {\n            opacity: 1,\n          }),\n        }}\n        \n      >\n        <StyledWrapper > \n          <Container component={MotionContainer} sx={{ height: 1, }} style={{width:'100%'}}>\n            <Grid container columnSpacing={{ md: 10 }} sx={{ height: 1 }}>\n               {mdUp && <Grid md={12}>{renderSlides2}</Grid>}\n              <Grid xs={12} md={6}>\n                {renderDescription}\n              </Grid>\n\n             \n            </Grid>\n          </Container>\n\n          {/* {renderEllipses} */}\n        </StyledWrapper>\n      </StyledRoot>\n\n      {/* {mdUp && renderPolygons} */}\n      \n      {/* <Box sx={{ height: { md: '100vh' }, width:'100%' }} /> */}\n    </>\n  );\n}\n","import { useScroll } from 'framer-motion';\n// @mui\nimport { styled } from '@mui/material/styles';\nimport Box from '@mui/material/Box';\n// components\nimport ScrollProgress from 'src/components/scroll-progress';\n//\nimport HomeHero from '../home-hero';\nimport HomeMinimal from '../home-minimal';\nimport HomePricing from '../home-pricing';\nimport HomeDarkMode from '../home-dark-mode';\nimport HomeLookingFor from '../home-looking-for';\nimport HomeForDesigner from '../home-for-designer';\nimport HomeColorPresets from '../home-color-presets';\nimport HomeAdvertisement from '../home-advertisement';\nimport HomeCleanInterfaces from '../home-clean-interfaces';\nimport HomeHugePackElements from '../home-hugepack-elements';\n\n// ----------------------------------------------------------------------\n\ntype StyledPolygonProps = {\n  anchor?: 'top' | 'bottom';\n};\n\nconst StyledPolygon = styled('div')<StyledPolygonProps>(({ anchor = 'top', theme }) => ({\n  left: 0,\n  zIndex: 9,\n  height: 80,\n  width: '100%',\n  position: 'absolute',\n  clipPath: 'polygon(0% 0%, 100% 100%, 0% 100%)',\n  backgroundColor: theme.palette.background.default,\n  display: 'block',\n  lineHeight: 0,\n  ...(anchor === 'top' && {\n    top: -1,\n    transform: 'scale(-1, -1)',\n  }),\n  ...(anchor === 'bottom' && {\n    bottom: -1,\n    backgroundColor: theme.palette.grey[900],\n  }),\n}));\n\n// ----------------------------------------------------------------------\n\nexport default function HomeView() {\n  const { scrollYProgress } = useScroll();\n\n  return (\n    <>\n      <ScrollProgress scrollYProgress={scrollYProgress} />\n\n      <HomeHero />\n\n      <Box\n        sx={{\n          overflow: 'hidden',\n          position: 'relative',\n          bgcolor: 'background.default',\n        }}\n      >\n        {/* <HomeMinimal /> */}\n\n        {/* <HomeHugePackElements />\n\n        <Box sx={{ position: 'relative' }}>\n          <StyledPolygon />\n          <HomeForDesigner />\n          <StyledPolygon anchor=\"bottom\" />\n        </Box>\n\n        <HomeDarkMode />\n\n        <HomeColorPresets />\n\n        <HomeCleanInterfaces />\n\n        <HomePricing />\n\n        <HomeLookingFor />\n\n        <HomeAdvertisement /> */}\n      </Box>\n    </>\n  );\n}\n","import { Helmet } from 'react-helmet-async';\n// sections\nimport { HomeView } from 'src/sections/home/view';\n\n// ----------------------------------------------------------------------\n\nexport default function HomePage() {\n  return (\n    <>\n      <Helmet>\n        <title> Minimal: The starting point for your next project</title>\n      </Helmet>\n\n      <HomeView />\n    </>\n  );\n}\n"],"names":["ScrollProgress","_ref","_ref$color","color","_ref$size","size","scrollYProgress","sx","other","_objectWithoutProperties","_excluded","scaleX","useSpring","stiffness","damping","restDelta","_jsx","Box","_objectSpread","component","m","div","top","left","right","height","zIndex","position","transformOrigin","bgcolor","background","theme","concat","palette","light","main","style","CustomSphere","forwardRef","ref","radius","widthSegments","heightSegments","texture","args","_ref$materialType","materialType","_ref$materialProps","materialProps","_jsxs","children","attach","side","BackSide","map","displayName","_Component","_inherits","ErrorBoundary","_super","_createSuper","props","_this","_classCallCheck","call","state","hasError","_createClass","key","value","error","errorInfo","console","this","_","Component","THREE","prototype","computeBoundsTree","disposeBoundsTree","raycast","acceleratedRaycast","csgEvaluator","Evaluator","useGroups","extend","OrbitControls","PHI","Math","sqrt","INV_PHI","FACE_DRAG_COEFFICIENTS","getDodecahedronData","Number","isFinite","Error","uniqueVerticesMap","Map","coords","distOriginToVertex","scale","forEach","v","x","y","z","toFixed","has","set","vertices","Array","from","values","faceData","faceCenterDist","normal","normalize","center","clone","multiplyScalar","push","Controls","_useThree","useThree","camera","gl","controlsRef","useRef","useEffect","controls","domElement","enableDamping","target","current","dispose","useFrame","_controlsRef$current","update","RomanDodecahedron","React","outerRadius","thickness","holeBaseDiameter","holeRatio","noduleRadius","material","_ref$wireframe","wireframe","_useState","useState","_useState2","_slicedToArray","calculatedGeometry","setCalculatedGeometry","geometry","tempGeoList","_getDodecahedronData","mathVertices","mathFaceData","outerDodecGeo","innerDodecGeo","outerBrush","Brush","innerBrush","updateMatrixWorld","shellBrush","evaluate","SUBTRACTION","holeDiameters","length","i","pow","cylinderHeight","cylinderGeo","rotateX","PI","tempQuat","face","index","holeRadius","holeBrush","setFromUnitVectors","quaternion","copy","noduleGeo","vertexPos","noduleBrush","ADDITION","computeVertexNormals","g","meshMaterial","useMemo","baseMaterial","specular","shininess","name","ResonatorSimulation","_ref2","onStatusUpdate","groupRef","dodecahedronMeshRef","particlesRef","particleGeoRef","resonatorControls","useControls","baseFieldSpeed","min","max","step","fieldIntensity","k_drag","label","inertiaScale","spinUpRate","velocityThreshold","thresholdFeedbackFactor","fieldActive","noduleAntifieldStrength","shellControls","vizControls","particleCount","particleSize","torusMajorRadius","torusMinorRadius","showParticles","finalShellParams","effectiveInertia","batteryRef","thresholdModifierRef","chargingModeRef","physicsState","angularVelocity","fieldAngle","currentTorque","particleData","data","positions","Float32Array","u","random","R","r","randR","randr","cos","sin","yOffset","existingAttribute","getAttribute","array","setAttribute","deleteAttribute","_particleGeoRef$curre","delta","_particleGeoRef$curre2","_particleGeoRef$curre3","ps","actualThreshold","magneticFieldDir","sub","effectiveDragFactor","quat","dragSum","weightSum","worldNormal","applyQuaternion","alignment","dot","computeEffectiveDrag","dragTorque","currentSpeed","feedbackTorque","overage","netTorque","add","noduleTorque","nodulePos","contribution","cross","angularAccel","divideScalar","deltaAngle","rotationAxis","deltaQuat","setFromAxisAngle","multiply","currentMaterial","emissive","maxTorqueEst","emissionStrength","setHSL","attributes","pData","isNaN","undefined","originalX","originalZ","needsUpdate","speed","pointsMat","bufferIndex","battery","castShadow","receiveShadow","rotation","transparent","opacity","blending","sizeAttenuation","StatusOverlay","_ref3","status","internalLightActive","setInternalLightActive","batteryPercent","angularPercent","barContainer","width","borderRadius","overflow","marginBottom","fontFamily","padding","fontSize","cursor","onClick","LoadingPlaceholder","_useState3","_useState4","setStatus","_useState5","_useState6","_Fragment","Leva","collapsed","titleBar","title","Canvas","fov","antialias","shadows","intensity","groundColor","distance","decay","Suspense","fallback","StyledRoot","styled","bgGradient","alpha","default","mode","imgUrl","_defineProperty","breakpoints","up","StyledWrapper","marginTop","HEADER","H_DESKTOP_OFFSET","StyledTextGradient","h1","_ref4","textGradient","primary","warning","lineHeight","letterSpacing","textAlign","backgroundSize","_ref5","filter","WebkitFilter","backgroundColor","darker","_ref6","bottom","_ref7","_ref7$opacity","_ref7$anchor","anchor","bgBlur","clipPath","direction","transform","HomeHero","mdUp","useResponsive","useTheme","heroRef","scrollY","useScroll","percent","setPercent","isLight","getScroll","useCallback","heroHeight","offsetHeight","on","scrollHeight","scrollPercent","floor","transition","repeatType","ease","duration","repeat","Infinity","hide","renderDescription","Stack","alignItems","justifyContent","mx","maxWidth","mt","md","H_DESKTOP","variants","varFade","in","Typography","variant","animate","backgroundPosition","List","ListItem","ListItemText","fontWeight","secondary","spacing","xs","sm","mb","Button","RouterLink","href","startIcon","Iconify","icon","renderSlides2","TemporalResonatorScene","img","Container","MotionContainer","Grid","container","columnSpacing","_ref$anchor","display","grey","HomeView","HomePage","Helmet"],"sourceRoot":""}