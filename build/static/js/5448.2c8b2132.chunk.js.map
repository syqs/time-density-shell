{"version":3,"file":"static/js/5448.2c8b2132.chunk.js","mappings":"iNAoBMA,EAAa,SAACC,EAAGC,EAAIC,GAAE,SAAQ,EAAM,EAAMA,EAAK,EAAMD,GAAMD,GAAK,EAAME,EAAK,EAAMD,IAAOD,EAAI,EAAMC,GACrGD,CAAC,EACCG,EAAuB,KACvBC,EAA2B,GAkBjC,SAASC,EAAYC,EAAKC,EAAKC,EAAKC,GAEhC,GAAIH,IAAQC,GAAOC,IAAQC,EACvB,OAAOC,EAAAA,EACX,IAAMC,EAAW,SAACC,GAAE,OArBxB,SAAyBC,EAAGC,EAAYC,EAAYT,EAAKE,GACrD,IAAIQ,EACAC,EACAC,EAAI,EACR,IAEIF,EAAWjB,EADXkB,EAAWH,GAAcC,EAAaD,GAAc,EACpBR,EAAKE,GAAOK,GAC7B,EACXE,EAAaE,EAGbH,EAAaG,QAEZE,KAAKC,IAAIJ,GAAYb,KACxBe,EAAId,GACV,OAAOa,CACX,CAK6BI,CAAgBT,EAAI,EAAG,EAAGN,EAAKE,EAAI,EAE5D,OAAO,SAACR,GAAC,OAAW,IAANA,GAAiB,IAANA,EAAUA,EAAID,EAAWY,EAASX,GAAIO,EAAKE,EAAI,CAC5E,CC9CA,IAAMa,EAASjB,EAAY,IAAM,EAAG,EAAG,GACjCkB,EAAUlB,EAAY,EAAG,EAAG,IAAM,GAClCmB,EAAYnB,EAAY,IAAM,EAAG,IAAM,GCJvCoB,EAAgB,SAACC,GACnB,OAAOC,MAAMC,QAAQF,IAA4B,kBAAZA,EAAK,EAC9C,E,sDCEMG,EAAUxB,EAAY,IAAM,KAAM,IAAM,KACxCyB,GAASC,EAAAA,EAAAA,GAAcF,GACvBG,GAAYC,EAAAA,EAAAA,GAAaH,GCEzBI,EAAe,CACjBC,OAAQzB,EAAAA,EACRY,OAAAA,EACAE,UAAAA,EACAD,QAAAA,EACAa,OAAAA,EAAAA,GACAC,UAAAA,EAAAA,GACAC,QAAAA,EAAAA,GACAR,OAAAA,EACAE,UAAAA,EACAH,QAAAA,EACAU,WCjBe,SAACC,GAAC,OAAMA,GAAK,GAAK,EAAI,GAAMV,EAAOU,GAAK,IAAO,EAAIrB,KAAKsB,IAAI,GAAI,IAAMD,EAAI,IAAI,GDmB3FE,EAA6B,SAACC,GAChC,GAAIhB,MAAMC,QAAQe,GAAa,EAE3BC,EAAAA,EAAAA,GAAgC,IAAtBD,EAAWE,OAAc,2DACnC,IAAAC,GAAAC,EAAAA,EAAAA,GAAyBJ,EAAU,GACnC,OAAOtC,EADEyC,EAAA,GAAIA,EAAA,GAAIA,EAAA,GAAIA,EAAA,GAEzB,CACK,MAA0B,kBAAfH,IAEZC,EAAAA,EAAAA,QAAuCI,IAA7Bd,EAAaS,GAA2B,wBAAFM,OAA0BN,EAAU,MAC7ET,EAAaS,IAEjBA,CACX,E,qBExBA,SAASO,EAASC,GAA4E,IAHvEC,EAAQC,EAG+DC,EAAAH,EAAzEI,SAAAA,OAAQ,IAAAD,EAAG,IAAGA,EAAaE,EAAcL,EAAzBD,UAA2BO,EAAKN,EAALM,MAAKC,EAAAP,EAAEzB,KAAAA,OAAI,IAAAgC,EAAG,YAAWA,EAK/EC,EAAkBlC,EAAcC,GAChCA,EAAKkC,IAAIlB,GACTA,EAA2BhB,GAK3BmC,EAAQ,CACVC,MAAM,EACNC,MAAOP,EAAe,IAKpBQ,EC7BV,SAA8BC,EAAQV,GAClC,OAAOU,EAAOL,KAAI,SAACM,GAAC,OAAKA,EAAIX,CAAQ,GACzC,CD2B0BY,CAGtBV,GAASA,EAAMZ,SAAWW,EAAeX,OACnCY,GACAW,EAAAA,EAAAA,GAAcZ,GAAiBD,GAC/Bc,GAAoBC,EAAAA,EAAAA,GAAYN,EAAeR,EAAgB,CACjE9B,KAAMC,MAAMC,QAAQ+B,GACdA,GA9BSP,EA+BKI,EA/BGH,EA+BaM,EA9BjCP,EAAOQ,KAAI,kBAAMP,GAAU7B,CAAS,IAAE+C,OAAO,EAAGnB,EAAOP,OAAS,MAgCvE,MAAO,CACH2B,mBAAoBjB,EACpBkB,KAAM,SAACzE,GAGH,OAFA6D,EAAME,MAAQM,EAAkBrE,GAChC6D,EAAMC,KAAO9D,GAAKuD,EACXM,CACX,EAER,C,0BE9CMa,EAAyB,EAC/B,SAASC,EAAsBC,EAAc5E,EAAG6E,GAC5C,IAAMC,EAAQ3D,KAAK4D,IAAI/E,EAAI0E,EAAwB,GACnD,OAAOM,EAAAA,EAAAA,GAAkBH,EAAUD,EAAaE,GAAQ9E,EAAI8E,EAChE,C,cCFMG,EAAU,KACVC,EAAc,IACdC,EAAc,GACdC,EAAa,IACbC,EAAa,EACnB,SAASC,EAAUnC,GAA6D,IACxEoC,EACAC,EAFwElC,EAAAH,EAA1DI,SAAAA,OAAQ,IAAAD,EAAG,IAAGA,EAAAmC,EAAAtC,EAAEuC,OAAAA,OAAM,IAAAD,EAAG,IAAIA,EAAAE,EAAAxC,EAAEyC,SAAAA,OAAQ,IAAAD,EAAG,EAACA,EAAAE,EAAA1C,EAAE2C,KAAAA,OAAI,IAAAD,EAAG,EAACA,GAGvEE,EAAAA,EAAAA,GAAQxC,IAAYyC,EAAAA,EAAAA,GAAsBb,GAAc,8CACxD,IAAIc,EAAe,EAAIP,EAIvBO,GAAeC,EAAAA,EAAAA,GAAMd,EAAYC,EAAYY,GAC7C1C,GAAW2C,EAAAA,EAAAA,GAAMhB,EAAaC,GAAagB,EAAAA,EAAAA,GAAsB5C,IAC7D0C,EAAe,GAIfV,EAAW,SAACa,GACR,IAAMC,EAAmBD,EAAeH,EAClCK,EAAQD,EAAmB9C,EAC3BgD,EAAIF,EAAmBT,EACvBY,EAAIC,EAAgBL,EAAcH,GAClCS,EAAIvF,KAAKwF,KAAKL,GACpB,OAAOrB,EAAWsB,EAAIC,EAAKE,CAC/B,EACAlB,EAAa,SAACY,GACV,IACME,EADmBF,EAAeH,EACP1C,EAC3BqD,EAAIN,EAAQV,EAAWA,EACvBiB,EAAI1F,KAAKsB,IAAIwD,EAAc,GAAK9E,KAAKsB,IAAI2D,EAAc,GAAK7C,EAC5DuD,EAAI3F,KAAKwF,KAAKL,GACdS,EAAIN,EAAgBtF,KAAKsB,IAAI2D,EAAc,GAAIH,GAErD,QADgBV,EAASa,GAAgBnB,EAAU,GAAK,EAAI,KACzC2B,EAAIC,GAAKC,GAAMC,CACtC,IAMAxB,EAAW,SAACa,GAGR,OAFUjF,KAAKwF,KAAKP,EAAe7C,KACxB6C,EAAeR,GAAYrC,EAAW,GACzC0B,CACZ,EACAO,EAAa,SAACY,GAGV,OAFUjF,KAAKwF,KAAKP,EAAe7C,IACIA,EAAWA,GAAvCqC,EAAWQ,GAE1B,GAEJ,IACMA,EAmBV,SAAyBb,EAAUC,EAAYwB,GAE3C,IADA,IAAIC,EAASD,EACJ9F,EAAI,EAAGA,EAAIgG,EAAgBhG,IAChC+F,GAAkB1B,EAAS0B,GAAUzB,EAAWyB,GAEpD,OAAOA,CACX,CAzByBE,CAAgB5B,EAAUC,EAD1B,EAAIjC,GAGzB,GADAA,GAAWyC,EAAAA,EAAAA,GAAsBzC,GAC7B6D,MAAMhB,GACN,MAAO,CACHiB,UAAW,IACXC,QAAS,GACT/D,SAAAA,GAIJ,IAAM8D,EAAYlG,KAAKsB,IAAI2D,EAAc,GAAKN,EAC9C,MAAO,CACHuB,UAAAA,EACAC,QAAwB,EAAfrB,EAAmB9E,KAAKoG,KAAKzB,EAAOuB,GAC7C9D,SAAAA,EAGZ,CACA,IAAM2D,EAAiB,GAQvB,SAAST,EAAgBL,EAAcH,GACnC,OAAOG,EAAejF,KAAKoG,KAAK,EAAItB,EAAeA,EACvD,C,4CClFMuB,EAAe,CAAC,WAAY,UAC5BC,EAAc,CAAC,YAAa,UAAW,QAC7C,SAASC,EAAaC,EAASC,GAC3B,OAAOA,EAAKC,MAAK,SAACC,GAAG,YAAsB9E,IAAjB2E,EAAQG,EAAkB,GACxD,CAwBA,SAASC,EAAM5E,GAAkD,IAuBzD6E,EAvBU9E,EAASC,EAATD,UAAW+E,EAAS9E,EAAT8E,UAAWC,EAAS/E,EAAT+E,UAAcP,GAAOQ,EAAAA,EAAAA,GAAAhF,EAAAiF,GACnDC,EAASnF,EAAU,GACnBoF,EAASpF,EAAUA,EAAUL,OAAS,GAKtCgB,EAAQ,CAAEC,MAAM,EAAOC,MAAOsE,GACpCE,EA/BJ,SAA0BZ,GACtB,IAAIa,GAAaC,EAAAA,EAAAA,GAAA,CACb7C,SAAU,EACVyB,UAAW,IACXC,QAAS,GACTxB,KAAM,EACN4C,wBAAwB,GACrBf,GAGP,IAAKD,EAAaC,EAASF,IACvBC,EAAaC,EAASH,GAAe,CACrC,IAAMmB,EAAUrD,EAAWqC,IAC3Ba,GAAaC,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACND,GACAG,GAAO,IACV/C,SAAU,EACVE,KAAM,KAEI4C,wBAAyB,CAC3C,CACA,OAAOF,CACX,CASsFI,CAAiBjB,GAA3FN,EAASkB,EAATlB,UAAWC,EAAOiB,EAAPjB,QAASxB,EAAIyC,EAAJzC,KAAMF,EAAQ2C,EAAR3C,SAAUrC,EAAQgF,EAARhF,SAAUmF,EAAsBH,EAAtBG,uBAChDG,EAAkBjD,IAAYO,EAAAA,EAAAA,GAAsBP,GAAY,EAChEK,EAAeqB,GAAW,EAAInG,KAAKoG,KAAKF,EAAYvB,IACpDgD,EAAeR,EAASD,EACxBU,GAAsB5C,EAAAA,EAAAA,GAAsBhF,KAAKoG,KAAKF,EAAYvB,IAQlEkD,EAAkB7H,KAAKC,IAAI0H,GAAgB,EAIjD,GAHAZ,IAAcA,EAAYc,EAAkB,IAAO,GACnDf,IAAcA,EAAYe,EAAkB,KAAQ,IAEhD/C,EAAe,EAAG,CAClB,IAAMgD,EAAcxC,EAAgBsC,EAAqB9C,GAEzD+B,EAAgB,SAAChI,GACb,IAAMuF,EAAWpE,KAAKwF,KAAKV,EAAe8C,EAAsB/I,GAChE,OAAQsI,EACJ/C,IACOsD,EACC5C,EAAe8C,EAAsBD,GACrCG,EACA9H,KAAK+H,IAAID,EAAcjJ,GACvB8I,EAAe3H,KAAKgI,IAAIF,EAAcjJ,GACtD,CACJ,MACK,GAAqB,IAAjBiG,EAEL+B,EAAgB,SAAChI,GAAC,OAAKsI,EACnBnH,KAAKwF,KAAKoC,EAAsB/I,IAC3B8I,GACID,EAAkBE,EAAsBD,GAAgB9I,EAAE,MAEtE,CAED,IAAMoJ,EAAoBL,EAAsB5H,KAAKoG,KAAKtB,EAAeA,EAAe,GACxF+B,EAAgB,SAAChI,GACb,IAAMuF,EAAWpE,KAAKwF,KAAKV,EAAe8C,EAAsB/I,GAE1DqJ,EAAWlI,KAAKmI,IAAIF,EAAoBpJ,EAAG,KACjD,OAAQsI,EACH/C,IACKsD,EACE5C,EAAe8C,EAAsBD,GACrC3H,KAAKoI,KAAKF,GACVD,EACIN,EACA3H,KAAKqI,KAAKH,IAClBD,CACZ,CACJ,CACA,MAAO,CACH5E,mBAAoBkE,GAAyBnF,GAAmB,KAChEkB,KAAM,SAACzE,GACH,IAAM6E,EAAUmD,EAAchI,GAC9B,GAAK0I,EAqBD7E,EAAMC,KAAO9D,GAAKuD,MArBO,CACzB,IAAIkG,EAAkBZ,EACZ,IAAN7I,IAOIyJ,EADAxD,EAAe,EACGtB,EAAsBqD,EAAehI,EAAG6E,GAGxC,GAG1B,IAAM6E,EAA2BvI,KAAKC,IAAIqI,IAAoBvB,EACxDyB,EAA+BxI,KAAKC,IAAIkH,EAASzD,IAAYoD,EACnEpE,EAAMC,KACF4F,GAA4BC,CACpC,CAKA,OADA9F,EAAME,MAAQF,EAAMC,KAAOwE,EAASzD,EAC7BhB,CACX,EAER,CC3HA,SAAS+F,EAAOzG,GAAiK,IAA9JD,EAASC,EAATD,UAASyC,EAAAxC,EAAEyC,SAAAA,OAAQ,IAAAD,EAAG,EAAGA,EAAAkE,EAAA1G,EAAE2G,MAAAA,OAAK,IAAAD,EAAG,GAAGA,EAAAE,EAAA5G,EAAE6G,aAAAA,OAAY,IAAAD,EAAG,IAAGA,EAAAE,EAAA9G,EAAE+G,cAAAA,OAAa,IAAAD,EAAG,GAAEA,EAAAE,EAAAhH,EAAEiH,gBAAAA,OAAe,IAAAD,EAAG,IAAGA,EAAEE,EAAYlH,EAAZkH,aAAcf,EAAGnG,EAAHmG,IAAKvE,EAAG5B,EAAH4B,IAAGuF,EAAAnH,EAAE8E,UAAAA,OAAS,IAAAqC,EAAG,GAAGA,EAAEpC,EAAS/E,EAAT+E,UACzJG,EAASnF,EAAU,GACnBW,EAAQ,CACVC,MAAM,EACNC,MAAOsE,GAGLkC,EAAkB,SAACC,GACrB,YAAYxH,IAARsG,EACOvE,OACC/B,IAAR+B,GAEG5D,KAAKC,IAAIkI,EAAMkB,GAAKrJ,KAAKC,IAAI2D,EAAMyF,GAD/BlB,EAC0CvE,CACzD,EACI0F,EAAYX,EAAQlE,EAClB8E,EAAQrC,EAASoC,EACjBnC,OAA0BtF,IAAjBqH,EAA6BK,EAAQL,EAAaK,GAK7DpC,IAAWoC,IACXD,EAAYnC,EAASD,GACzB,IAcIsC,EACAC,EAfEC,EAAY,SAAC7K,GAAC,OAAMyK,EAAYtJ,KAAKwF,KAAK3G,EAAIgK,EAAa,EAC3Dc,EAAa,SAAC9K,GAAC,OAAKsI,EAASuC,EAAU7K,EAAE,EACzC+K,EAAgB,SAAC/K,GACnB,IAAMsG,EAAQuE,EAAU7K,GAClBgL,EAASF,EAAW9K,GAC1B6D,EAAMC,KAAO3C,KAAKC,IAAIkF,IAAU2B,EAChCpE,EAAME,MAAQF,EAAMC,KAAOwE,EAAS0C,CACxC,EASMC,EAAqB,SAACjL,GAjCN,IAACwK,KAkCA3G,EAAME,WAlCSf,IAARsG,GAAqBkB,EAAIlB,QAAiBtG,IAAR+B,GAAqByF,EAAIzF,KAoCrF4F,EAAsB3K,EACtB4K,EAAW7C,EAAO,CACd7E,UAAW,CAACW,EAAME,MAAOwG,EAAgB1G,EAAME,QAC/C6B,SAAUjB,EAAsBmG,EAAY9K,EAAG6D,EAAME,OACrDuD,QAAS4C,EACT7C,UAAW+C,EACXnC,UAAAA,EACAC,UAAAA,IAER,EAEA,OADA+C,EAAmB,GACZ,CACHzG,mBAAoB,KACpBC,KAAM,SAACzE,GAOH,IAAIkL,GAAkB,EAUtB,OATKN,QAAoC5H,IAAxB2H,IACbO,GAAkB,EAClBH,EAAc/K,GACdiL,EAAmBjL,SAMKgD,IAAxB2H,GAAqC3K,EAAI2K,EAClCC,EAASnG,KAAKzE,EAAI2K,KAGxBO,GAAmBH,EAAc/K,GAC3B6D,EAEf,EAER,C,0BCjFMsH,EAAkB,SAACC,GACrB,IAAMC,EAAgB,SAAHlI,GAAA,IAAMmI,EAASnI,EAATmI,UAAS,OAAOF,EAAOE,EAAU,EAC1D,MAAO,CACHC,MAAO,kBAAMC,EAAAA,GAAMJ,OAAOC,GAAe,EAAK,EAC9CI,KAAM,kBAAMC,EAAAA,EAAAA,IAAYL,EAAc,EAKtCM,IAAK,kBAAMC,EAAAA,EAAUC,aAAeD,EAAAA,EAAUN,UAAYQ,YAAYH,KAAK,EAEnF,ECVMI,EAAuB,IAC7B,SAASC,EAAsBC,GAI3B,IAHA,IAAI1I,EAAW,EAEXM,EAAQoI,EAAUxH,KAAKlB,IACnBM,EAAMC,MAAQP,EAAWwI,GAC7BxI,GAHa,GAIbM,EAAQoI,EAAUxH,KAAKlB,GAE3B,OAAOA,GAAYwI,EAAuBG,IAAW3I,CACzD,C,qICLM4I,EAAQ,CACVC,MAAOxC,EACPA,QAAAA,EACAyC,MAAOnJ,EACPA,UAAWA,EACX6E,OAAAA,GASJ,SAASuE,GAAYnJ,GAA2M,IAGxNoJ,EACAC,EAYAC,EAhBwNC,EAAAvJ,EAAxMwJ,SAAAA,OAAQ,IAAAD,GAAOA,EAAAE,EAAAzJ,EAAE0J,MAAAA,OAAK,IAAAD,EAAG,EAACA,EAAAE,EAAA3J,EAAE4J,OAAAA,OAAM,IAAAD,EAAG3B,EAAe2B,EAAaE,EAAW7J,EAAtBD,UAAS+J,EAAA9J,EAAe+J,KAAAA,OAAI,IAAAD,EAAG,YAAWA,EAAAE,EAAAhK,EAAEiK,OAAAA,OAAM,IAAAD,EAAG,EAACA,EAAAE,EAAAlK,EAAEmK,YAAAA,OAAW,IAAAD,EAAG,EAACA,EAAAE,EAAApK,EAAEqK,WAAAA,OAAU,IAAAD,EAAG,OAAMA,EAAEE,EAAMtK,EAANsK,OAAQC,EAAMvK,EAANuK,OAAQC,EAAUxK,EAAVwK,WAAYC,EAAQzK,EAARyK,SAAajG,GAAOQ,EAAAA,EAAAA,GAAAhF,EAAAiF,GACpNyF,EAAQ,EACRC,GAAa,EAOXC,EAAwB,WAC1BvB,EAAyB,IAAIwB,SAAQ,SAACC,GAClC1B,EAAyB0B,CAC7B,GACJ,EAEAF,IAEA,IAMIG,EANEC,EAAmBhC,EAAMe,IAAShK,EAOpCiL,IAAqBjL,GACK,kBAAnB8J,EAAY,KACnBkB,GAAwB5J,EAAAA,EAAAA,GAAY,CAAC,EAAG,KAAM0I,EAAa,CACvD9G,OAAO,IAEX8G,EAAc,CAAC,EAAG,MAEtB,IACIoB,EADEnC,EAAYkC,GAAgB1F,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAC,CAAC,EAAId,GAAO,IAAEzE,UAAW8J,KAEzC,WAAfQ,IACAY,EAAoBD,GAAgB1F,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAC,CAAC,EAC/Bd,GAAO,IACVzE,WAAWmL,EAAAA,EAAAA,GAAIrB,GAAasB,UAC5B1I,WAAY+B,EAAQ/B,UAAY,OAGxC,IAAI2I,EAAY,OACZC,EAAW,KACXC,EAAY,KACZC,EAAa,KASoB,OAAjCzC,EAAUzH,oBAA+B4I,IACzCnB,EAAUzH,mBAAqBwH,EAAsBC,IAEzD,IAAQzH,EAAuByH,EAAvBzH,mBACJmK,EAAmBzC,IACnB0C,EAAgB1C,IACO,OAAvB1H,IAEAoK,GADAD,EAAmBnK,EAAqB8I,IACJF,EAAS,GAAKE,GAEtD,IAAIuB,EAAc,EACZC,EAAO,SAACxD,GACV,GAAkB,OAAdmD,EAAJ,CAQIZ,EAAQ,IACRY,EAAYtN,KAAKmI,IAAImF,EAAWnD,IAChCuC,EAAQ,IACRY,EAAYtN,KAAKmI,IAAIgC,EAAYsD,EAAgBf,EAAOY,IAW5D,IAAMM,GATFF,EADa,OAAbL,EACcA,EAMArN,KAAK6N,MAAM1D,EAAYmD,GAAaZ,GAGfhB,GAASgB,GAAS,EAAI,GAAK,GAC5DoB,EAAiBpB,GAAS,EAAIkB,EAAmB,EAAIA,EAAmBH,EAC9EC,EAAc1N,KAAK4D,IAAIgK,EAAkB,GAKvB,aAAdR,GAAyC,OAAbC,IAC5BK,EAAcD,GAElB,IAAIM,EAAUL,EACVM,EAAiBlD,EACrB,GAAImB,EAAQ,CAMR,IAAMgC,EAAWP,EAAcF,EAK3BU,EAAmBlO,KAAKmO,MAAMF,GAK9BG,EAAoBH,EAAW,GAK9BG,GAAqBH,GAAY,IAClCG,EAAoB,GAEF,IAAtBA,GAA2BF,IAC3BA,EAAmBlO,KAAKmI,IAAI+F,EAAkBjC,EAAS,GAIvD,IAAMoC,EAAiBC,QAAQJ,EAAmB,GAC9CG,IACmB,YAAfhC,GACA+B,EAAoB,EAAIA,EACpBjC,IACAiC,GAAqBjC,EAAcqB,IAGnB,WAAfnB,IACL2B,EAAiBf,IAGzB,IAAI5L,GAAI0D,EAAAA,EAAAA,GAAM,EAAG,EAAGqJ,GAChBV,EAAcD,IACdpM,EAAmB,YAAfgL,GAA4BgC,EAAiB,EAAI,GAEzDN,EAAU1M,EAAImM,CAClB,CAMA,IAAM9K,EAAQoL,EACR,CAAEnL,MAAM,EAAOC,MAAOiJ,EAAY,IAClCmC,EAAe1K,KAAKyK,GACtBhB,IACArK,EAAME,MAAQmK,EAAsBrK,EAAME,QAE9C,IAAMD,EAASD,EAATC,KACDmL,GAAyC,OAAvBzK,IACnBV,EAAO+J,GAAS,EAAIgB,GAAeD,EAAgBC,GAAe,GAEtE,IAAMa,EAAmC,OAAblB,IACT,aAAdD,GAA2C,YAAdA,GAA2BzK,GAO7D,OANI8J,GACAA,EAAS/J,EAAME,OAEf2L,GACAC,IAEG9L,CAvGG,CAwGd,EACM+L,EAAsB,WACxBnD,GAAmBA,EAAgBhB,OACnCgB,OAAkBzJ,CACtB,EACM6M,EAAS,WACXtB,EAAY,OACZqB,IACArD,IACAwB,IACAU,EAAYC,EAAa,IAC7B,EACMiB,EAAS,WACXpB,EAAY,WACZZ,GAAcA,IACdiC,IACArD,GACJ,EACMuD,GAAO,WACT,IAAIhC,EAAJ,CAEKrB,IACDA,EAAkBM,EAAO+B,IAC7B,IAAMnD,EAAMc,EAAgBd,MAC5B8B,GAAUA,IACO,OAAbe,EACAC,EAAY9C,EAAM6C,EAEZC,GAA2B,aAAdF,IACnBE,EAAY9C,GAEE,aAAd4C,GACAR,IAEJW,EAAaD,EACbD,EAAW,KAKXD,EAAY,UACZ9B,EAAgBlB,OArBN,CAsBd,EACIoB,GACAmD,KAEJ,IAAMC,GAAW,CACbC,KAAI,SAAC/B,EAASgC,GACV,OAAOzD,EAAuBwD,KAAK/B,EAASgC,EAChD,EACIC,WACA,OAAO/J,EAAAA,EAAAA,GAAsB0I,EACjC,EACIqB,SAAKC,GACLA,GAAUnK,EAAAA,EAAAA,GAAsBmK,GAChCtB,EAAcsB,EACG,OAAb3B,GAAsB/B,GAA6B,IAAVoB,EAIzCY,EAAYhC,EAAgBd,MAAQwE,EAAUtC,EAH9CW,EAAW2B,CAKnB,EACI5M,eACA,IAAMA,EAA4C,OAAjC0I,EAAUzH,mBACrBwH,EAAsBC,GACtBA,EAAUzH,mBAChB,OAAO2B,EAAAA,EAAAA,GAAsB5C,EACjC,EACIsK,YACA,OAAOA,CACX,EACIA,UAAMuC,GACFA,IAAavC,GAAUpB,IAE3BoB,EAAQuC,EACRL,GAASG,MAAO/J,EAAAA,EAAAA,GAAsB0I,GAC1C,EACIhL,YACA,OAAO0K,CACX,EACAuB,KAAAA,GACAO,MAAO,WACH9B,EAAY,SACZC,EAAWK,CACf,EACApD,KAAM,WACFqC,GAAa,EACK,SAAdS,IAEJA,EAAY,OACZb,GAAUA,IACVmC,IACJ,EACAA,OAAQ,WACe,OAAfnB,GACAI,EAAKJ,GACTmB,GACJ,EACAS,SAAU,WACN/B,EAAY,UAChB,EACAgC,OAAQ,SAACrB,GAEL,OADAT,EAAY,EACLK,EAAKI,EAChB,GAEJ,OAAOa,EACX,C,kICzSM3N,EAAS,SAACI,GAAC,OAAK,EAAIrB,KAAK+H,IAAI/H,KAAKqP,KAAKhO,GAAG,EAC1CF,GAAUP,EAAAA,EAAAA,GAAcK,GACxBC,GAAYJ,EAAAA,EAAAA,GAAaK,E,wDCH/B,IAAML,EAAe,SAACoB,GAAM,OAAK,SAACb,GAAC,OAAKA,GAAK,GAAMa,EAAO,EAAIb,GAAK,GAAK,EAAIa,EAAO,GAAK,EAAIb,KAAO,CAAC,E,uDCApG,IAAMT,EAAgB,SAACsB,GAAM,OAAK,SAACb,GAAC,OAAK,EAAIa,EAAO,EAAIb,EAAE,E,+ECI1D,IAAMwD,EAAwB,SAACyK,GAAO,OAAe,IAAVA,CAAc,EACnDtK,EAAwB,SAACuK,GAAY,OAAKA,EAAe,GAAI,C","sources":["../node_modules/framer-motion/dist/es/easing/cubic-bezier.mjs","../node_modules/framer-motion/dist/es/easing/ease.mjs","../node_modules/framer-motion/dist/es/easing/utils/is-easing-array.mjs","../node_modules/framer-motion/dist/es/easing/back.mjs","../node_modules/framer-motion/dist/es/easing/utils/map.mjs","../node_modules/framer-motion/dist/es/easing/anticipate.mjs","../node_modules/framer-motion/dist/es/animation/generators/keyframes.mjs","../node_modules/framer-motion/dist/es/utils/offsets/time.mjs","../node_modules/framer-motion/dist/es/animation/generators/utils/velocity.mjs","../node_modules/framer-motion/dist/es/animation/generators/spring/find.mjs","../node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs","../node_modules/framer-motion/dist/es/animation/generators/inertia.mjs","../node_modules/framer-motion/dist/es/animation/animators/js/driver-frameloop.mjs","../node_modules/framer-motion/dist/es/animation/generators/utils/calc-duration.mjs","../node_modules/framer-motion/dist/es/animation/animators/js/index.mjs","../node_modules/framer-motion/dist/es/easing/circ.mjs","../node_modules/framer-motion/dist/es/easing/modifiers/mirror.mjs","../node_modules/framer-motion/dist/es/easing/modifiers/reverse.mjs","../node_modules/framer-motion/dist/es/utils/time-conversion.mjs"],"sourcesContent":["import { noop } from '../utils/noop.mjs';\n\n/*\n  Bezier function generator\n  This has been modified from GaÃ«tan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\n    t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noop;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexport { cubicBezier };\n","import { cubicBezier } from './cubic-bezier.mjs';\n\nconst easeIn = cubicBezier(0.42, 0, 1, 1);\nconst easeOut = cubicBezier(0, 0, 0.58, 1);\nconst easeInOut = cubicBezier(0.42, 0, 0.58, 1);\n\nexport { easeIn, easeInOut, easeOut };\n","const isEasingArray = (ease) => {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\nexport { isEasingArray };\n","import { cubicBezier } from './cubic-bezier.mjs';\nimport { mirrorEasing } from './modifiers/mirror.mjs';\nimport { reverseEasing } from './modifiers/reverse.mjs';\n\nconst backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);\nconst backIn = reverseEasing(backOut);\nconst backInOut = mirrorEasing(backIn);\n\nexport { backIn, backInOut, backOut };\n","import { invariant } from '../../utils/errors.mjs';\nimport { cubicBezier } from '../cubic-bezier.mjs';\nimport { noop } from '../../utils/noop.mjs';\nimport { easeIn, easeInOut, easeOut } from '../ease.mjs';\nimport { circIn, circInOut, circOut } from '../circ.mjs';\nimport { backIn, backInOut, backOut } from '../back.mjs';\nimport { anticipate } from '../anticipate.mjs';\n\nconst easingLookup = {\n    linear: noop,\n    easeIn,\n    easeInOut,\n    easeOut,\n    circIn,\n    circInOut,\n    circOut,\n    backIn,\n    backInOut,\n    backOut,\n    anticipate,\n};\nconst easingDefinitionToFunction = (definition) => {\n    if (Array.isArray(definition)) {\n        // If cubic bezier definition, create bezier curve\n        invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n        const [x1, y1, x2, y2] = definition;\n        return cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === \"string\") {\n        // Else lookup from table\n        invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\n        return easingLookup[definition];\n    }\n    return definition;\n};\n\nexport { easingDefinitionToFunction };\n","import { backIn } from './back.mjs';\n\nconst anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n\nexport { anticipate };\n","import { easeInOut } from '../../easing/ease.mjs';\nimport { isEasingArray } from '../../easing/utils/is-easing-array.mjs';\nimport { easingDefinitionToFunction } from '../../easing/utils/map.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { convertOffsetToTimes } from '../../utils/offsets/time.mjs';\n\nfunction defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = \"easeInOut\", }) {\n    /**\n     * Easing functions can be externally defined as strings. Here we convert them\n     * into actual functions.\n     */\n    const easingFunctions = isEasingArray(ease)\n        ? ease.map(easingDefinitionToFunction)\n        : easingDefinitionToFunction(ease);\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = {\n        done: false,\n        value: keyframeValues[0],\n    };\n    /**\n     * Create a times array based on the provided 0-1 offsets\n     */\n    const absoluteTimes = convertOffsetToTimes(\n    // Only use the provided offsets if they're the correct length\n    // TODO Maybe we should warn here if there's a length mismatch\n    times && times.length === keyframeValues.length\n        ? times\n        : defaultOffset(keyframeValues), duration);\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\n        ease: Array.isArray(easingFunctions)\n            ? easingFunctions\n            : defaultEasing(keyframeValues, easingFunctions),\n    });\n    return {\n        calculatedDuration: duration,\n        next: (t) => {\n            state.value = mapTimeToKeyframe(t);\n            state.done = t >= duration;\n            return state;\n        },\n    };\n}\n\nexport { defaultEasing, keyframes };\n","function convertOffsetToTimes(offset, duration) {\n    return offset.map((o) => o * duration);\n}\n\nexport { convertOffsetToTimes };\n","import { velocityPerSecond } from '../../../utils/velocity-per-second.mjs';\n\nconst velocitySampleDuration = 5; // ms\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n    const prevT = Math.max(t - velocitySampleDuration, 0);\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\n\nexport { calcGeneratorVelocity };\n","import { warning } from '../../../utils/errors.mjs';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { secondsToMilliseconds, millisecondsToSeconds } from '../../../utils/time-conversion.mjs';\n\nconst safeMin = 0.001;\nconst minDuration = 0.01;\nconst maxDuration = 10.0;\nconst minDamping = 0.05;\nconst maxDamping = 1;\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {\n    let envelope;\n    let derivative;\n    warning(duration <= secondsToMilliseconds(maxDuration), \"Spring duration must be 10 seconds or less\");\n    let dampingRatio = 1 - bounce;\n    /**\n     * Restrict dampingRatio and duration to within acceptable ranges.\n     */\n    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n    duration = clamp(minDuration, maxDuration, millisecondsToSeconds(duration));\n    if (dampingRatio < 1) {\n        /**\n         * Underdamped spring\n         */\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        /**\n         * Critically-damped spring\n         */\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = secondsToMilliseconds(duration);\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: 100,\n            damping: 10,\n            duration,\n        };\n    }\n    else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nexport { calcAngularFreq, findSpring, maxDamping, maxDuration, minDamping, minDuration };\n","import { millisecondsToSeconds } from '../../../utils/time-conversion.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: 0.0,\n        stiffness: 100,\n        damping: 10,\n        mass: 1.0,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        const derived = findSpring(options);\n        springOptions = {\n            ...springOptions,\n            ...derived,\n            velocity: 0.0,\n            mass: 1.0,\n        };\n        springOptions.isResolvedFromDuration = true;\n    }\n    return springOptions;\n}\nfunction spring({ keyframes, restDelta, restSpeed, ...options }) {\n    const origin = keyframes[0];\n    const target = keyframes[keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, velocity, duration, isResolvedFromDuration, } = getSpringOptions(options);\n    const initialVelocity = velocity ? -millisecondsToSeconds(velocity) : 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\n    restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    return {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = initialVelocity;\n                if (t !== 0) {\n                    /**\n                     * We only need to calculate velocity for under-damped springs\n                     * as over- and critically-damped springs can't overshoot, so\n                     * checking only for displacement is enough.\n                     */\n                    if (dampingRatio < 1) {\n                        currentVelocity = calcGeneratorVelocity(resolveSpring, t, current);\n                    }\n                    else {\n                        currentVelocity = 0;\n                    }\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n    };\n}\n\nexport { spring };\n","import { spring } from './spring/index.mjs';\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value),\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t > timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\nexport { inertia };\n","import { frame, cancelFrame } from '../../../frameloop/index.mjs';\nimport { frameData } from '../../../frameloop/data.mjs';\n\nconst frameloopDriver = (update) => {\n    const passTimestamp = ({ timestamp }) => update(timestamp);\n    return {\n        start: () => frame.update(passTimestamp, true),\n        stop: () => cancelFrame(passTimestamp),\n        /**\n         * If we're processing this frame we can use the\n         * framelocked timestamp to keep things in sync.\n         */\n        now: () => frameData.isProcessing ? frameData.timestamp : performance.now(),\n    };\n};\n\nexport { frameloopDriver };\n","/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxGeneratorDuration = 20000;\nfunction calcGeneratorDuration(generator) {\n    let duration = 0;\n    const timeStep = 50;\n    let state = generator.next(duration);\n    while (!state.done && duration < maxGeneratorDuration) {\n        duration += timeStep;\n        state = generator.next(duration);\n    }\n    return duration >= maxGeneratorDuration ? Infinity : duration;\n}\n\nexport { calcGeneratorDuration, maxGeneratorDuration };\n","import { keyframes } from '../../generators/keyframes.mjs';\nimport { spring } from '../../generators/spring/index.mjs';\nimport { inertia } from '../../generators/inertia.mjs';\nimport { frameloopDriver } from './driver-frameloop.mjs';\nimport { interpolate } from '../../../utils/interpolate.mjs';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../../utils/time-conversion.mjs';\nimport { calcGeneratorDuration } from '../../generators/utils/calc-duration.mjs';\n\nconst types = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\n/**\n * Animate a single value on the main thread.\n *\n * This function is written, where functionality overlaps,\n * to be largely spec-compliant with WAAPI to allow fungibility\n * between the two.\n */\nfunction animateValue({ autoplay = true, delay = 0, driver = frameloopDriver, keyframes: keyframes$1, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", onPlay, onStop, onComplete, onUpdate, ...options }) {\n    let speed = 1;\n    let hasStopped = false;\n    let resolveFinishedPromise;\n    let currentFinishedPromise;\n    /**\n     * Resolve the current Promise every time we enter the\n     * finished state. This is WAAPI-compatible behaviour.\n     */\n    const updateFinishedPromise = () => {\n        currentFinishedPromise = new Promise((resolve) => {\n            resolveFinishedPromise = resolve;\n        });\n    };\n    // Create the first finished promise\n    updateFinishedPromise();\n    let animationDriver;\n    const generatorFactory = types[type] || keyframes;\n    /**\n     * If this isn't the keyframes generator and we've been provided\n     * strings as keyframes, we need to interpolate these.\n     * TODO: Support velocity for units and complex value types/\n     */\n    let mapNumbersToKeyframes;\n    if (generatorFactory !== keyframes &&\n        typeof keyframes$1[0] !== \"number\") {\n        mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n            clamp: false,\n        });\n        keyframes$1 = [0, 100];\n    }\n    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\n    let mirroredGenerator;\n    if (repeatType === \"mirror\") {\n        mirroredGenerator = generatorFactory({\n            ...options,\n            keyframes: [...keyframes$1].reverse(),\n            velocity: -(options.velocity || 0),\n        });\n    }\n    let playState = \"idle\";\n    let holdTime = null;\n    let startTime = null;\n    let cancelTime = null;\n    /**\n     * If duration is undefined and we have repeat options,\n     * we need to calculate a duration from the generator.\n     *\n     * We set it to the generator itself to cache the duration.\n     * Any timeline resolver will need to have already precalculated\n     * the duration by this step.\n     */\n    if (generator.calculatedDuration === null && repeat) {\n        generator.calculatedDuration = calcGeneratorDuration(generator);\n    }\n    const { calculatedDuration } = generator;\n    let resolvedDuration = Infinity;\n    let totalDuration = Infinity;\n    if (calculatedDuration !== null) {\n        resolvedDuration = calculatedDuration + repeatDelay;\n        totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n    }\n    let currentTime = 0;\n    const tick = (timestamp) => {\n        if (startTime === null)\n            return;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (speed > 0)\n            startTime = Math.min(startTime, timestamp);\n        if (speed < 0)\n            startTime = Math.min(timestamp - totalDuration / speed, startTime);\n        if (holdTime !== null) {\n            currentTime = holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            currentTime = Math.round(timestamp - startTime) * speed;\n        }\n        // Rebase on delay\n        const timeWithoutDelay = currentTime - delay * (speed >= 0 ? 1 : -1);\n        const isInDelayPhase = speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\n        currentTime = Math.max(timeWithoutDelay, 0);\n        /**\n         * If this animation has finished, set the current time\n         * to the total duration.\n         */\n        if (playState === \"finished\" && holdTime === null) {\n            currentTime = totalDuration;\n        }\n        let elapsed = currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = currentTime / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const iterationIsOdd = Boolean(currentIteration % 2);\n            if (iterationIsOdd) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            let p = clamp(0, 1, iterationProgress);\n            if (currentTime > totalDuration) {\n                p = repeatType === \"reverse\" && iterationIsOdd ? 1 : 0;\n            }\n            elapsed = p * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes$1[0] }\n            : frameGenerator.next(elapsed);\n        if (mapNumbersToKeyframes) {\n            state.value = mapNumbersToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0;\n        }\n        const isAnimationFinished = holdTime === null &&\n            (playState === \"finished\" || (playState === \"running\" && done));\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            finish();\n        }\n        return state;\n    };\n    const stopAnimationDriver = () => {\n        animationDriver && animationDriver.stop();\n        animationDriver = undefined;\n    };\n    const cancel = () => {\n        playState = \"idle\";\n        stopAnimationDriver();\n        resolveFinishedPromise();\n        updateFinishedPromise();\n        startTime = cancelTime = null;\n    };\n    const finish = () => {\n        playState = \"finished\";\n        onComplete && onComplete();\n        stopAnimationDriver();\n        resolveFinishedPromise();\n    };\n    const play = () => {\n        if (hasStopped)\n            return;\n        if (!animationDriver)\n            animationDriver = driver(tick);\n        const now = animationDriver.now();\n        onPlay && onPlay();\n        if (holdTime !== null) {\n            startTime = now - holdTime;\n        }\n        else if (!startTime || playState === \"finished\") {\n            startTime = now;\n        }\n        if (playState === \"finished\") {\n            updateFinishedPromise();\n        }\n        cancelTime = startTime;\n        holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        playState = \"running\";\n        animationDriver.start();\n    };\n    if (autoplay) {\n        play();\n    }\n    const controls = {\n        then(resolve, reject) {\n            return currentFinishedPromise.then(resolve, reject);\n        },\n        get time() {\n            return millisecondsToSeconds(currentTime);\n        },\n        set time(newTime) {\n            newTime = secondsToMilliseconds(newTime);\n            currentTime = newTime;\n            if (holdTime !== null || !animationDriver || speed === 0) {\n                holdTime = newTime;\n            }\n            else {\n                startTime = animationDriver.now() - newTime / speed;\n            }\n        },\n        get duration() {\n            const duration = generator.calculatedDuration === null\n                ? calcGeneratorDuration(generator)\n                : generator.calculatedDuration;\n            return millisecondsToSeconds(duration);\n        },\n        get speed() {\n            return speed;\n        },\n        set speed(newSpeed) {\n            if (newSpeed === speed || !animationDriver)\n                return;\n            speed = newSpeed;\n            controls.time = millisecondsToSeconds(currentTime);\n        },\n        get state() {\n            return playState;\n        },\n        play,\n        pause: () => {\n            playState = \"paused\";\n            holdTime = currentTime;\n        },\n        stop: () => {\n            hasStopped = true;\n            if (playState === \"idle\")\n                return;\n            playState = \"idle\";\n            onStop && onStop();\n            cancel();\n        },\n        cancel: () => {\n            if (cancelTime !== null)\n                tick(cancelTime);\n            cancel();\n        },\n        complete: () => {\n            playState = \"finished\";\n        },\n        sample: (elapsed) => {\n            startTime = 0;\n            return tick(elapsed);\n        },\n    };\n    return controls;\n}\n\nexport { animateValue };\n","import { mirrorEasing } from './modifiers/mirror.mjs';\nimport { reverseEasing } from './modifiers/reverse.mjs';\n\nconst circIn = (p) => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circOut);\n\nexport { circIn, circInOut, circOut };\n","// Accepts an easing function and returns a new one that outputs mirrored values for\n// the second half of the animation. Turns easeIn into easeInOut.\nconst mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\nexport { mirrorEasing };\n","// Accepts an easing function and returns a new one that outputs reversed values.\n// Turns easeIn into easeOut.\nconst reverseEasing = (easing) => (p) => 1 - easing(1 - p);\n\nexport { reverseEasing };\n","/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\nconst secondsToMilliseconds = (seconds) => seconds * 1000;\nconst millisecondsToSeconds = (milliseconds) => milliseconds / 1000;\n\nexport { millisecondsToSeconds, secondsToMilliseconds };\n"],"names":["calcBezier","t","a1","a2","subdivisionPrecision","subdivisionMaxIterations","cubicBezier","mX1","mY1","mX2","mY2","noop","getTForX","aX","x","lowerBound","upperBound","currentX","currentT","i","Math","abs","binarySubdivide","easeIn","easeOut","easeInOut","isEasingArray","ease","Array","isArray","backOut","backIn","reverseEasing","backInOut","mirrorEasing","easingLookup","linear","circIn","circInOut","circOut","anticipate","p","pow","easingDefinitionToFunction","definition","invariant","length","_definition","_slicedToArray","undefined","concat","keyframes","_ref","values","easing","_ref$duration","duration","keyframeValues","times","_ref$ease","easingFunctions","map","state","done","value","absoluteTimes","offset","o","convertOffsetToTimes","defaultOffset","mapTimeToKeyframe","interpolate","splice","calculatedDuration","next","velocitySampleDuration","calcGeneratorVelocity","resolveValue","current","prevT","max","velocityPerSecond","safeMin","minDuration","maxDuration","minDamping","maxDamping","findSpring","envelope","derivative","_ref$bounce","bounce","_ref$velocity","velocity","_ref$mass","mass","warning","secondsToMilliseconds","dampingRatio","clamp","millisecondsToSeconds","undampedFreq","exponentialDecay","delta","a","b","calcAngularFreq","c","exp","d","e","f","g","initialGuess","result","rootIterations","approximateRoot","isNaN","stiffness","damping","sqrt","durationKeys","physicsKeys","isSpringType","options","keys","some","key","spring","resolveSpring","restDelta","restSpeed","_objectWithoutProperties","_excluded","origin","target","_getSpringOptions","springOptions","_objectSpread","isResolvedFromDuration","derived","getSpringOptions","initialVelocity","initialDelta","undampedAngularFreq","isGranularScale","angularFreq","sin","cos","dampedAngularFreq","freqForT","min","sinh","cosh","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","inertia","_ref$power","power","_ref$timeConstant","timeConstant","_ref$bounceDamping","bounceDamping","_ref$bounceStiffness","bounceStiffness","modifyTarget","_ref$restDelta","nearestBoundary","v","amplitude","ideal","timeReachedBoundary","spring$1","calcDelta","calcLatest","applyFriction","latest","checkCatchBoundary","hasUpdatedFrame","frameloopDriver","update","passTimestamp","timestamp","start","frame","stop","cancelFrame","now","frameData","isProcessing","performance","maxGeneratorDuration","calcGeneratorDuration","generator","Infinity","types","decay","tween","animateValue","resolveFinishedPromise","currentFinishedPromise","animationDriver","_ref$autoplay","autoplay","_ref$delay","delay","_ref$driver","driver","keyframes$1","_ref$type","type","_ref$repeat","repeat","_ref$repeatDelay","repeatDelay","_ref$repeatType","repeatType","onPlay","onStop","onComplete","onUpdate","speed","hasStopped","updateFinishedPromise","Promise","resolve","mapNumbersToKeyframes","generatorFactory","mirroredGenerator","_toConsumableArray","reverse","playState","holdTime","startTime","cancelTime","resolvedDuration","totalDuration","currentTime","tick","timeWithoutDelay","round","isInDelayPhase","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","iterationIsOdd","Boolean","isAnimationFinished","finish","stopAnimationDriver","cancel","play","controls","then","reject","time","newTime","newSpeed","pause","complete","sample","acos","seconds","milliseconds"],"sourceRoot":""}