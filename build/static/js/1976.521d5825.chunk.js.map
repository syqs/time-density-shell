{"version":3,"file":"static/js/1976.521d5825.chunk.js","mappings":"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","sources":["../node_modules/@mui/material/Menu/menuClasses.js","../node_modules/@mui/material/Menu/Menu.js","../node_modules/@mui/material/utils/getScrollbarSize.js","../node_modules/@mui/material/MenuList/MenuList.js"],"sourcesContent":["import { unstable_generateUtilityClasses as generateUtilityClasses } from '@mui/utils';\nimport generateUtilityClass from '../generateUtilityClass';\nexport function getMenuUtilityClass(slot) {\n  return generateUtilityClass('MuiMenu', slot);\n}\nconst menuClasses = generateUtilityClasses('MuiMenu', ['root', 'paper', 'list']);\nexport default menuClasses;","'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"onEntering\"],\n  _excluded2 = [\"autoFocus\", \"children\", \"disableAutoFocusItem\", \"MenuListProps\", \"onClose\", \"open\", \"PaperProps\", \"PopoverClasses\", \"transitionDuration\", \"TransitionProps\", \"variant\"];\nimport * as React from 'react';\nimport { isFragment } from 'react-is';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { unstable_composeClasses as composeClasses } from '@mui/base';\nimport { HTMLElementType } from '@mui/utils';\nimport MenuList from '../MenuList';\nimport Popover, { PopoverPaper } from '../Popover';\nimport styled, { rootShouldForwardProp } from '../styles/styled';\nimport useTheme from '../styles/useTheme';\nimport useThemeProps from '../styles/useThemeProps';\nimport { getMenuUtilityClass } from './menuClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst RTL_ORIGIN = {\n  vertical: 'top',\n  horizontal: 'right'\n};\nconst LTR_ORIGIN = {\n  vertical: 'top',\n  horizontal: 'left'\n};\nconst useUtilityClasses = ownerState => {\n  const {\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root'],\n    paper: ['paper'],\n    list: ['list']\n  };\n  return composeClasses(slots, getMenuUtilityClass, classes);\n};\nconst MenuRoot = styled(Popover, {\n  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',\n  name: 'MuiMenu',\n  slot: 'Root',\n  overridesResolver: (props, styles) => styles.root\n})({});\nexport const MenuPaper = styled(PopoverPaper, {\n  name: 'MuiMenu',\n  slot: 'Paper',\n  overridesResolver: (props, styles) => styles.paper\n})({\n  // specZ: The maximum height of a simple menu should be one or more rows less than the view\n  // height. This ensures a tappable area outside of the simple menu with which to dismiss\n  // the menu.\n  maxHeight: 'calc(100% - 96px)',\n  // Add iOS momentum scrolling for iOS < 13.0\n  WebkitOverflowScrolling: 'touch'\n});\nconst MenuMenuList = styled(MenuList, {\n  name: 'MuiMenu',\n  slot: 'List',\n  overridesResolver: (props, styles) => styles.list\n})({\n  // We disable the focus ring for mouse, touch and keyboard users.\n  outline: 0\n});\nconst Menu = /*#__PURE__*/React.forwardRef(function Menu(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiMenu'\n  });\n  const {\n      autoFocus = true,\n      children,\n      disableAutoFocusItem = false,\n      MenuListProps = {},\n      onClose,\n      open,\n      PaperProps = {},\n      PopoverClasses,\n      transitionDuration = 'auto',\n      TransitionProps: {\n        onEntering\n      } = {},\n      variant = 'selectedMenu'\n    } = props,\n    TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded),\n    other = _objectWithoutPropertiesLoose(props, _excluded2);\n  const theme = useTheme();\n  const isRtl = theme.direction === 'rtl';\n  const ownerState = _extends({}, props, {\n    autoFocus,\n    disableAutoFocusItem,\n    MenuListProps,\n    onEntering,\n    PaperProps,\n    transitionDuration,\n    TransitionProps,\n    variant\n  });\n  const classes = useUtilityClasses(ownerState);\n  const autoFocusItem = autoFocus && !disableAutoFocusItem && open;\n  const menuListActionsRef = React.useRef(null);\n  const handleEntering = (element, isAppearing) => {\n    if (menuListActionsRef.current) {\n      menuListActionsRef.current.adjustStyleForScrollbar(element, theme);\n    }\n    if (onEntering) {\n      onEntering(element, isAppearing);\n    }\n  };\n  const handleListKeyDown = event => {\n    if (event.key === 'Tab') {\n      event.preventDefault();\n      if (onClose) {\n        onClose(event, 'tabKeyDown');\n      }\n    }\n  };\n\n  /**\n   * the index of the item should receive focus\n   * in a `variant=\"selectedMenu\"` it's the first `selected` item\n   * otherwise it's the very first item.\n   */\n  let activeItemIndex = -1;\n  // since we inject focus related props into children we have to do a lookahead\n  // to check if there is a `selected` item. We're looking for the last `selected`\n  // item and use the first valid item as a fallback\n  React.Children.map(children, (child, index) => {\n    if (! /*#__PURE__*/React.isValidElement(child)) {\n      return;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (isFragment(child)) {\n        console.error([\"MUI: The Menu component doesn't accept a Fragment as a child.\", 'Consider providing an array instead.'].join('\\n'));\n      }\n    }\n    if (!child.props.disabled) {\n      if (variant === 'selectedMenu' && child.props.selected) {\n        activeItemIndex = index;\n      } else if (activeItemIndex === -1) {\n        activeItemIndex = index;\n      }\n    }\n  });\n  return /*#__PURE__*/_jsx(MenuRoot, _extends({\n    onClose: onClose,\n    anchorOrigin: {\n      vertical: 'bottom',\n      horizontal: isRtl ? 'right' : 'left'\n    },\n    transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,\n    slots: {\n      paper: MenuPaper\n    },\n    slotProps: {\n      paper: _extends({}, PaperProps, {\n        classes: _extends({}, PaperProps.classes, {\n          root: classes.paper\n        })\n      })\n    },\n    className: classes.root,\n    open: open,\n    ref: ref,\n    transitionDuration: transitionDuration,\n    TransitionProps: _extends({\n      onEntering: handleEntering\n    }, TransitionProps),\n    ownerState: ownerState\n  }, other, {\n    classes: PopoverClasses,\n    children: /*#__PURE__*/_jsx(MenuMenuList, _extends({\n      onKeyDown: handleListKeyDown,\n      actions: menuListActionsRef,\n      autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),\n      autoFocusItem: autoFocusItem,\n      variant: variant\n    }, MenuListProps, {\n      className: clsx(classes.list, MenuListProps.className),\n      children: children\n    }))\n  }));\n});\nprocess.env.NODE_ENV !== \"production\" ? Menu.propTypes /* remove-proptypes */ = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n  /**\n   * An HTML element, or a function that returns one.\n   * It's used to set the position of the menu.\n   */\n  anchorEl: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([HTMLElementType, PropTypes.func]),\n  /**\n   * If `true` (Default) will focus the `[role=\"menu\"]` if no focusable child is found. Disabled\n   * children are not focusable. If you set this prop to `false` focus will be placed\n   * on the parent modal container. This has severe accessibility implications\n   * and should only be considered if you manage focus otherwise.\n   * @default true\n   */\n  autoFocus: PropTypes.bool,\n  /**\n   * Menu contents, normally `MenuItem`s.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * When opening the menu will not focus the active item but the `[role=\"menu\"]`\n   * unless `autoFocus` is also set to `false`. Not using the default means not\n   * following WAI-ARIA authoring practices. Please be considerate about possible\n   * accessibility implications.\n   * @default false\n   */\n  disableAutoFocusItem: PropTypes.bool,\n  /**\n   * Props applied to the [`MenuList`](/material-ui/api/menu-list/) element.\n   * @default {}\n   */\n  MenuListProps: PropTypes.object,\n  /**\n   * Callback fired when the component requests to be closed.\n   *\n   * @param {object} event The event source of the callback.\n   * @param {string} reason Can be: `\"escapeKeyDown\"`, `\"backdropClick\"`, `\"tabKeyDown\"`.\n   */\n  onClose: PropTypes.func,\n  /**\n   * If `true`, the component is shown.\n   */\n  open: PropTypes.bool.isRequired,\n  /**\n   * @ignore\n   */\n  PaperProps: PropTypes.object,\n  /**\n   * `classes` prop applied to the [`Popover`](/material-ui/api/popover/) element.\n   */\n  PopoverClasses: PropTypes.object,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n  /**\n   * The length of the transition in `ms`, or 'auto'\n   * @default 'auto'\n   */\n  transitionDuration: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number, PropTypes.shape({\n    appear: PropTypes.number,\n    enter: PropTypes.number,\n    exit: PropTypes.number\n  })]),\n  /**\n   * Props applied to the transition element.\n   * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition/) component.\n   * @default {}\n   */\n  TransitionProps: PropTypes.object,\n  /**\n   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus.\n   * @default 'selectedMenu'\n   */\n  variant: PropTypes.oneOf(['menu', 'selectedMenu'])\n} : void 0;\nexport default Menu;","import { unstable_getScrollbarSize as getScrollbarSize } from '@mui/utils';\nexport default getScrollbarSize;","'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"actions\", \"autoFocus\", \"autoFocusItem\", \"children\", \"className\", \"disabledItemsFocusable\", \"disableListWrap\", \"onKeyDown\", \"variant\"];\nimport * as React from 'react';\nimport { isFragment } from 'react-is';\nimport PropTypes from 'prop-types';\nimport ownerDocument from '../utils/ownerDocument';\nimport List from '../List';\nimport getScrollbarSize from '../utils/getScrollbarSize';\nimport useForkRef from '../utils/useForkRef';\nimport useEnhancedEffect from '../utils/useEnhancedEffect';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction nextItem(list, item, disableListWrap) {\n  if (list === item) {\n    return list.firstChild;\n  }\n  if (item && item.nextElementSibling) {\n    return item.nextElementSibling;\n  }\n  return disableListWrap ? null : list.firstChild;\n}\nfunction previousItem(list, item, disableListWrap) {\n  if (list === item) {\n    return disableListWrap ? list.firstChild : list.lastChild;\n  }\n  if (item && item.previousElementSibling) {\n    return item.previousElementSibling;\n  }\n  return disableListWrap ? null : list.lastChild;\n}\nfunction textCriteriaMatches(nextFocus, textCriteria) {\n  if (textCriteria === undefined) {\n    return true;\n  }\n  let text = nextFocus.innerText;\n  if (text === undefined) {\n    // jsdom doesn't support innerText\n    text = nextFocus.textContent;\n  }\n  text = text.trim().toLowerCase();\n  if (text.length === 0) {\n    return false;\n  }\n  if (textCriteria.repeating) {\n    return text[0] === textCriteria.keys[0];\n  }\n  return text.indexOf(textCriteria.keys.join('')) === 0;\n}\nfunction moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {\n  let wrappedOnce = false;\n  let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);\n  while (nextFocus) {\n    // Prevent infinite loop.\n    if (nextFocus === list.firstChild) {\n      if (wrappedOnce) {\n        return false;\n      }\n      wrappedOnce = true;\n    }\n\n    // Same logic as useAutocomplete.js\n    const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true';\n    if (!nextFocus.hasAttribute('tabindex') || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {\n      // Move to the next element.\n      nextFocus = traversalFunction(list, nextFocus, disableListWrap);\n    } else {\n      nextFocus.focus();\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * A permanently displayed menu following https://www.w3.org/WAI/ARIA/apg/patterns/menu-button/.\n * It's exposed to help customization of the [`Menu`](/material-ui/api/menu/) component if you\n * use it separately you need to move focus into the component manually. Once\n * the focus is placed inside the component it is fully keyboard accessible.\n */\nconst MenuList = /*#__PURE__*/React.forwardRef(function MenuList(props, ref) {\n  const {\n      // private\n      // eslint-disable-next-line react/prop-types\n      actions,\n      autoFocus = false,\n      autoFocusItem = false,\n      children,\n      className,\n      disabledItemsFocusable = false,\n      disableListWrap = false,\n      onKeyDown,\n      variant = 'selectedMenu'\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const listRef = React.useRef(null);\n  const textCriteriaRef = React.useRef({\n    keys: [],\n    repeating: true,\n    previousKeyMatched: true,\n    lastTime: null\n  });\n  useEnhancedEffect(() => {\n    if (autoFocus) {\n      listRef.current.focus();\n    }\n  }, [autoFocus]);\n  React.useImperativeHandle(actions, () => ({\n    adjustStyleForScrollbar: (containerElement, theme) => {\n      // Let's ignore that piece of logic if users are already overriding the width\n      // of the menu.\n      const noExplicitWidth = !listRef.current.style.width;\n      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {\n        const scrollbarSize = `${getScrollbarSize(ownerDocument(containerElement))}px`;\n        listRef.current.style[theme.direction === 'rtl' ? 'paddingLeft' : 'paddingRight'] = scrollbarSize;\n        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;\n      }\n      return listRef.current;\n    }\n  }), []);\n  const handleKeyDown = event => {\n    const list = listRef.current;\n    const key = event.key;\n    /**\n     * @type {Element} - will always be defined since we are in a keydown handler\n     * attached to an element. A keydown event is either dispatched to the activeElement\n     * or document.body or document.documentElement. Only the first case will\n     * trigger this specific handler.\n     */\n    const currentFocus = ownerDocument(list).activeElement;\n    if (key === 'ArrowDown') {\n      // Prevent scroll of the page\n      event.preventDefault();\n      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);\n    } else if (key === 'ArrowUp') {\n      event.preventDefault();\n      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);\n    } else if (key === 'Home') {\n      event.preventDefault();\n      moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);\n    } else if (key === 'End') {\n      event.preventDefault();\n      moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);\n    } else if (key.length === 1) {\n      const criteria = textCriteriaRef.current;\n      const lowerKey = key.toLowerCase();\n      const currTime = performance.now();\n      if (criteria.keys.length > 0) {\n        // Reset\n        if (currTime - criteria.lastTime > 500) {\n          criteria.keys = [];\n          criteria.repeating = true;\n          criteria.previousKeyMatched = true;\n        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {\n          criteria.repeating = false;\n        }\n      }\n      criteria.lastTime = currTime;\n      criteria.keys.push(lowerKey);\n      const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);\n      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {\n        event.preventDefault();\n      } else {\n        criteria.previousKeyMatched = false;\n      }\n    }\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n  };\n  const handleRef = useForkRef(listRef, ref);\n\n  /**\n   * the index of the item should receive focus\n   * in a `variant=\"selectedMenu\"` it's the first `selected` item\n   * otherwise it's the very first item.\n   */\n  let activeItemIndex = -1;\n  // since we inject focus related props into children we have to do a lookahead\n  // to check if there is a `selected` item. We're looking for the last `selected`\n  // item and use the first valid item as a fallback\n  React.Children.forEach(children, (child, index) => {\n    if (! /*#__PURE__*/React.isValidElement(child)) {\n      if (activeItemIndex === index) {\n        activeItemIndex += 1;\n        if (activeItemIndex >= children.length) {\n          // there are no focusable items within the list.\n          activeItemIndex = -1;\n        }\n      }\n      return;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (isFragment(child)) {\n        console.error([\"MUI: The Menu component doesn't accept a Fragment as a child.\", 'Consider providing an array instead.'].join('\\n'));\n      }\n    }\n    if (!child.props.disabled) {\n      if (variant === 'selectedMenu' && child.props.selected) {\n        activeItemIndex = index;\n      } else if (activeItemIndex === -1) {\n        activeItemIndex = index;\n      }\n    }\n    if (activeItemIndex === index && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {\n      activeItemIndex += 1;\n      if (activeItemIndex >= children.length) {\n        // there are no focusable items within the list.\n        activeItemIndex = -1;\n      }\n    }\n  });\n  const items = React.Children.map(children, (child, index) => {\n    if (index === activeItemIndex) {\n      const newChildProps = {};\n      if (autoFocusItem) {\n        newChildProps.autoFocus = true;\n      }\n      if (child.props.tabIndex === undefined && variant === 'selectedMenu') {\n        newChildProps.tabIndex = 0;\n      }\n      return /*#__PURE__*/React.cloneElement(child, newChildProps);\n    }\n    return child;\n  });\n  return /*#__PURE__*/_jsx(List, _extends({\n    role: \"menu\",\n    ref: handleRef,\n    className: className,\n    onKeyDown: handleKeyDown,\n    tabIndex: autoFocus ? 0 : -1\n  }, other, {\n    children: items\n  }));\n});\nprocess.env.NODE_ENV !== \"production\" ? MenuList.propTypes /* remove-proptypes */ = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n  /**\n   * If `true`, will focus the `[role=\"menu\"]` container and move into tab order.\n   * @default false\n   */\n  autoFocus: PropTypes.bool,\n  /**\n   * If `true`, will focus the first menuitem if `variant=\"menu\"` or selected item\n   * if `variant=\"selectedMenu\"`.\n   * @default false\n   */\n  autoFocusItem: PropTypes.bool,\n  /**\n   * MenuList contents, normally `MenuItem`s.\n   */\n  children: PropTypes.node,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * If `true`, will allow focus on disabled items.\n   * @default false\n   */\n  disabledItemsFocusable: PropTypes.bool,\n  /**\n   * If `true`, the menu items will not wrap focus.\n   * @default false\n   */\n  disableListWrap: PropTypes.bool,\n  /**\n   * @ignore\n   */\n  onKeyDown: PropTypes.func,\n  /**\n   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus\n   * and the vertical alignment relative to the anchor element.\n   * @default 'selectedMenu'\n   */\n  variant: PropTypes.oneOf(['menu', 'selectedMenu'])\n} : void 0;\nexport default MenuList;"],"names":["getMenuUtilityClass","slot","generateUtilityClass","generateUtilityClasses","_excluded","_excluded2","RTL_ORIGIN","vertical","horizontal","LTR_ORIGIN","MenuRoot","styled","Popover","shouldForwardProp","prop","rootShouldForwardProp","name","overridesResolver","props","styles","root","MenuPaper","PopoverPaper","paper","maxHeight","WebkitOverflowScrolling","MenuMenuList","MenuList","list","outline","React","inProps","ref","useThemeProps","_props$autoFocus","autoFocus","children","_props$disableAutoFoc","disableAutoFocusItem","_props$MenuListProps","MenuListProps","onClose","open","_props$PaperProps","PaperProps","PopoverClasses","_props$transitionDura","transitionDuration","_props$TransitionProp","TransitionProps","onEntering","_props$variant","variant","_objectWithoutPropertiesLoose","other","theme","useTheme","isRtl","direction","ownerState","_extends","classes","composeClasses","useUtilityClasses","autoFocusItem","menuListActionsRef","activeItemIndex","map","child","index","disabled","selected","_jsx","anchorOrigin","transformOrigin","slots","slotProps","className","element","isAppearing","current","adjustStyleForScrollbar","onKeyDown","event","key","preventDefault","actions","clsx","nextItem","item","disableListWrap","firstChild","nextElementSibling","previousItem","lastChild","previousElementSibling","textCriteriaMatches","nextFocus","textCriteria","undefined","text","innerText","textContent","trim","toLowerCase","length","repeating","keys","indexOf","join","moveFocus","currentFocus","disabledItemsFocusable","traversalFunction","wrappedOnce","nextFocusDisabled","getAttribute","hasAttribute","focus","_props$autoFocusItem","_props$disabledItemsF","_props$disableListWra","listRef","textCriteriaRef","previousKeyMatched","lastTime","useEnhancedEffect","containerElement","noExplicitWidth","style","width","clientHeight","scrollbarSize","concat","getScrollbarSize","ownerDocument","handleRef","useForkRef","forEach","muiSkipListHighlight","type","items","newChildProps","tabIndex","List","role","activeElement","criteria","lowerKey","currTime","performance","now","push","keepFocusOnCurrent"],"sourceRoot":""}